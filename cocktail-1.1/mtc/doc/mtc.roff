.if t \{ \
.po 2.5c	\" page offset (left margin)
.		\" Umlauts and sharp s
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.\}
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.		\" Umlauts and sharp s
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s sz
.\}
.de iE
.iT \\$1 \\$2 \\$3 \\$4 1u \\$5
.ev 1
.iT \\$1 \\$2 \\$3 \\$4 1u \\$5
.ev
.ev 2
.iT \\$1 \\$2 \\$3 \\$4 10u/12u \\$5
.nr nV \\n(.vu
.ev
..
.de iT
.c2 ?
.lg 0
.hy \\$6
.hc \%
.ft \\$2
.ps \\$3*\\$5
.nr tt \\$4
.vs \\n(ttu*\\$5
.nr tt \\$1
.if t \{ \
.ll \\n(ttu
.lt \\n(ttu
.\}
..
.de iP
.nr tt \\$1
.\" po \\n(ttu
.nr tt \\$2
.pl \\n(ttu
.nr kA \\$3
.nr kB \\$4
.nr kC \\$5
.nr tt \\$6
.nr fA \\n(.pu-\\n(ttu-1v
.nr tt \\$7
.nr fB \\n(.pu-\\n(ttu-1v
.nr tt \\$8
.nr fC \\n(.pu-\\n(ttu-1v
.nr s1 1
.wh 0 kT
.nr fP \\n(fCu
.wh \\n(fPu fT
.nr bO 0
.nr bN 0
.wh 9999u nT
.nr nO 0
.nr nN 0
.nr nZ 0
.em sE
..
.de iD
.nh
.ev 1
.nh
.ev
.ev 2
.nh
.ev
..
.de kT
.ev 1
.nr sN +1
.nf
.sp |\\n(kAu
.ie \\n(s1 \{\
.tl '\\*(k7'\\*(k8'\\*(k9'
.\}
.el \{\
.ie \\n(sN%2   .tl '\\*(k1'\\*(k2'\\*(k3'
.el .tl '\\*(k4'\\*(k5'\\*(k6'
.\}
.sp |\\n(kBu
.kX
.sp |\\n(kCu
.if \\n(bO \{\
.nr bO 0
.bK
.di bK
.di
.\}
.if \\n(nO \{\
.nr nO 0
.ev 2
.da nF
\l'5c'
.br
.nK
.br
.di
.ev
.nr fP -\\n(dnu
.if !(\\n(fPu-\\n(nlu) .nr fP \\n(nlu+1v
.ch fT \\n(fPu
.nr nN 1
.di nK
.di
.\}
.nr nZ 0
.ev
.ns
..
.de fT
.ev 1
.nf
.if \\n(bN \{\
.nr bN 0
.bF
.di bF
.di
.\}
.if \\n(nN \{\
.nr nN 0
.nr nO 0
.ch nT \\n(fCu
.nF
.if \\n(nO \{\
.  di
.  if !\\n(dn .nr nO 0
.  \}
.di nF
.di
.ch nT 9999u
.\}
.sp |\\n(fBu
.fX
.sp |\\n(fAu
.ie \\n(s1=1 \{\
.tl '\\*(f7'\\*(f8'\\*(f9'
.nr s1 0
.\}
.el \{\
.ie \\n(sN%2   .tl '\\*(f1'\\*(f2'\\*(f3'
.el .tl '\\*(f4'\\*(f5'\\*(f6'
.\}
.nr fP \\n(fCu
.ch fT \\n(fPu
.bp
.ev
..
.de nT
.nr nO 1
.di nK
..
.de sE
.if \\n(nO+\\n(bO \&
..
.de zA
.br
.di zX
..
.de zE
.br
.di
.if \\n(nlu>\\n(kCu \{\
.ne \\n(dnu
.\}
.ev 1
.zX
.ev
..
.de nA
.ie \\n(nN \{\
.ne \\n(nVu+1v
.\}
.el \{\
.ne \\n(nVu*2u+1v
.\}
.nr nZ +1
..
.de nB
.ev 2
.da nF
.if !\\n(nN \{\
\l'5c'
.br
.\}
.in +2n
.ti -2n
..
.de nE
.br
.in -2n
.di
.ev
.nr fP -\\n(dnu
.if !\\n(nN .nr fP -\\n(nVu
.if !(\\n(fPu-\\n(nlu) .nr fP \\n(nlu+1v
.ch fT \\n(fPu
.nr nN 1
..
.de bA
.ev 1
.fi
.di bZ
..
.de bB
.br
.di
.nf
.nr bH \\n(dnu
.nr tt \\$1v
.ie (\\n(nlu+\\n(bHu+(2u*\\n(ttu))<\\n(fPu \{\
.sp \\n(ttu
.rs
.bZ
.sp \\n(ttu
.\}
.el \{\
.da bK
.if \\n(fCu-\\n(bHu-\\n(kCu \{\
\!.ne \\n(bHu
.\}
\!.rs
.bZ
.sp \\n(ttu
\!.ne 3v
.di
.nr bO 1
.\}
.ev
..
.de bE
.br
.di
.nf
.nr bH \\n(dnu
.nr tt \\$1v
.ie (\\n(nlu+\\n(bHu+\\n(ttu)<\\n(fPu \{\
.da bF
.sp \\n(ttu
\!.rs
.bZ
.di
.nr fP -\\n(bHu
.ch fT \\n(fPu
.nr bN 1
.\}
.el \{\
.da bK
.if \\n(fCu-\\n(bHu-\\n(kCu \{\
\!.ne \\n(bHu
.\}
\!.rs
.bZ
.sp \\n(ttu
\!.ne 3v
.di
.nr bO 1
.\}
.ev
..
.de hS
.nr h1 \\$1
.nr h2 \\$2
.nr h3 \\$3
.nr h4 \\$4
.nr h5 \\$5
.if \\n(.$ .nr h\\n(.$ -1
..
.de hT
.af h1 \\$1
.af h2 \\$2
.af h3 \\$3
.af h4 \\$4
.af h5 \\$5
..
.de hA
.sp \\$2
.ne \\$3+3v
.nr h\\$1 +1
.if \\$1<5 .nr h5 0
.if \\$1<4 .nr h4 0
.if \\$1<3 .nr h3 0
.if \\$1<2 .nr h2 0
..
.de hB
.nr hI \\$1
.if \\n(hI .nr hI +2n
.in +\\n(hIu
.if \\n(hI .sp -1v
..
.de hC
.in -\\n(hIu
.sp \\$1
.ns
.ti +\\$2
.ev 1
.fi
.da hX
.sp \\$3
.ll -9n
.in +\\$4
\!.ne 2v+\\$5
..
.de hD
.in +\\$1
.sp -1v
..
.de hE
.br
.nr hJ \\n(.nu+\\n(.iu+2n
.nr hK \\n(.lu+3n
.in -\\$1
.in -\\$2
.ll +9n
.sp -1v
.ta \\n(hJu \\n(hKu \\n(.luR
.tc
.lc .
\t\a\t\\n(sN
.sp \\$3
.di
.nf
.ev
..
.de hH
.br
.ev 1
.hX
.ev
..
.de lA
.ev 1
.fi
.da lX
..
.de lE
.br
.di
.nf
.ev
..
.de lL
.br
.ev 1
.lX
.ev
..
.de eD
.ne 2v
.br
.nr e\\$1 \\n(.nu
.in +\\n(e\\$1u
.sp -1v
..
.de eE
.in -\\n(e\\$1u
..
.de PS
.nr pE (\\n(.lu-\\$2u)/2u
.in +\\n(pEu
.ne \\$1u
..
.de PE
.in -\\n(pEu
..
.ds dO "$
.
.ds : \h'-(\\w'\\(um'u+\\w'a'u)/2u'\\(um\h'(\\w'a'u-\\w'\\(um'u)/2u'
.ds ; \h'-(\\w'\\(um'u+\\w'U'u)/2u'\v'-0.2m'\
\\(um\v'+0.2m'\h'(\\w'U'u-\\w'\\(um'u)/2u'
.
.
.ds #h ((1u-(\\\\n(.fu%2u))*0.13m)
.ds ' \k_\h'-(\\n(.wu*8/10-\*(#h)'\v'-0.1m'\(aa\v'+0.1m'\h'|\\n_u'
.ds ` \k_\h'-(\\n(.wu*7/10-\*(#h)'\v'-0.1m'\(ga\v'+0.1m'\h'|\\n_u'
.ds ^ \k_\h'-(\\n(.wu-\*(#h-0.05m)'\v'-0.5m'\s-2^\s0\v'+0.5m'\h'|\\n_u'
.ds ~ \k_\h'-(\\n(.wu-\*(#h-0.05m)'\v'-0.5m'\s-2~\s0\v'+0.5m'\h'|\\n_u'
.ds , \k_\h'-(\\n(.wu*8/10)',\h'|\\n_u'
.ds v \k_\h'-(\\n(.wu*9/10-\*(#h)'\v'-0.6m'\
\s-4v\s0\v'+0.6m'\h'|\\n_u'
.\" .ds o \k_\h'-(\\n(.wu+\w'\(de'u-\*(#h)/2u'\v'-0.4n'\
.\" \z\(de\v'0.4n'\h'|\\n_u'
.rm #h
.iE 16.5cn 1 12 14pp 30
.iP 0.0cn 29.7cv 3vv 4vv 8vv 3vv 4vv 4vv
.ce 9999
\&\fB
.nr gP \n(.s
.ps \n(.s*5u/2u
\&Entwurf und Implementierung
.ps \n(gP
\&\fP
.ce 0
.br
.ce 9999
\&\fB
.nr gP \n(.s
.ps \n(.s*5u/2u
\&eines \*Ubersetzers
.ps \n(gP
\&\fP
.ce 0
.br
.ce 9999
\&\fB
.nr gP \n(.s
.ps \n(.s*5u/2u
\&von Modula-2 nach C
.ps \n(gP
\&\fP
.ce 0
.sp 9
.ce 9999
\&\fB\s+2Diplomarbeit\s-2\fP
.ce 0
.sp 0.4v
.ce 9999
\&\s+2von\s-2
.ce 0
.sp 0.4v
.ce 9999
\&\fB\s+2Matthias Martin\s-2\fP
.ce 0
.sp 9
.ce 9999
\&\fB\s+2Universit\*at Karlsruhe\s-2\fP
.ce 0
.sp 0.4v
.ce 9999
\&\fB\s+2Fakult\*at f\*ur Informatik\s-2\fP
.ce 0
.sp 0.4v
.ce 9999
\&\s+2Februar 1990\s-2
.ce 0
.sp 9
.ce 9999
\&\s+2Betreuer:\s-2
.ce 0
.sp 0.4v
.ce 9999
\&\s+2Prof. Dr. S. J\*ahnichen\s-2
.ce 0
.sp 0.4v
.ce 9999
\&\s+2Dr. J. Grosch\s-2
.ce 0
\s+2
.ce 9999
\&\fB\*Ubersicht\fP
.ce 0
.sp 0.4v
.sp 0.4v
.ne 2v
.ti +2n
Diese Diplomarbeit beschreibt den Entwurf und die Implementierung des
\*Ubersetzers \%Mtc, der in \%Modula-2 geschriebene Programme in
lesbaren C-Code umsetzt. Die Definition einer vollst\*andigen Abbildung von
\%Modula-2 nach C, die auch anhand von zahlreichen Beispielen illustriert
wird, bildet den Hauptteil dieser Arbeit. Die Implementierung des \*Ubersetzers
erfolgte unter weitgehendem Einsatz von \*Ubersetzerbauwerkzeugen. Die
Beschreibung der Implementierung konzentriert sich daher besonders auf die
Darstellung des Einsatzes dieser Werkzeuge. Ein abschlie\*sendes
Kapitel \*uber erste praktische Eins\*atze von \%Mtc demonstriert die
Leistungsf\*ahigkeit und Laufzeiteffizienz des \*Ubersetzers sowie die Qualit\*at
des erzeugten C-Codes.
\s-2
                  
            
               
	     
.nr sN 1-1
.br
.ne 29.7c
.eo
.ds f1 
.ds f2 \n(sN
.ds f3 
.ec
.eo
.ds f4 
.ds f5 \n(sN
.ds f6 
.ec
.eo
.ds f7 
.ds f8 \n(sN
.ds f9 
.ec
.de fX
.fi
.nf
..
\&           
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Einleitung\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Einleitung
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
Diese Arbeit beschreibt den Entwurf und die Implementierung des \*Ubersetzers
\%\fIMtc\fP, der in \%Modula-2 geschriebene Programme in lesbaren C-Code
umsetzt.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Motivation und Zielsetzung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Motivation und Zielsetzung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 
[Wirth\|85]
ist eine Weiterentwicklung der Programmiersprache Pascal, die
im wesentlichen um ein Modulkonzept erweitert wurde. An der
GMD Forschungsstelle Karlsruhe wurde der Modula-\*Ubersetzer \%MOCKA
[Engelmann\|87]
entwickelt, der auch vollst\*andig in \%Modula-2 implementiert ist.
\%Modula-2 und \%MOCKA werden zur Zeit an der GMD Forschungsstelle
Karlsruhe
als bevorzugte Werkzeuge zur Programmentwicklung eingesetzt. Insbesondere
sind alle in den letzten drei Jahren am Institut
entwickelten \*Ubersetzerbauwerkzeuge
in \%Modula-2 implementiert.
.sp 0.4v
.ne 2v
.ti +2n
Die Sprache C [Kernighan\|78] wurde urspr\*unglich entworfen und
implementiert f\*ur die Entwicklung des UNIX-Betriebssystems
[UNIX\|79], welches abgesehen von wenigen Teilen,
bei denen extrem hohe Effizienzanforderungen oder spezielle
Maschineneigenschaften
den Einsatz von Assembler notwendig machen, vollst\*andig in C implementiert
ist. Da \%UNIX nicht nur ein Betriebssystem ist, sondern, weniger eng
betrachtet, unter dem Begriff \%UNIX eine Programmierumgebung
mit einer Vielzahl von n\*utzlichen Werkzeugen f\*ur die Programmentwicklung
verstanden
wird, hat \%UNIX in den letzten Jahren, besonders im wissenschaftlichen
Bereich, eine sehr weite Verbreitung gefunden. Auch an der GMD Forschungsstelle
Karlsruhe wird \%UNIX eingesetzt.
.sp 0.4v
.ne 2v
.ti +2n
Aus den einleitenden Vorbemerkungen l\*a\*st sich nun direkt die
haupts\*achliche Zielsetzung und das geplante Einsatzgebiet von \%\fIMtc\fP
ableiten:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Modula-\*Ubersetzer \%MOCKA und die am Institut entwickelten
\*Ubersetzerbauwerkzeuge k\*onnen mit \%\fIMtc\fP schnell und relativ einfach
auf neue Maschinen \*ubertragen werden, auf denen das UNIX-System und ein
\*Ubersetzer f\*ur die Sprache C vorhanden sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die \*Ubersetzerbauwerkzeuge werden auch f\*ur alle Interessenten
zug\*anglich, die einen \*Ubersetzer f\*ur die im Vergleich mit \%Modula-2
weit verbreitete Sprache C besitzen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Weiterentwicklung der \*Ubersetzerbauwerkzeuge kann in der besser
strukturierten, moderneren und relativ sicheren Sprache \%Modula-2
erfolgen, die Werkzeuge sind aber auch jederzeit, ohne den riesigen Aufwand
einer \*Ubersetzung von Hand, in C und unter \%UNIX verf\*ugbar.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da \%\fIMtc\fP f\*ur die \*Ubertragung von fertigen Modula-Programmen
nach C gedacht ist und nicht f\*ur die Programmentwicklung eingesetzt werden
soll, kann bei der Implementierung davon ausgegangen werden, da\*s nur korrekte
Programme als Eingabe vorkommen. Insbesondere soll die semantische Korrektheit
der Eingabeprogramme nicht \*uberpr\*uft werden.
Weil die \*ubersetzten Programme unter Umst\*anden noch von Hand weiterbearbeitet
werden sollen, ist
eine wichtige Forderung an die erzeugten Programme, da\*s sie gut lesbar sind.
.sp 0.4v
.ne 2v
.ti +2n
Ein weiteres Ziel dieser Arbeit ist der praktische Einsatz der bisher
entwickelten \*Ubersetzerbauwerkzeuge bei der Implementierung von \%\fIMtc\fP, um
dabei:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die praktische Einsetzbarkeit der Werkzeuge f\*ur die Entwicklung eines
gr\*o\*seren \*Ubersetzers zu zeigen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Leistungsf\*ahigkeit der Werkzeuge und des (teilweise) generierten
\*Ubersetzers zu demonstrieren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Erfahrungen zu sammeln, die zu einer Verbesserung der Werkzeuge f\*uhren.
.in -4n
.sp 0.1vv
.sp 0.3vv
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Randbedingungen\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Randbedingungen
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Implementierung des \*Ubersetzers erfolgt auf UNIX-Workstations der
Firmen \%PCS und \%SUN.
Implementierungssprache ist \%Modula-2. Die folgenden an der
GMD Forschungsstelle Karlsruhe entwickelten \*Ubersetzerbauwerkzeuge
standen f\*ur die Entwicklung von \%\fIMtc\fP zur Verf\*ugung:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Generator f\*ur Symbolentschl\*ussler \%\fIRex\fP [Grosch\|87b].
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Zerteilergeneratoren \%\fILalr\fP und \%\fIEll\fP [Vielsack\|88].
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%\fIAst\fP [Grosch\|89a], ein Werkzeug zur Spezifikation
und Implementierung von abstrakten Syntaxb\*aumen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%\fIAg\fP [Grosch\|89b], ein Generator f\*ur
Attributauswerter.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Das Werkzeug \%\fIEstra\fP [Vielsack\|89] zur Spezifikation
und Implementierung der Transformation attributierter Strukturb\*aume.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Neben diesen Werkzeugen
wurden Modula-Moduln aus der umfangreichen Bibliothek \%\fIReuse\fP
[Grosch\|87a] mit wiederverwendbarer Software verwendet.
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Vergleichbare Arbeiten\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Vergleichbare Arbeiten
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
In diesem Kapitel sollen kurz zwei mit \%\fIMtc\fP vergleichbare Arbeiten
vorgestellt werden, die sich mit der \*Ubersetzung von Programmen von einer
h\*oheren Programmiersprache in eine andere h\*ohere Programmiersprache
besch\*aftigen.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&PTC\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&PTC
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der \*Ubersetzer \%PTC [PTC\|87] war f\*ur die vorliegende Arbeit von besonderem
Interesse, da die Zielsprache ebenfalls C und die Quellsprache \%Pascal
der Vorg\*anger von \%Modula-2 ist.
Er wurde von P. Bergsten bei der Firma Holistic Technology AB,
Gothenburg, Schweden entwickelt.
.sp 0.4v
.ne 2v
.ti +2n
\%PTC verarbeitet ein korrektes Pascal-Programm und erzeugt ein
\*aquivalentes C-Programm.
Der \*Ubersetzer, der
(fast) vollst\*andiges \%Pascal implementiert,
wurde entworfen, um fertig
entwickelte
Pascal-Programme auf Systeme zu \*ubertragen, die keinen Pascal-\*Ubersetzer
besitzen. Er ist nicht f\*ur die Programmentwicklung gedacht. Daher wird die
Korrektheit der Eingabeprogramme auch nicht \*uberpr\*uft und beim
ersten entdeckten
Fehler bricht der \*Ubersetzer mit einer entsprechenden Meldung ab. PTC besitzt
daher keinerlei Fehlerbehandlung und fehlerhafte Programme k\*onnen im
schlimmsten Fall sogar zum Absturz des \*Ubersetzers f\*uhren.
.sp 0.4v
.ne 2v
.ti +2n
Auf die von \%PTC implementierte Abbildung von \%Pascal nach C soll
hier nicht im Detail eingegangen werden. Da \%Modula-2 ein Nachfolger von
\%Pascal ist und daher ein nicht unerheblicher Teil der beiden Sprachen,
abgesehen von kleinen syntaktischen Unterschieden, nahezu identisch ist und
dar\*uberhinaus an vielen Stellen die Abbildung nach C auf der Hand liegt,
stimmt die von \%PTC implementierte Abbildung f\*ur die gemeinsamen
Konstrukte von \%Modula-2 und \%Pascal
im Prinzip mit der in Kapitel 4 beschriebenen Abbildung von
\%Modula-2 nach C \*uberein. Dort wird an den entsprechenden
Stellen
darauf verwiesen, wo besonders elegante L\*osungen von \%PTC \*ubernommen
wurden.
.sp 0.4v
.ne 2v
.ti +2n
Hier soll nur kurz dargestellt werden, welche Probleme bei der Abbildung
f\*ur \%Modula-2 im Vergleich zu \%Pascal entfallen und welche neu
hinzukommen.
.sp 0.4v
.ne 2v
.ti +2n
Da in \%Modula-2 die Ein-/Ausgabe, die Dateiverwaltung sowie die
Speicherverwaltung nicht Teil der Sprachdefinition sind, entf\*allt die f\*ur
\%Pascal notwendige und teilweise sehr aufwendige Abbildung dieser
Konstrukte, die von \%PTC mit Hilfe der C-Standardbibliothek implementiert
werden. Spr\*unge, insbesondere Spr\*unge, die eine Prozedur verlassen und die
kein direktes Gegenst\*uck in C haben, sind in \%Modula-2 ebenfalls nicht
m\*oglich. Ein weiteres, von
\%PTC allerdings nicht gel\*ostes Problem, welches in \%Modula-2
entf\*allt, ist die in \%Pascal gegebene M\*oglichkeit lokal deklarierte
Prozeduren als Prozedurparameter zu \*ubergeben.
.sp 0.4v
.ne 2v
.ti +2n
Verglichen mit \%Pascal kommen in \%Modula-2 insbesondere
das Modulkonzept und die getrennte \*Ubersetzung neu
hinzu.
Au\*serdem ist die Reihenfolge der Deklarationen und Anweisungen in
\%Modula-2 nicht so stark eingeschr\*ankt wie in \%Pascal und es sind
allgemeine Ausdr\*ucke in Deklarationen zul\*assig. Das Konzept der
\*Ubergabe von Funktionen bzw. Prozeduren als Parameter wurde in \%Modula-2
zu dem allgemeinen Konzept der Prozedurtypen und -variablen erweitert.
Zus\*atzlich neu ist die
M\*oglichkeit, Felder beliebiger Gr\*o\*se an Prozeduren zu \*ubergeben sowie eine
Reihe von M\*oglichkeiten zur ,,maschinennahen'' Programmierung.
.sp 0.4v
.ne 2v
.ti +2n
\%PTC ist in \%Pascal implementiert. Das Programm ist im wesentlichen
aus den drei Prozeduren \%\fIparse\fP, \%\fItransform\fP und \%\fIemit\fP aufgebaut.
.sp 0.4v
.ne 2v
.ti +2n
Die Prozedur \%\fIparse\fP liest und zerteilt das Quellprogramm und baut einen
abstrakten Strukturbaum auf. Die Zerteilung arbeitet nach dem Verfahren des
rekursiven Abstiegs. Parallel zur Zerteilung wird eine Definitionstabelle
aufgebaut und die Bezeichneridentifikation durchgef\*uhrt.
.sp 0.4v
.ne 2v
.ti +2n
Die Prozedur \%\fItransform\fP f\*uhrt eine Reihe von Baum-zu-Baum
Transformationen durch, die notwendig sind, um das Pascal-Programm nach C zu
\*ubersetzen. Die wichtigste dieser Transformationen ist die Delokalisierung von
in \%Pascal
lokal deklarierten Prozeduren, da in C keine geschachtelten
Funktionsdeklarationen zul\*assig sind. Zus\*atzlich zur Transformation des
Strukturbaums werden bei Bedarf auch Bezeichner zur Vermeidung von
Namenskonflikten umbenannt.
.sp 0.4v
.ne 2v
.ti +2n
Die Prozedur \%\fIemit\fP schlie\*slich traversiert den transformierten Baum und
gibt die entsprechenden C-Konstrukte aus.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&PascAda\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&PascAda
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Das an der University of California entworfenen \fIPascAda\fP\^-System
[PascAda\|80] besteht aus zwei
\*Ubersetzern; der eine transformiert Pascal-Programme in Ada-Programme, der
zweite f\*uhrt die entgegengesetzte Transformation durch.
Beide \*Ubersetzer sind in \%Pascal implementiert.
Die wichtigsten Ziele dieses Projekts waren\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Wobei man ber\*ucksichtigen
mu\*s, da\*s das Projekt zu einem Zeitpunkt durchgef\*uhrt wurde, als gerade eine
erste Definition der Sprache \%Ada aber noch kein
Ada-\*Ubersetzer vorlag.
.nE
\&:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Da die beiden \*Ubersetzer in \%Pascal implementiert sind, f\*ur das
Implementierungen existieren, stellt der \*Ubersetzer von \%Ada nach
\%Pascal einen \*Ubersetzer f\*ur (eine Teilmenge von) \%Ada dar.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&M\*oglichkeit der vorl\*aufigen Entwicklung von Software in \%Ada.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Umsetzen existierender, in Pascal implementierter Software nach
\%Ada.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Unterst\*utzung der \*Ubertragung von in \%Ada und/oder
\%Pascal implementierter Software auf neue Systeme.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&M\*oglichkeit zu Experimenten mit \%Ada.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bootstrap eines Ada-\*Ubersetzers.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die \fIPascAda\fP-Gruppe ist bei diesem Projekt folgenderma\*sen vorgegangen.
Zun\*achst wurden zwei Teilmengen \%\fIAdaP\fP und \%\fIPascalA\fP von
\%Ada und \%Pascal definiert, f\*ur die eine direkte \%1:1
\*Ubersetzung
in die jeweils andere Teilmenge existiert. Im n\*achsten Schritt wurden
dann zwei erweiterte Teilsprachen \%\fIAdaPE\fP und \%\fIPascalAE\fP
definiert, f\*ur welche Transformationsregeln gefunden werden konnten, wie
Konstrukte dieser erweiterten Teilsprachen durch Transformation der
Quellprogramme auf Konstrukte von \%\fIAdaP\fP bzw. \%\fIPascalA\fP
abgebildet werden k\*onnen. Da die Semantik von \%Ada eine weitgehende
Obermenge von \%Pascal ist, ist \%\fIPascalAE\fP nahezu vollst\*andiges
\%Pascal. Eine Ausnahme sind z.B. Prozeduren und Funktionen als Parameter
oder nicht lokale Spr\*unge. Da f\*ur viele Sprachkonzepte von \%Ada, wie
z.B. Parallelverarbeitung und Ausnahmebehandlung, keine entsprechenden
Konzepte in \%Pascal existieren und eine Simulation, wenn \*uberhaupt,
nur mit gro\*sem Aufwand m\*oglich
w\*are, sind die Einschr\*ankungen bei \%\fIAdaPE\fP nat\*urlich gr\*o\*ser.
.sp 0.4v
.ne 2v
.ti +2n
Bei der Implementierung der beiden \*Ubersetzer wurde als gemeinsame
Zwischensprache die Baumstruktur aus einer formalen
Definition von \%Ada [Donzeau\|79] benutzt,
die um einige spezielle Konstrukte f\*ur
\%\fIPascalAE\fP erweitert wurde. Der \*Ubersetzer von Pascal nach Ada besteht
logisch aus 4 Komponenten:
.sp 0.3vv
.nr a1 0
.af a1 1
.br
.ne 2v
\&\fIPascalToTree:\fP
.in +18n
.if \w'\fIPascalToTree:\fP\ 'u<18n .sp -1v
\&Setzt das Quellprogramm in einen Baum der
Zwischensprache um.
.in -18n
.br
.ne 2v
\&\fIPascalAEtoA:\fP
.in +18n
.if \w'\fIPascalAEtoA:\fP\ 'u<18n .sp -1v
\&Setzt \fIPascalAE\fP-Konstrukte durch Baum-zu-Baum
Transformationen in entsprechende \fIPascalA\fP-Konstrukte um.
.in -18n
.br
.ne 2v
\&\fIPascalACheck:\fP
.in +18n
.if \w'\fIPascalACheck:\fP\ 'u<18n .sp -1v
\&Pr\*uft, ob der Baum einem Programm der Teilsprache
\%\fIPascalA\fP entspricht.
.in -18n
.br
.ne 2v
\&\fITreeToAda:\fP
.in +18n
.if \w'\fITreeToAda:\fP\ 'u<18n .sp -1v
\&Setzt den Baum in ein entsprechendes Ada-Programm um.
.in -18n
.sp 0.3vv
Der \*Ubersetzer von \%Ada nach \%Pascal besteht aus 4 analogen
Komponenten.
.sp 0.4v
.ne 2v
.ti +2n
Beide \*Ubersetzer f\*uhren keine komplette semantische Analyse durch, sondern
pr\*ufen nur ob ein Programm in der jeweiligen Teilsprache \%\fIPascalAE\fP
bzw. \%\fIAdaPE\fP enthalten ist.
.br
.ne 3
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Die Sprachen\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Die Sprachen
.hE 0 4n 0.1v
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Die Quellsprache Modula-2\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Die Quellsprache Modula-2
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Programmiersprache Modula-2 [Wirth\|85] wurde Ende der siebziger
Jahre an der \%ETH
Z\*urich unter der Leitung von Professor N. Wirth entwickelt. \%Modula-2 ist
ein direkter Nachfolger der Programmiersprache \%Pascal. Das wichtigste
neue Sprachkonzept im Vergleich zu \%Pascal ist ein Modulkonzept.
Die folgende Aufz\*ahlung gibt einen kurzen \*Uberblick \*uber \%Modula-2:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein Modula-Programm besteht aus einer Reihe von \*Ubersetzungseinheiten,
die getrennt \*ubersetzt werden k\*onnen. Eine solche \*Ubersetzungseinheit ist
entweder ein Programmodul, ein Definitionsmodul oder ein Implementierungsmodul.
Ein Programmodul stellt ein Hauptprogramm dar. Definitions- und
Implementierungsmoduln treten immer paarweise auf. Es handelt sich dabei jeweils
um einen logisch zusammengeh\*orenden Modul. Der Definitionsmodul stellt die
Schnittstelle des Moduls dar und spezifiziert die vom Modul exportierten, d.h.
die nach au\*sen sichtbaren Objekte (Daten und Operationen). Der
Implementierungsmodul enth\*alt die Implementierung der nach au\*sen sichtbaren
Operationen und eventuell weitere lokale Objekte. Der Realisierung des
Geheimnisprinzips dienen die sogenannten opaquen Typen, deren Struktur den
sie benutzenden Moduln verborgen bleibt.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle im Modula-Programm benutzten Objekte m\*ussen durch eine Deklaration
bekannt gemacht werden, es sei denn, es handelt sich um ein vordefiniertes
Objekt.
Die Objekte von \%Modula-2 sind: Konstanten, Typen, Variablen, Prozeduren
und Moduln.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%Modula-2 ist eine blockstrukturierte Sprache. Zus\*atzlich zur
Blockstruktur erlaubt das Modulkonzept eine explizite Kontrolle des
G\*ultigkeitsbereichs bzw. der Sichtbarkeit von Objekten. Alle Objekte, die
innerhalb von Deklarationen verwendet werden, m\*ussen textuell vor ihrer
Benutzung deklariert werden; ein Objekt kann aber innerhalb einer Anweisung
benutzt werden, die der Deklaration des Objekts textuell vorangeht.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%Modula-2 ist eine streng typisierte Sprache. Die Grundtypen von
\%Modula-2 sind: Zeichen, Wahrheitswerte sowie ganze und reelle
Zahlen verschiedener Gr\*o\*se. Neben den Grundtypen besitzt \%Modula-2 einen
umfangreichen Satz von Typkonstruktoren. Die m\*oglichen Typen sind:
Grundtypen, Aufz\*ahlungstypen, Unterbereichstypen, Felder, Verbunde,
Verbunde mit Varianten, Mengen, Zeiger und Prozedurtypen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Prozedurdeklarationen bestehen aus einem Prozedurkopf, der angibt,
welche formalen Parameter und welchen Resultattyp\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Der Resultattyp wird nur
bei Funktionsprozeduren angegeben.
.nE
\& die Prozedur besitzt
und einem Rumpf, der lokale Deklarationen und Anweisungen enth\*alt.
\%Modula-2 kennt drei Arten von formalen
Parametern: neben den von \%Pascal her bekannten Wert- und
Referenzparametern gibt es noch sogenannte offene Felder. Offene Felder sind
eindimensionale Felder, deren Feldgrenzen bei der Parameterdeklaration nicht
festgelegt werden. Dadurch k\*onnen Felder unterschiedlicher Gr\*o\*se
von einer Prozedur bearbeitet werden. In \%Modula-2
k\*onnen beliebige Objekte lokal zu einer Prozedur deklariert werden. Das
bedeutet insbesondere, da\*s auch Prozedurdeklarationen geschachtelt werden
k\*onnen. Prozeduren k\*onnen auch rekursiv aufgerufen werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein (lokaler) Modul besteht im wesentlichen aus einer Reihe von
Deklarationen und einer Anweisungsfolge. Die Anweisungsfolge dient der
Initialisierung von lokalen Objekten. Grunds\*atzlich sind innerhalb des Moduls
deklarierte Objekte au\*serhalb unsichtbar und umgekehrt sind au\*serhalb
deklarierte Objekte innerhalb des Moduls unsichtbar. Durch Import- bzw.
Exportanweisungen kann der Programmierer die Sichtbarkeit von Objekten explizit
kontrollieren und Objekte innerhalb/au\*serhalb des Moduls sichtbar werden
lassen. Moduln erm\*oglichen es also, zusammengeh\*orige Daten und Operationen
zusammenzufassen und gegen\*uber anderen Programmteilen abzugrenzen. Die Import-
bzw Exportanweisungen bilden dabei die Schnittstellen des Moduls nach au\*sen.
Ein Definitionsmodul ist im Prinzip nichts anderes, als die (erweiterte)
Exportliste des zugeh\*origen Implementierungsmoduls.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Neben den \*ublichen arithmetischen, logischen und relationalen
Operatoren sowie Operatoren zum Zugriff auf strukturierte Variablen besitzt
\%Modula-2 auch Operatoren zur Manipulation von Mengen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Anweisungen von \%Modula-2 sind: Zuweisung,
bedingte Anweisung, Fallunterscheidung, verschiedene Schleifenkonstrukte,
Schleifenausgangsanweisung,
R\*uckkehranweisung und Prozeduraufruf.
In \%Modula-2 k\*onnen auch beliebig strukturiete Objekte als Ganzes
zugewiesen werden. Eine Sprunganweisung
existiert in \%Modula-2 nicht. Eine Spezialit\*at von \%Modula-2 (und
\%Pascal) ist die WITH-Anweisung, die es erm\*oglicht, auf Komponenten
von Verbunden
ohne Qualifikation durch den Namen des Verbundes zuzugreifen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%Modula-2 bietet eine Reihe von M\*oglichkeiten, die f\*ur eine
,,maschinennahe'' Programmierung notwendig sind. Insbesondere k\*onnen die Regeln
der strengen Typisierung umgangen und die Adressen von beliebigen Variablen
bestimmt werden. Die meisten dieser M\*oglichkeiten
sind Datentypen und Prozeduren, die im vordefinierten Pseudomodul \%SYSTEM
enthalten sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%Modula-2 erlaubt die Spezifikation von quasiparallelen Prozessen
mit Hilfe von Koroutinen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Definition der Ein- und Ausgabe sowie der Datei- und
Speicherverwaltung sind nicht Teil der Sprachdefinition von \%Modula-2.
.in -4n
.sp 0.1vv
.sp 0.3vv
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Die Zielsprache C\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Die Zielsprache C
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Sprache C [Kernighan\|78] wurde zu Beginn der siebziger Jahre
von D. Ritchie f\*ur die
Entwicklung des UNIX-Betriebssystems entworfen und implementiert. C ist eine
relativ maschinennahe Sprache, die sich besonders f\*ur die Entwicklung von
Betriebssystemen und anderen hardwarenahen Systemteilen eignet. Es wurden aber
auch zahlreiche \*Ubersetzer und umfangreiche Anwendungssoftware wie z.B.
Datenbankanwendungen in C implementiert. Die folgende Aufz\*ahlung soll einen
kurzen \*Uberblick \*uber die Sprache C geben, sofern sie f\*ur diese Arbeit
relevant ist:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein C-Programm besteht aus einer Reihe von Quelldateien (Moduln), die
eine Folge von Typ-, Daten- und Funktionsdeklarationen enthalten und vom
C-\*Ubersetzer getrennt \*ubersetzt werden k\*onnen. Im Gegensatz zu
\%Modula-2 werden vom C-\*Ubersetzer aber keinerlei Pr\*ufungen \*uber die
Grenzen der einzelnen Quelldateien hinweg vorgenommen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der C-Pr\*aprozessor, welcher ein Teil der Sprachdefinition von C ist,
ist ein Makroprozessor, der Textersatz vornehmen, Dateien in eine Quelldatei
einf\*ugen und Teile eines Programms von der \*Ubersetzung ausschlie\*sen kann.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&In C m\*ussen alle Objekte vor ihrer Anwendung deklariert werden. Es
besteht jedoch die M\*oglichkeit von Vorw\*artsdeklarationen und von sogenannten
\fIextern\fP\^-Deklarationen, mit deren Hilfe in anderen Quelldateien deklarierte
Objekte bekannt gemacht werden k\*onnen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C kennt eine einfache Art von Blockstruktur: Variablen k\*onnen innerhalb
von Funktionen in Bl\*ocken deklariert werden und verdecken globale Objekte bzw.
Variablen in umfassenden Bl\*ocken mit dem gleichen Namen. Funktionen k\*onnen
jedoch nicht lokal in einer anderen Funktion deklariert werden, d\*urfen also
nicht statisch geschachtelt sein.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Lebensdauer bzw. Sichtbarkeit von Objekten werden in C u.a. durch ihre
Speicherklasse festgelegt. Lokale Variablen von Funktionen k\*onnen dabei
folgende Speicherklassen haben:
.sp 0.1vv
.if \n(.nu<4n .sp -0.1vv
.nr a2 0
.af a2 a
.br
.ne 2v
\&\fIstatic:\fP
.in +12n
.if \w'\fIstatic:\fP\ 'u<12n .sp -1v
\&Lebensdauer entspricht der Programmdauer. Dies
entspricht den \fIown\fP\^-Va\%ria\%blen von \%Algol.
.in -12n
.br
.ne 2v
\&\fIauto:\fP
.in +12n
.if \w'\fIauto:\fP\ 'u<12n .sp -1v
\&Variablen liegen auf dem Keller. Lebensdauer von
Block\%ein- bis Block\%aus\%tritt.
.in -12n
.br
.ne 2v
\&\fIregister:\fP
.in +12n
.if \w'\fIregister:\fP\ 'u<12n .sp -1v
\&Lebensdauer wie \fIauto\fP\^-Objekte, diese sollen aber nach
M\*oglichkeit vom \*Ubersetzer in einem Register abgelegt werden.
.in -12n
.sp 0.1vv
Die Lebensdauer von globalen Variablen ist die gesamte Programmdauer. Die
Angabe der Speicherklasse \fIstatic\fP verhindert bei globalen Objekten, da\*s sie
au\*serhalb der sie enthaltenden Quelldatei sichtbar sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C ist keine streng typisierte Sprache. F\*ur arithmetische Typen ist eine
gro\*se Zahl von impliziten Typumwandlungen definiert. Neben impliziten
Typumwandlungen sind auch explizite Konvertierungen m\*oglich. Zuweisungen
zwischen Zeigern verschiedenen Typs sind ebenfalls m\*oglich. Die Grundtypen von
C sind: Zeichen, ganze und reelle Zahlen mit verschiedenem
Speicherbedarf. Die zusammengesetzten Datentypen von C sind: Zeiger, Vektoren
(Felder), Strukturen (Verbunde)\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ In der deutschsprachigen Fachliteratur
haben sich die Begriffe Vektor
und Struktur f\*ur die entsprechenden C-Datenstrukturen eingeb\*urgert.
.nE
\&,
Varianten und Aufz\*ahlungen. Eine Variante ist eine
Struktur, bei der sich die Komponenten \*uberlagern. Es handelt sich also um
eine eingeschr\*ankte Art von variantem Verbund.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine Funktionsdeklaration besteht aus dem Ergebnistyp
der Funktion, der Deklaration der Parameter und aus
lokalen Deklarationen und
Anweisungen in Form eines Blocks. Wie bereits erw\*ahnt k\*onnen
Funktionsdeklarationen nicht geschachtelt werden. Als Hauptprogramm fungiert
die Funktion \fImain\fP. Die Parameter\*ubergabe erfolgt durch Wert\*ubergabe
(\fIcall by value\fP). Bei Vektoren wird ein Zeiger auf den Anfang des
Vektors \*ubergeben (\fIcall by reference\fP). Funktionen k\*onnen auch
rekursiv aufgerufen werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C besitzt eine gro\*se Zahl von Operatoren. Die wichtigsten dieser
Operatoren sind: Arithmetische, logische und relationale Operatoren, Operatoren
zur Selektion von Komponenten strukturierter Variablen und
Operatoren zur Bitmanipulation.
Dar\*uberhinaus gibt es noch eine Reihe von speziellen Operatoren wie
bedingte Ausdr\*ucke oder Inkrement- und Dekrementoperatoren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Anweisungen von C sind: Zuweisung, Sprunganweisung, bedingte
Anweisung, Fallunterscheidung, verschiedene Schleifenkonstrukte,
Schleifenausgangsanweisung, R\*uckkehranweisung und Prozeduraufruf.
Die Zuweisung ist allerdings eingeschr\*ankt: Vektoren k\*onnen nicht als Ganzes
zugewiesen werden und Strukturen nur bei neueren Implementierungen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C besitzt einen Adre\*soperator, mit dem die Adressen s\*amtlicher
Objekte bestimmt werden k\*onnen. Insbesondere kann man auch die Adressen von
Funktionen bestimmen und diese dann sp\*ater \*uber diese Adressen aufrufen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Vergleich\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Vergleich
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Beim Vergleich von \%Modula-2 und C zeigt sich, da\*s C, trotz der auch in
\%Modula-2
vorhandenen M\*oglichkeiten zur ,,maschinennahen'' Programmierung, die
maschinenn\*ahere Sprache ist. \%Modula-2 besitzt ein deutlich h\*oheres
Abstraktionsniveau und an vielen Punkten m\*achtigere Ausdrucksmittel.
Allerdings besteht, wenn man von den Koroutinen einmal absieht, die
M\*oglichkeit in C nicht direkt vorhandene Modula-Konstrukte
durch eine Kombination von
primitiveren C-Konstrukten zu realisieren. So k\*onnen z.B. die Mengen von
\%Modula-2 in C mit Hilfe der Operatoren zur
Bitmanipulation realisiert
werden.
.sp 0.4v
.ne 2v
.ti +2n
Die folgenden Punkte erfordern bei der Abbildung besonderen Aufwand:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C kennt kein Modulkonzept, welches dem von \%Modula-2 vergleichbar
w\*are. Insbesondere existieren keine den opaquen Typen und den
lokalen Moduln entsprechenden Konzepte.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Regeln hinsichtlich G\*ultigkeit und Sichtbarkeit von Bezeichnern
weisen eine Reihe von Unterschieden auf, z.B. verlangt C im Gegensatz zu
\%Modula-2, da\*s alle Objekte immer vor ihrer Anwendung deklariert werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die zusammengesetzten Typen von C sind weniger m\*achtig als die
zusammengesetzten Typen von \%Modula-2. Besondere
Schwierigkeiten
bereitet, da\*s
sich die
Behandlung von Vektoren von der Behandlung anderer Variablen unterscheidet.
Auch die eingeschr\*ankte Form von varianten Verbunden in C erfordert eine
besondere Behandlung.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Da C im Gegensatz zu \%Modula-2 keine geschachtelten
Funktionsdeklarationen kennt, mu\*s die in \%Modula-2 vom \*Ubersetzer
vorgenommene Verwaltung der Prozedurschachteln zum Zugriff auf die lokalen
Variablen von statisch umfassenden Prozeduren (Verweis auf den statischen
Vorg\*anger) auf geeignete Art und Weise mit Hilfe von C-Code vorgenommen
werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C kennt kein den offenen Feldern entsprechendes Konzept der
Parameter\*ubergabe.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Abgesehen von den oben genannten Punkten kann ein gro\*ser Teil der
Deklarationen sowie die meisten Anweisungen und Ausdr\*ucke ohne gro\*se Probleme
direkt nach C \*ubersetzt werden. Allerdings zeigt es sich bei der im
folgenden Kapitel
beschriebenen Abbildung, da\*s manchmal auch schon kleine semantische
Unterschiede, bei sich direkt entsprechenden Sprachkonstrukten, die Abbildung
deutlich verkomplizieren k\*onnen.
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Abbildung von Modula-2 nach C\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Abbildung von Modula-2 nach C
.hE 0 4n 0.1v
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Grundlagen der Abbildung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Grundlagen der Abbildung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Bevor man eine Abbildung von Modula-2 nach C definieren kann,
mu\*s man zun\*achst kl\*aren, welche Definition der beiden Sprachen
als Basis f\*ur diese Abbildung verwendet werden soll.
Die wichtigsten Gr\*unde daf\*ur sind:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Seit ihrer Entstehung unterlagen beide Sprachen einer gewissen
Evolution: manche Sprachelemente wurden ver\*andert, andere sind neu
hinzugekommen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Verschiedene Implementierungen unterscheiden sich fast immer
in einigen Details.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die vorhandenen Sprachdefinitionen sind nicht in allen Punkten
v\*ollig eindeutig.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Zur Zeit wird zwar f\*ur beide Sprachen an einer
standardisierten Sprachversion gearbeitet, aber zum einen liegen
diese Standards bisher noch nicht endg\*ultig vor, zum anderen d\*urfte nach
dem Vorliegen der Standards noch einige Zeit vergehen, bis \*Ubersetzer
verf\*ugbar sind, die sie implementieren. Das Vorgehen in dieser
Abbildung orientiert sich daher am geplanten Einsatz des 
\*Ubersetzers: \*Ubertragung von mit dem Karlsruher Modula-\*Ubersetzer
\%MOCKA
unter dem UNIX-Betriebssystem
entwickelten Programmen nach C.
.sp 0.4v
.ne 2v
.ti +2n
\%MOCKA implementiert die Sprache \%Modula-2 im
wesentlichen so, wie sie von N. Wirth [Wirth\|85] definiert wurde.
Diese Definition bildet, neben dem
MOCKA-Benutzerhandbuch [Engelmann\|87], die
Ausgangsbasis der Abbildung, die dar\*uberhinaus auch die
meisten von \%MOCKA vorgenommenen Spracherweiterungen
ber\*ucksichtigt. Insbesondere die Abbildung der Grundtypen, die
zugrundegelegten Regeln hinsichtlich Typkompatibilit\*at und die
Behandlung von Mengen orientiert sich an der Implementierung von \%MOCKA.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur die Sprache C wurde die deutsche \*Ubersetzung der bereits etwas \*alteren
Sprachbeschreibung von B.W. Kernighan und D. Ritchie
[Kernighan\|78, Kernighan\|83] als Ausgangsbasis gew\*ahlt.
Es werden jedoch auch einige
Sprachelemente wie z.B. Zuweisung von Strukturen als Ganzes verwendet,
die zum damaligen Zeitpunkt noch nicht in allen Implementierungen
verf\*ugbar waren.
Die gestellte Mindestanforderung an die erzeugten C-Programme ist,
da\*s sie von den an der GMD Forschungsstelle Karlsruhe verf\*ugbaren
C-\*Ubersetzern der Firmen \%SUN und \%PCS
akzeptiert werden.
.sp 0.4v
.ne 2v
.ti +2n
In der folgenden Beschreibung der Abbildung
wird an den entsprechenden Stellen auf m\*oglicherweise
implementierungsabh\*angige Annahmen besonders hingewiesen.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Programmrepr\*asentation\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Programmrepr\*asentation
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die erzeugten C-Programme werden zur Erh\*ohung der Lesbarkeit durch
geeignete Einr\*uckungen und Verwendung von Zwischenr\*aumen formatiert.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Bezeichner\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Bezeichner
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die m\*oglichen Modula-Bezeichner bilden eine Teilmenge der m\*oglichen
C-Bezeichner, insbesondere werden in beiden Sprachen Gro\*s- und
Kleinbuchstaben unterschieden. Die Bezeichner k\*onnen daher in der Regel
direkt aus dem Modula-Programm in das C-Programm \*ubernommen werden.
Um Namenskonflikte im erzeugten C-Programm
zu vermeiden, ist es jedoch in den folgenden F\*allen notwendig, den Bezeichner
durch das Hinzuf\*ugen eines Pr\*afix umzubenennen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Bezeichner ist ein Schl\*usselwort der Sprache C.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Bezeichner wird bereits f\*ur ein vom \*Ubersetzer vordefiniertes
Objekt verwendet.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Aufgrund der unterschiedlichen Regeln hinsichtlich des
G\*ultigkeitsbereichs von Bezeichnern oder durch eine f\*ur die Abbildung
nach C notwendige Transformation des Modula-Programms
w\*urde ein Namenskonflikt entstehen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Der Pr\*afix hat die Form \%\fIC_nnn_\fP\^, wobei \%\fInnn\fP f\*ur eine
eindeutige Nummer steht. Die Abk\*urzungen \%\fInnn\fP und \%\fIxxx\fP
werden im folgenden f\*ur die Bezeichnung von vom \*Ubersetzer vergebenen
Nummern benutzt.
.sp 0.4v
.ne 2v
.ti +2n
Es sei an dieser Stelle darauf verwiesen, da\*s bei \*alteren
C-\*Ubersetzern zur Unterscheidung von Bezeichnern h\*aufig nur
wenige Zeichen verwendet werden. Da aber bei neueren C-\*Ubersetzern
hier meistens keine Restriktionen mehr bestehen, wird dies bei der
Abbildung nicht ber\*ucksichtigt.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Numerische Konstanten\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Numerische Konstanten
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die ganzzahligen Konstanten von \%Modula-2 werden gem\*a\*s der folgenden
Tabelle mit regul\*aren Ausdr\*ucken nach C \*ubersetzt:
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
ce| ce
lefTT| lefTT.
Modula-2|C
_
[0-9]+|[0-9]+
[0-7]+ B|0 [0-7]+
[0-7]+ C|(unsigned char) '\e[0-7]+'
[0-9] [0-9A-F]* H|0X [0-9] [0-9A-F]*
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.1\fP: Abbildung von ganzzahligen Konstanten
.ce 0
.sp 1.5
.zE
Bei den dezimalen Konstanten m\*ussen f\*uhrende Nullen
entfernt werden, da sie sonst in C als oktale Konstanten
interpretiert werden.
.sp 0.4v
.ne 2v
.ti +2n
Ganzzahlige Konstanten haben in C den Typ \fIint\fP oder \fIlong\fP, d.h.
sie werden als ganze Zahl mit Vorzeichen interpretiert. \%Modula-2
definiert, da\*s eine ganzzahlige Konstante \fIn\fP, deren Wert im Bereich
\%MAX\^(INTEGER)\ <\ \fIn\fP\ \(<=\ MAX\^(CARDINAL)
liegt, den Typ \%CARDINAL hat, d.h. \fIn\fP wird als ganze Zahl ohne
Vorzeichen interpretiert.
Bei einer direkten \*Ubersetzung einer solchen Konstanten entsprechend der obigen
Tabelle nach C, w\*urde das dazugeh\*orige Bitmuster vom C-\*Ubersetzer als
negative Zahl interpretiert. Daher wird einer solchen Konstanten in C eine
explizite Typumwandlung in den Typ \%\fIunsigned\ long\fP vorangestellt,
um eine korrekte Interpretation als ganze Zahl ohne Vorzeichen durch den
C-\*Ubersetzer zu erzwingen.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur Zeichenkonstanten der Form \%[0-7]+\ C existiert ein \*ahnliches
Problem. \%MOCKA erlaubt Zeichenkonstanten \fIc\fP im Bereich
\%0\ \(<=\ \fIc\fP\ \(<=\ 255.
In C haben Zeichenkonstanten den Typ \%\fIchar\fP. Werden C-Zeichenkonstanten
oder -variablen z.B. in relationalen Ausdr\*ucken verwendet, so werden sie
zun\*achst implizit in den Typ \%\fIint\fP umgewandelt. Diese
Umwandlung ist maschinenabh\*angig. Eine Zeichenkonstante, deren Wert als
oktales Bitmuster definiert ist, kann dabei negativ erscheinen. Der
Modula-Ausdruck
\%0C\ <\ 377C
ist immer wahr,
der C-Ausdruck
\%'\e0'\ <\ '\e377'
ist dagegen, abh\*angig von der jeweiligen Maschine, wahr oder falsch.
Um diese Fehlinterpretation zu vermeiden, wird, wie der obigen Tabelle zu
entnehmen ist, solchen Zeichenkonstanten in C eine explizite Typumwandlung
in den Typ
\%\fIunsigned\ char\fP vorangestellt, was zur Folge hat, da\*s bei einer
impliziten Typumwandlung in den Typ \%\fIint\fP kein negativer Wert mehr
entstehen kann.
.sp 0.4v
.ne 2v
.ti +2n
Im Modula-Programm enthaltene Gleitpunktkonstanten k\*onnen textuell
in das erzeugte C-Programm eingesetzt werden, da die in \%Modula-2
zul\*assigen Gleitpunktkonstanten eine Teilmenge der in C
zul\*assigen Gleitpunktkonstanten darstellen.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Zeichenketten\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Zeichenketten
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung von Zeichenketten h\*angt davon ab, wie sie im
Modula-Programm verwendet werden. Dabei mu\*s insbesondere
folgendes beachtet werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine Zeichenkette der L\*ange n ist in \%Modula-2 vom Typ
\%ARRAY\ [\^0\^..\^n\^-1\^]\ OF\ CHAR.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine Zeichenkette der L\*ange 1 ist in \%Modula-2
kompatibel mit dem Typ \%CHAR.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&In C wird eine Zeichenkette als initialisierter Vektor von
Zeichen betrachtet, der am Ende ein zus\*atzliches NUL-Zeichen enth\*alt.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C unterscheidet zwischen Zeichenkonstanten und Zeichenketten der
L\*ange 1.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Bei der Abbildung wird daher folgenderma\*sen vorgegangen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine Zeichenkette der Sprache Modula-2 mit L\*ange \%n\ >\ 1
wird auf eine Zeichenkette der Sprache C abgebildet.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Falls eine Zeichenkette der L\*ange 1 in einem Kontext benutzt wird,
in dem ein Ausdruck vom Typ CHAR erwartet wird, dann wird sie auf eine
C-Zeichenkonstante abgebildet. Wird diese Zeichenkette jedoch in einem Kontext
benutzt, in dem ein Ausdruck vom Typ
\%ARRAY\ [\^0\^..\^0\^]\ OF\ CHAR
erwartet wird, dann wird sie zu einer C-Zeichenkette.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die folgenden Zeichen m\*ussen in C
innerhalb von Zeichenketten und -konstanten durch das
Fluchtsymbol\ \e\ maskiert werden:\ \ \e\ \ '\ \ ".
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Kommentare\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Kommentare
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Kommentare im Modula-Programm k\*onnten auf C-Kommentare abgebildet
werden, wobei ber\*ucksichtigt werden m\*u\*ste, da\*s C keine geschachtelten
Kommentare kennt. Da aber in Modula-2 Kommentare an jeder beliebigen Stelle des
Programms stehen k\*onnen und es keine allgemeinen Regeln bez\*uglich der
Zuordnung von Kommentaren zu Programmstellen gibt, w\*urde im erzeugten
C-Programm \(em bei jeder f\*ur diese Zuordnung gew\*ahlten L\*osung \(em
ein erheblicher
Teil der Kommentare an die falschen Programmstellen plaziert. Daher ist
es sinnvoller auf die Kommentare im C-Programm v\*ollig zu verzichten.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&G\*ultigkeit und Sichtbarkeit\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&G\*ultigkeit und Sichtbarkeit
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Regeln bez\*uglich G\*ultigkeit und Sichtbarkeit von Bezeichnern
in \%Modula-2 und C weisen eine Reihe von Unterschieden auf, die bei der
Abbildung ber\*ucksichtigt werden m\*ussen.
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 erm\*oglicht es durch das Modulkonzept den G\*ultigkeitsbereich
bzw. die Sichtbarkeit
von in globalen oder lokalen Moduln\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Ein globaler Modul ist ein
Programmodul oder er besteht aus einem Definitions- und einem
Implementierungsmodul.
.nE
\&
vereinbarten Bezeichnern mit
Import- bzw. Exportanweisungen explizit zu kontrollieren. Au\*serdem
kann man, insbesondere zur Vermeidung von Namenskonflikten, importierte
Bezeichner durch den Namen des sie exportierenden Moduls qualifizieren.
C hat kein vergleichbares Modulkonzept. Die einzige in C vorhandene
M\*oglichkeit zur expliziten Kontrolle des G\*ultigkeitsbereichs von Bezeichnern
ist, die Sichtbarkeit von globalen Objekten durch Angabe der
Speicherklasse \%\fIstatic\fP auf die sie enthaltende Quelldatei zu
beschr\*anken. Daher wird bei der Abbildung nach C wie folgt vorgegangen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle von globalen Moduln exportierten Bezeichner werden in den
C-Programmen in der qualifizierten Form \%\fIModulname_Bezeichner\fP geschrieben,
um Namenskonflikte zu vermeiden. Eine Qualifikation nur bei Namenskonflikten
ist nicht mit einer getrennten \*Ubersetzung von globalen Moduln nach C
vereinbar.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&In lokalen Moduln deklarierte Bezeichner werden
in unqualifizierter Form geschrieben. Sie m\*ussen durch einen
Pr\*afix umbenannt werden, falls bei der Abbildung der lokalen Moduln nach
C Namenskonflikte entstehen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle globalen Funktionen und Variablen, die nicht
exportiert werden, werden in C in der Speicherklasse \%\fIstatic\fP vereinbart,
um ihre Sichtbarkeit auf die sie enthaltende Quelldatei zu beschr\*anken.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 erlaubt, da\*s ein Bezeichner in einer Anweisung verwendet
wird, die textuell der Deklaration des Bezeichners vorausgeht; dies ist in C
nicht zul\*assig\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Einzige Ausnahme: Funktionen die ein Resultat vom Typ \fIint\fP
liefern.
.nE
\&.
Dieses Problem wird folgenderma\*sen gel\*ost:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle Prozedurdeklarationen werden an das Ende des sie enthaltenden
Deklarationsteils verschoben. Abgesehen von dieser Verschiebung bleibt
die urspr\*ungliche Reihenfolge der Deklarationen erhalten. Damit erfolgen
alle Konstanten-, Variablen- und Typdeklarationen vor ihrer ersten Verwendung
in einer Anweisung.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle Prozeduren, die vor
ihrer Vereinbarung verwendet werden, m\*ussen im C-Programm vor ihrer
ersten Benutzung durch eine Deklaration der Form
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
Speicherklasse  Ergebnistyp  Prozedurname  ();
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
bekannt gemacht werden. Eine solche Deklaration \(em die einer
\fIforward\fP\^-Deklaration in \%Pascal entspricht\(em ist insbesondere
dann notwendig, wenn sich Prozeduren gegenseitig rekursiv aufrufen.
Die Speicherklasse ist \%\fIstatic\fP, falls die Prozedur nicht exportiert
wird, und \%\fIextern\fP, falls sie exportiert wird.
.in -4n
.sp 0.1vv
.sp 0.3vv
Der folgende Ausschnitt eines Modula-Programms
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
PROCEDURE Expr;
BEGIN
  Term;
  WHILE Token = "+" DO
    Token := GetToken ();
    Term;
  END;
END Expr;
.sp 0.4v
.br
.ne 3
PROCEDURE Term;
BEGIN
  Factor;
  ...
.sp 0.4v
.br
.ne 3
PROCEDURE Factor;
BEGIN
  CASE Token OF
  | "(" : Token := GetToken (); Expr;
  ...
VAR  Token : CHAR;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
CHAR Token;
.sp 0.4v
extern void Term   ();
extern void Factor ();
.sp 0.4v
.br
.ne 3
void Expr()
{
    Term();
    while (Token == '+') {
        Token = GetToken();
        Term();
    }
}
.sp 0.4v
.br
.ne 3
void Term()
{
    Factor();
  ...
.sp 0.4v
.br
.ne 3
void Factor()
{
    switch (Token) {
    case '(' :
        Token = GetToken(); Expr();
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 verlangt, da\*s in Deklarationen verwendete Bezeichner vor ihrer
ersten Anwendung vereinbart werden. Um jedoch die Definition von
,,rekursiven'' Typen zu erm\*oglichen, kann bei der Deklaration von
Zeigertypen der Name des Bezugstyps vor seiner Deklaration verwendet werden.
Das folgende Beispiel zeigt eine solche ,,rekursive'' Definition:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE
  tTree = POINTER TO tNode;
  tNode = RECORD
             Key   : INTEGER;
             Left  ,
             Right : tTree;
          END;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Da C die Verwendung von Strukturnamen erlaubt, bevor eine vollst\*andige
Definition der Struktur vorliegt, kann die obige Definition durch
Einf\*uhrung eines Strukturnamens nach C \*ubersetzt werden:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef struct S_1 *tTree;
.sp 0.4v
typedef struct S_1 {
    INTEGER Key;
    tTree   Left, Right;
} tNode;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Ist der Bezugstyp kein Verbund, so ist eine Abbildung nach C nur mit
erheblichem Aufwand m\*oglich. Eine allgemeine L\*osung k\*onnte
folgenderma\*sen aussehen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Handelt es sich nicht um eine ,,rekursive'' Typdeklaration,
dann werden die Deklarationen derart umgeordnet, da\*s alle Vereinbarungen der
beteiligten Typen vor ihrer ersten Anwendung erfolgen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Dies entspricht
einer topologischen Sortierung des gerichteten Graphen, der durch die
Relation ,,wird verwendet zur Deklaration von'' definiert wird.
.nE
\&.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Handelt es sich um eine ,,rekursive'' Typdeklaration, dann m\*ussen
einige oder alle der beteiligten Typen in C zu einer Struktur gemacht werden.
Die folgende Deklaration
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE
  tPointer1 = POINTER TO tPointer2;
  tPointer2 = POINTER TO tPointer1;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
w\*urde dann in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef struct S_2 *tPointer1;
.sp 0.4v
typedef struct S_2 {
    tPointer1 *X;
} tPointer2;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Diese L\*osung ist jedoch mit einem erheblichen \*Ubersetzungsaufwand
verbunden. Dar\*uberhinaus mu\*s man ber\*ucksichtigen, da\*s
Zeigerdeklarationen, in denen der Bezugstyp erst nach dem Zeigertyp
definiert wird, in der Praxis haupts\*achlich zur Definition von
Listen, B\*aumen oder \*ahnlichen Datenstrukturen verwendet werden. In diesen
F\*allen ist der Bezugstyp aber fast immer ein Verbund.
Aus diesen Gr\*unden ist es sinnvoller, Modula-Programme, die solche
Typdeklarationen
enthalten, nur dann nach C zu \*ubersetzen, wenn der Bezugstyp ein
Verbund ist.
.sp 0.4v
.ne 2v
.ti +2n
Symbolische Konstanten werden in C mit Hilfe der \fI#define\fP\^-Anweisung des
C-Pr\*aprozessors vereinbart.
Bei der Abbildung mu\*s ber\*ucksichtigt werden, da\*s
der G\*ultigkeitsbereich eines mit \%\fI#define\fP vereinbarten Makros
der gesamte Rest der Quelldatei ist.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur mit \%\fItypedef\fP vereinbarte Typnamen gilt laut C-Sprachbeschreibung
die \*ubliche Blockstruktur von C. Das hei\*st eine Deklaration der Art
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef char tType;
  ...
{
    typedef int tType;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
ist eigentlich zul\*assig. Viele C-\*Ubersetzer sind jedoch nicht in der
Lage, eine derartige Deklaration zu verarbeiten.
.sp 0.4v
.ne 2v
.ti +2n
Die oben genannten Einschr\*ankungen f\*ur die mehrfache
Verwendung von Konstanten- und Typnamen werden bei der
\*Ubersetzung
dadurch gel\*ost, da\*s die Namen von Konstanten und Typen
durch eine Umbenennung innerhalb einer Quelldatei eindeutig
gemacht werden.
.br
.ne 4
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Deklarationen\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Deklarationen
.hE 4n 5n 0v
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Konstantendeklarationen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Konstantendeklarationen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung von Konstantendeklarationen ist abh\*angig von der Art
der Konstante.
.sp 0.4v
.ne 2v
.ti +2n
Eine Konstante, deren Wert eine Zeichenkette mit L\*ange
\%n\ >\ 1 ist, wird auf einen Vektor von Zeichen
abgebildet, der mit der angegebenen Zeichenkette initialisiert
wird. Ist der Wert der Konstante eine Zeichenkette der L\*ange 1, dann wird
diese Konstante im C-Programm mit einer \fI#define\fP\^-Anweisung als
Zeichenkonstante definiert. Wird diese Konstante jedoch in einem Kontext
benutzt, in dem ein Ausdruck mit Typ
\%ARRAY\ [\^0\^..\^0\^]\ OF\ CHAR
erwartet wird, dann mu\*s der Wert der Konstante als Zeichenkette direkt
f\*ur den Konstantennamen eingesetzt werden.
.sp 0.4v
.ne 2v
.ti +2n
Alle \*ubrigen im Modula-Programm vereinbarten Konstanten werden im
erzeugten C-Programm mit einer \fI#define\fP\^-Anweisung
vereinbart. Konstante
Ausdr\*ucke werden dabei auf die entsprechenden C-Ausdr\*ucke abgebildet,
wenn der Ausdruck auch in C einen konstanten Ausdruck bildet.
Konstante Ausdr\*ucke, die logische Operatoren, einen in C als Funktion
definierten Operator oder eine in C als Funktion definierte Standardfunktion
enthalten, sind in C nicht mehr konstant.
Solche Ausdr\*ucke werden bei der \*Ubersetzung ausgewertet und der Wert des
Ausdrucks wird f\*ur den Ausdruck eingesetzt. Diese Unterscheidung ist
notwendig, damit benannte Konstanten in C f\*ur Fallmarken von
\fIswitch\fP\^-Anweisungen und zur Dimensionierung von Vektoren verwendet werden
k\*onnen. Die Alternative, konstante Ausdr\*ucke immer schon bei der
\*Ubersetzung auszuwerten, vermindert die Lesbarkeit der erzeugten Programme
und wurde daher verworfen.
Somit werden die folgenden Deklarationen
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
CONST
  Message       = "hello world";
  BitsPerBitset = SIZE (BITSET) * 8;
  EmptySet      = {};
  MaxToken      = 63;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
CHAR Message[] = "hello world";
.sp 0.4v
#define BitsPerBitset   (sizeof(BITSET) * 8)
#define EmptySet        0XL
#define MaxToken        63
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Eine Auswertung von konstanten Ausdr\*ucken bei der \*Ubersetzung nach C
ist in den meisten F\*allen
problemlos m\*oglich. Die von \%MOCKA
gemachte Einschr\*ankung, da\*s konstante Ausdr\*ucke keine Standardfunktionen
enthalten d\*urfen, wird dabei fallengelassen. Schwierigkeiten bereitet
aber die Auswertung der Funktionen \%SIZE, \%TSIZE, \%MAX
und \%MIN, da diese sowohl von der Abbildung der Typen nach C
als auch von der Typabbildung des verwendeten C-\*Ubersetzers abh\*angen. Dieses
Problem wird folgenderma\*sen gel\*ost:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der \*Ubersetzer enth\*alt eine Tabelle, in der vermerkt ist, welche
Gr\*o\*se die Grund-, Standard-, Aufz\*ahlungs-, Mengen- und Zeigertypen in C haben. Die
obigen Standardfunktionen k\*onnen f\*ur diese Typen mit Hilfe der Tabelle
ausgewertet werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Feld- oder Verbundtypen als Argumente sind nicht zul\*assig, da dazu
die genaue Typabbildung des C-\*Ubersetzers, insbesondere die m\*oglicherweise
notwendige Ausrichtung von Strukturkomponenten, bekannt sein m\*u\*ste.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da der C-Pr\*aprozessor Textersatz vornimmt, wird der Wert aller mit
\%\fI#define\fP vereinbarten Konstanten im C-Programm textuell
f\*ur den Konstantennamen eingesetzt. Deshalb ist es nicht sinnvoll,
Zeichenketten mit \%\fI#define\fP zu vereinbaren, denn in einem
C-Programm sind alle Zeichenketten verschieden, selbst wenn sie aus der
gleichen Zeichenfolge bestehen. Das bedeutet, da\*s das erzeugte Objektprogramm
bei mehrfacher Anwendung eines mit \%\fI#define\fP vereinbarten
Konstantennamens die zugeh\*orige Zeichenkette
ebenfalls mehrfach enthalten w\*urde. Die Deklaration als initialisierter
Vektor vermeidet dies.
.sp 0.4v
.ne 2v
.ti +2n
Wird der Wert der Modula-Konstante durch einen konstanten Ausdruck
spezifiziert, mu\*s bei der Abbildung nach C noch folgendes beachtet
werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Ausdruck mu\*s, wegen des vom C-Pr\*aprozessor vorgenommenen
Textersatzes, geklammert werden, um eine korrekte Auswertungsreihenfolge
zu garantieren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Falls der Ersatztext Namen enth\*alt, die nicht selbst als Makros
vereinbart sind, mu\*s darauf geachtet werden, da\*s nicht auf subtile Art
und Weise im C-Programm Namenskonflikte entstehen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Konstante Ausdr\*ucke werden vom C-\*Ubersetzer bereits bei der
\*Ubersetzung des C-Programms ausgewertet.
.in -4n
.sp 0.1vv
.sp 0.3vv
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Typdeklarationen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Typdeklarationen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die im Modula-Programm vereinbarten Typen werden im erzeugten C-Programm
mittels einer \fItypedef\fP\^-Anweisung vereinbart.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Typkompatibilit\*at\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Typkompatibilit\*at
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die von \%MOCKA implementierten Regeln
hinsichtlich Typ- und Zuweisungskompatibilit\*at, die weniger streng sind,
als die
in der Sprachbeschreibung von \%Modula-2 enthaltenen, bilden die Grundlage
f\*ur diese Abbildung. Es mu\*s besonders darauf geachtet werden, da\*s Typen,
die in \%Modula-2 typ- bzw. zuweisungskompatibel sind, dies auch
im erzeugten C-Programm sind. Dabei k\*onnen folgende Eigenschaften von C
vorteilhaft ausgenutzt werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C definiert f\*ur arithmetische Typen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Zu den arithmetischen Typen
geh\*oren in C die Typen: \%\fIchar\fP, \%\fIint\fP, \%\fIfloat\fP
und \%\fIdouble\fP. Der Typ \%\fIint\fP kann mit einer Gr\*o\*senangabe
\%\fIshort\fP oder \%\fIlong\fP versehen sein. Au\*serdem kann man
\%\fIchar\fP\^- und \fIint\fP\^-Objekte auch als
\%\fIunsigned\fP, d.h. als ganze Zahl ohne Vorzeichen,
vereinbaren.
.nE
\& eine gro\*se Zahl von impliziten Typumwandlungen in Ausdr\*ucken
bei der Zuweisung und der Parameter\*ubergabe. Arithmetische Typen
k\*onnen daher in C fast in beliebiger Kombination verwendet werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Von den meisten C-\*Ubersetzern werden Zeichen und ganzzahlige
Werte, unabh\*angig von ihrem tats\*achlichen Speicherbedarf, bei der
Parameter\*ubergabe mit 4 Byte \*ubergeben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der C-\*Ubersetzer erlaubt Zuweisungen zwischen Zeigern verschiedenen
Typs. Bei der \*Ubergabe von Zeigern an eine Funktion darf sich der Typ des
aktuellen Parameters vom Typ des formalen Parameters unterscheiden. Diese
Zuweisungen bzw. Parameter\*ubergaben erfolgen als reine Kopien, ohne jede
Umwandlung. Ohne eine explizite Typumwandlung wird das Pr\*ufprogramm
\%\fIlint\fP,
mit dem C-Programme auf semantische Fehler untersucht werden k\*onnen, an
diesen Stellen Typfehler melden, was aber nicht unbedingt bedeuten mu\*s, da\*s
die Programme wirklich fehlerhaft sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der C-\*Ubersetzer nimmt praktisch keine Typpr\*ufungen vor.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Bei der Abbildung der nicht zusammengesetzten Typen wird darauf geachtet,
da\*s die Gr\*o\*se der Typen im C-Programm wenn m\*oglich der von \%MOCKA
f\*ur die entsprechenden Modula-Typen vorgesehenen Gr\*o\*se entspricht. Mit dieser
Voraussetzung und aufgrund der oben geschilderten Eigenschaften von C sind
im erzeugten C-Programm nur an einigen wenigen Stellen explizite
Typumwandlungen notwendig, damit die C-Programme korrekt funktionieren.
Durch die Angabe einer Option bei der \*Ubersetzung von \%Modula-2 nach
C kann man \%\fIMtc\fP allerdings dazu veranlassen, weitere explizite
Typumwandlungen zu
erzeugen, die f\*ur das korrekte Funktionieren der erzeugten C-Programme nicht
unbedingt notwendig sind und daher normalerweise wegen der damit verbundenen
schlechteren Lesbarkeit der C-Programme weggelassen werden, die aber dazu
f\*uhren, da\*s \%\fIlint\fP keine Typfehler mehr meldet.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Grundtypen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Grundtypen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Menge der vordefinierten Grundtypen von \%Modula-2, die
aus den
Typen \%INTEGER, \%CARDINAL,
\%BOOLEAN, \%CHAR, \%REAL, \%LONGREAL und \%LONGINT
besteht, ist entsprechend der von \%MOCKA implementierten Spracherweiterung
um die Grundtypen \%SHORTINT, \%SHORTCARD und \%LONGCARD
erweitert. Die Definition dieser Grundtypen ist in der Definitionsdatei
\%SYSTEM_.h enthalten, die mit Hilfe einer
\fI#in\%clude\fP\^-\%An\%wei\%sung
vom C-Pr\*aprozessor in jedes erzeugte C-Programm eingef\*ugt wird.
Die folgende Aufz\*ahlung zeigt die Definition
der Grundtypen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Da \%MOCKA die Typen \%INTEGER und
\%LONGINT sowie \%CARDINAL und \%LONGCARD als
synonym vereinbart, werden sie auch bei der Abbildung nach
C als synonym vereinbart.
.nE
\&:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
typedef short           SHORTINT;
typedef long            LONGINT;
typedef LONGINT         INTEGER;
.sp 0.4v
.br
.ne 3
typedef unsigned short  SHORTCARD;
typedef unsigned long   LONGCARD;
typedef LONGCARD        CARDINAL;
.sp 0.4v
.br
.ne 3
typedef unsigned char   BOOLEAN;
#define FALSE           (BOOLEAN)0
#define TRUE            (BOOLEAN)1
.sp 0.4v
typedef unsigned char   CHAR;
.sp 0.4v
.br
.ne 2
typedef float           REAL;
typedef double          LONGREAL;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Der Typ \%CHAR mu\*s, wegen der Probleme bei der impliziten Umwandlung von
Zeichenwerten in ganzzahlige Werte (s. Kap. \n(h1.2.2), in C als
\%\fIunsigned\ char\fP und nicht als \%\fIchar\fP definiert werden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Aufz\*ahlungstypen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Aufz\*ahlungstypen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die auf den ersten Blick naheliegende Abbildung von Aufz\*ahlungstypen
ist, die Aufz\*ahlungstypen von \%Modula-2 direkt
auf die Aufz\*ahlungstypen von C abzubilden. Die Deklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE  Color = (red, green, blue);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
w\*urde damit in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef enum {red, green, blue} Color;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die C-Sprachbeschreibung legt fest, da\*s die in der Aufz\*ahlung
genannten Namen als Konstanten vereinbart sind und \*uberall
dort verwendet werden k\*onnen, wo in C Konstanten zul\*assig sind.
Die Konstanten erhalten aufeinanderfolgende ganzzahlige Werte, wobei
die erste Konstante der Aufz\*ahlung den Wert 0 hat. Viele C-\*Ubersetzer
verbieten jedoch, Aufz\*ahlungskonstanten z.B. in Vergleichen oder
zur Indizierung von Vektoren zu verwenden. Diese Einschr\*ankung kann
allerdings umgangen werden, indem Aufz\*ahlungskonstante in diesen
F\*allen mittels einer expliziten Typumwandlung in einen \fIint\fP\^-Wert
umgewandelt werden:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
a[(int)red] = 1;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Eine weitere Schwierigkeit ist, da\*s eine Reihe von C-\*Ubersetzern es nicht
vertr\*agt, wenn eine Aufz\*ahlungskonstante innerhalb einer Funktion lokal
neu deklariert wird. Solche Aufz\*ahlungskonstanten m\*u\*sten daher umbenannt
werden.
.sp 0.4v
.ne 2v
.ti +2n
Um die oben genannten Probleme zu vermeiden, wurde folgende Abbildung
gew\*ahlt: der Aufz\*ahlungstyp wird entsprechend der Anzahl
von Aufz\*ahlungskonstanten in einen \fIunsigned\fP\^-Typ geeigneter Gr\*o\*se
umgesetzt; die Aufz\*ahlungskonstanten werden mit \fI#define\fP\^-Anweisungen
als symbolische Konstanten vereinbart.
F\*ur die Namen der Aufz\*ahlungskonstanten gilt wie f\*ur alle mit \%\fI#define\fP
vereinbarten Konstantennamen, da\*s sie bei Bedarf durch eine Umbenennung innerhalb
der sie enthaltenden Quelldatei eindeutig gemacht werden m\*ussen (s. Kap. \n(h1.3).
Die obige Deklaration wird dann zu:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define red     0
#define green   1
#define blue    2
.sp 0.4v
typedef unsigned char Color; 
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Der Vorteil dieser L\*osung ist, da\*s keine Typumwandlungen mehr notwendig
sind; der Nachteil eine schlechtere Lesbarkeit der Typdeklaration.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Unterbereichstypen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Unterbereichstypen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Unterbereichstypen werden nach C abgebildet, indem mit Hilfe einer
\fItypedef\fP\^-Anweisung der Name des Unterbereichstyps als
synonym zum Namen des
Basistyps vereinbart wird. Ist der Basistyp
in der Deklaration des Unterbereichstyps nicht explizit angegeben,
so mu\*s er aus dem Typ der unteren und/oder oberen Grenze des
Unterbereichstyps abgeleitet werden. Sind die untere/obere Grenze
ganzzahlige Konstanten, dann legt die Sprachbeschreibung von
\%Modula-2 fest, da\*s der Basistyp \%INTEGER ist, falls
die untere Grenze eine negative Zahl ist, und ansonsten \%CARDINAL.
Somit werden die folgenden Deklarationen
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE
  TrafficLight  = [red..green];
  tToken        = [0..MaxToken];
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef Color     TrafficLight;
typedef CARDINAL  tToken;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Felder\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Felder
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Eine direkte Abbildung der Felder der Sprache \%Modula-2 auf die Vektoren
der Sprache C ist, wegen der ungew\*ohnlichen Semantik der Vektoren,
nicht sinnvoll. Vektoren k\*onnen nicht als Ganzes zugewiesen werden
oder als Wertparameter \*ubergeben werden. Bei der Zuweisung und der
Parameter\*ubergabe wird ein Vektorname immer als Zeiger auf das erste
Element des Vektors interpretiert. Aus diesem Grund mu\*s in C die
Zuweisung eines Vektors elementweise erfolgen.
Will man den Vektor als Wertparameter
\*ubergeben, mu\*s der \*ubergebene Vektor am Anfang der
Funktion in einen lokal vereinbarten Vektor kopiert werden.
Da neuere C-\*Ubersetzer in der Lage sind Strukturen als Ganzes zuzuweisen oder
sie als Wertparameter an Funktionen zu \*ubergeben, wird
diese Schwierigkeit umgangen, indem ein Feld auf eine
Struktur mit einem Vektor \fIA\fP als einziger Komponente abgebildet wird
[PTC\|87].
Die Anzahl der Elemente von Vektoren wird in C durch einen
konstanten Ausdruck angegeben, daher mu\*s bei der \*Ubersetzung f\*ur den
Indextyp ein konstanter Ausdruck erzeugt werden, der angibt
wieviele verschiedene Werte der Indexbereich umfa\*st.
Die folgenden Typdeklarationen
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE
  tString       = ARRAY [0..255] OF CHAR;
  tTokenSet     = ARRAY [0..1] OF BITSET; 
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
werden in C also zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
typedef struct S_3 {
    CHAR A[255 + 1];
} tString;
.sp 0.4v
.br
.ne 3
typedef struct S_4 {
    BITSET A[1 + 1];
} tTokenSet;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Diese L\*osung hat mehrere Vorteile: Zun\*achst wird damit die Zuweisung von
Feldern bzw. ihre \*Ubergabe als Wertparameter erheblich effizienter, weil
kein C-Code zum Kopieren mehr
notwendig ist, sondern direkt der Zuweisungsoperator
bzw. der Parameter\*ubergabemechanismus von C verwendet
werden kann. Der vom C-\*Ubersetzer daf\*ur erzeugte Code
ist in der Regel effizienter, da spezielle Assembler-Befehle
verwendet werden k\*onnen. Der zweite Vorteil ist eine Vereinfachung des
\*Ubersetzers, weil Felder jetzt bei der Zuweisung, der Parameter\*ubergabe
und der Adre\*sbestimmung wie alle anderen Datentypen behandelt werden k\*onnen.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Verbunde\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Verbunde
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 verlangt die Eindeutigkeit der Komponentennamen eines Verbundes
lediglich innerhalb der Definition des Verbundtyps. Insbesondere kann man
in einem Deklarationsteil den gleichen Komponentennamen in der
Definition von zwei verschiedenen Verbunden benutzen. Die C-Sprachbeschreibung
fordert, da\*s die Namen aller Komponenten
von zwei im gleichen G\*ultigkeitsbereich vereinbarten Strukturen
untereinander verschieden sind\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Ausnahme: Zwei Strukturen
beginnen mit der gleichen Folge von Komponenten.
.nE
\&.
Die meisten neueren C-\*Ubersetzer sind hier allerdings gro\*sz\*ugiger und
verlangen die Eindeutigkeit nur innerhalb der Definition einer
Struktur. Diese Regel
wird voraussichtlich auch im neuen C-Sprachstandard enthalten sein. Daher werden
Verbunde direkt, ohne Ber\*ucksichtigung von m\*oglichen Namenskonflikten
aufgrund identischer Komponentennamen,
auf die Strukturen der Sprache C abgebildet. Somit wird die Typdeklaration
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE  date = RECORD
               day   : [1..31];
               month : [1..12];
               year  : CARDINAL;
             END;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef struct S_5 {
    CARDINAL day;
    CARDINAL month;
    CARDINAL year;
} date;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Die Strukturen, auf die die Felder und Verbunde der Sprache \%Modula-2
abgebildet werden, erhalten immer einen Strukturnamen. Diese Strukturnamen
werden in den erzeugten C-Programmen an verschiedenen Stellen ben\*otigt,
z.B. bei der \*Ubersetzung von Vorw\*artsreferenzen in Zeigerdeklarationen
(s. Kap. \n(h1.3). Wegen der getrennten
\*Ubersetzung und zur Vermeidung von Namenskonflikten haben die Strukturnamen
der in einem Definitionsmodul definierten Verbunde und Felder in C die lange
Form \%\fIModulname_nnn\fP\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Besteht der Modulname nur aus einem
Buchstaben, so wird das Zeichen _ verdoppelt, um theoretisch m\*ogliche
Namenskonflikte mit anderen vom \*Ubersetzer erzeugten Bezeichnern zu
verhindern.
.nE
\&; alle \*ubrigen Strukturnamen haben die k\*urzere
Form \%\fIS_nnn\fP.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Verbunde mit Varianten\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Verbunde mit Varianten
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Datenstruktur Variante der Sprache C entspricht einem varianten Teil eines
Verbundes in \%Modula-2. Eine Variante in C kann allerdings \(em im
Gegensatz zu einer Variante in \%Modula-2 \(em nur
eine einzige Komponente zur gleichen
Zeit enthalten\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Die f\*ur die jeweiligen Datenstrukturen der beiden
Sprachen gebr\*auchlichen deutschen Begriffe sind hier leider etwas verwirrend.
Eine Komponente der C-Datenstruktur Variante (Englisch: Union) entspricht
einer Variante eines varianten Teils eines Modula-Verbundes.
.nE
\&.
.sp 0.4v
.ne 2v
.ti +2n
Die Typdeklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
TYPE  tRecord =    RECORD
                     x ,
                     y : CHAR;
.br
.ne 3
        CASE      tag0 : Color OF
        | red   : a, b : CHAR;
        | green : c, d : CHAR;
        | blue  : e, f : CHAR;
        END;
                     z : CHAR;
.br
.ne 2
        CASE      tag1 : BOOLEAN OF
        | TRUE  : u, v : INTEGER;
        | FALSE : r, s : INTEGER;
        END;
      END;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
typedef struct S_6 {
    CHAR    x, y;
    Color   tag0;
.br
.ne 2
    union {
        struct {CHAR a, b;} V_1;
        struct {CHAR c, d;} V_2;
        struct {CHAR e, f;} V_3;
    } U_1;
    CHAR    z;
    BOOLEAN tag1;
.br
.ne 2
    union {
        struct {INTEGER u, v;} V_1;
        struct {INTEGER r, s;} V_2;
    } U_2;
} tRecord;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Jeder variante Teil des Modula-Verbundes wird in C zu einer Variante. In C mu\*s
die Variante allerdings, da sie eine Komponente der umfassenden Struktur ist,
einen zus\*atzlichen Komponentennamen \%\fIU_nnn\fP bekommen, wobei
\%\fInnn\fP angibt, um den
wievielten varianten Teil des Modula-Verbundes es sich handelt. Zur
Umgehung der Einschr\*ankung, da\*s Varianten in C nur genau eine Komponente zur
gleichen Zeit enthalten k\*onnen, mu\*s jede Variante des Modula-Verbundes in C
zus\*atzlich in eine Struktur geklammert werden. Diese Strukturen erhalten den
Komponentennamen \%\fIV_nnn\fP, wobei \%\fInnn\fP
angibt, um die wievielte Variante innerhalb
eines varianten Teils es sich jeweils handelt. Bei der \*Ubersetzung des Zugriffs
auf Varianten m\*ussen diese zus\*atzlichen Komponentennamen dann entsprechend
ber\*ucksichtigt werden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Mengen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Mengen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Mengen werden in C einheitlich auf den Typ
\%\fIunsigned\ long\fP abgebildet. Damit kann
eine Menge maximal 16 oder 32 Elemente enthalten\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ \%MOCKA macht die
gleiche Einschr\*ankung, daher d\*urfte dies in unserem Fall keine wirkliche
Einschr\*ankung bedeuten.
.nE
\& je nach Gr\*o\*se des Typs auf der Zielmaschine.
Diese Abbildung vereinfacht die Behandlung von Mengen und steigert zus\*atzlich die
Effizienz der Mengenverarbeitung, da jetzt:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Konstante Mengen in C als Hexadezimalkonstante oder als konstante
Ausdr\*ucke dargestellt werden
k\*onnen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Mengenoperationen in C weitgehend ohne zus\*atzliche Funktionsaufrufe
mit den Operatoren zur Bitmanipulation implementiert werden
k\*onnen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Mengen als Wertparameter \*ubergeben und als Funktionsergebnis
geliefert werden k\*onnen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.zA
.sp 0.4v
.ne 2v
.ti +2n
Der Standardtyp \%BITSET ist definiert als:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef unsigned long BITSET;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Zeiger\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Zeiger
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Zeigertypen werden direkt auf die Zeigertypen der Sprache C
abgebildet. Damit wird
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE  PtrToCardinal = POINTER TO CARDINAL;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef CARDINAL *PtrToCardinal;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Wie oben bereits erl\*autert, werden die
Zeigerdeklarationen, in denen der Bezugstyp erst
nach dem Zeigertyp vereinbart wird, auf F\*alle beschr\*ankt,
in denen der Bezugstyp ein Verbund oder ein Feld ist.
.zA
.sp 0.4v
.ne 2v
.ti +2n
Die Konstante \%NIL ist in \%SYSTEM_.h als
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define NIL     0L
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
definiert.
.zE
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Prozedurtypen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Prozedurtypen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Ein Prozedurtyp wird in C zu einem Zeiger auf eine
Funktion mit entsprechendem Ergebnistyp.
Somit wird die Typdeklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE  Function = PROCEDURE (CARDINAL): CARDINAL;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in folgende C-Deklaration umgesetzt:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef CARDINAL (*Function)();
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zA
.sp 0.4v
.ne 2v
.ti +2n
Der Standardtyp \%PROC ist definiert als:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef void (*PROC)();
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Variablendeklarationen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Variablendeklarationen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Variablendeklarationen werden auf entsprechende C-Variablendeklarationen
abgebildet, die aus einem Typnamen und einer Liste von Deklaratoren
[Kernighan\|78] bestehen.
Die folgenden Variablendeklarationen (s. Beispiele Kap. \n(h1.3 und \n(h1.\n(h2.2)
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
VAR
  x, y  : POINTER TO INTEGER;
  i, j  : CARDINAL;
  p, q  : BOOLEAN;
  s     : BITSET;
  F     : Function;
  S     : tString;
  t     : tTree;
.br
.ne 5
  w, v  : ARRAY [0..7] OF
            RECORD
              ch    : CHAR;
              count : CARDINAL;
            END;
.br
.ne 2
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
werden somit in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
INTEGER     *x, *y;
CARDINAL    i, j;
BOOLEAN     p, q;
BITSET      s;
Function    F;
tString     S;
tTree       t;
.sp 0.4v
.br
.ne 6
struct S_7 {
    struct S_8 {
        CHAR     ch;
        CARDINAL count;
    } A[7 + 1];
} w, v;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Prozedurdeklarationen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Prozedurdeklarationen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Deklaration einer Prozedur oder Funktion wird
in C auf eine Funktionsdeklaration abgebildet.
Eine Prozedur hat als C-Funktion
den Ergebnistyp \%\fIvoid\fP, womit in C angedeutet wird, da\*s die
Funktion kein Ergebnis liefert.
Sowohl \%Modula-2 als auch C erlauben rekursive Aufrufe
von Prozeduren bzw. Funktionen. Prozedurdeklarationen k\*onnen in
Modula-2 beliebig geschachtelt werden; C erlaubt keine geschachtelten
Funktionsdeklarationen. Aus diesem Grund mu\*s ein Modula-Programm, das
solche geschachtelten Prozedurdeklarationen enth\*alt, bei der
\*Ubersetzung nach C derart transformiert werden, da\*s keine
geschachtelten Prozedurdeklarationen mehr vorhanden sind.
Bei dieser Transformation m\*ussen besonders die beiden folgenden Punkte
beachtet werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei der Deklaration einer lokalen Prozedur in \%Modula-2 k\*onnen
Konstanten und/oder Typen verwendet werden, die in einer statisch
umfassenden Prozedur vereinbart sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine lokale Prozedur kann auf eine lokale Variable
einer statisch umfassenden Prozedur zugreifen.
Um diesen Zugriff zur Laufzeit zu erm\*oglichen, enth\*alt in \%Modula-2
jede Prozedurschachtel einen Verweis auf die Schachtel
ihres statischen Vorg\*angers.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Geschachtelte Prozedurdeklarationen werden daher folgenderma\*sen behandelt:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ist eine Prozedur \fIQ\fP lokal in einer Prozedur \fIP\fP deklariert,
dann steht die Funktion \fIQ\fP in C vor der Funktion \fIP\fP.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle lokalen
Konstanten- und Typdeklarationen der Prozedur \fIP\fP
werden in C zu globalen Deklarationen,
die vor die Funktion \fIQ\fP plaziert werden, damit sie
auch f\*ur \fIQ\fP sichtbar sind.
Im Prinzip w\*urde es gen\*ugen, nur solche lokalen
Konstanten- und Typen von \fIP\fP global zu vereinbaren,
die in \fIQ\fP benutzt werden\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ 
Dies gilt dann nat\*urlich auch rekursiv f\*ur alle lokalen Objekte,
die in der Deklaration dieser Konstanten- und Typen verwendet werden.
.nE
\&.
Zur Vereinfachung der Transformation werden aber alle lokalen Konstanten-
und Typdeklarationen aus dem Modula-Programm in C zu globalen Deklarationen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Um in C der Funktion \fIQ\fP den Zugriff auf lokal in \fIP\fP vereinbarte Variablen
zu erm\*oglichen, gibt es verschiedene M\*oglichkeiten. Eine
Alternative ist, da\*s die Funktion \fIP\fP die Adressen der lokalen Variablen
als zus\*atzliche Parameter an \fIQ\fP \*ubergibt,
eine zweite Alternative verwendet
globale Zeigervariablen [PTC\|87], um den Zugriff zu realisieren. Diese
beiden Varianten werden unten n\*aher beschrieben und miteinander
verglichen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei dieser Transformation k\*onnen eventuell Namenskonflikte
entstehen. Diese werden in C durch Umbenennungen gel\*ost.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Zur Erl\*auterung der obigen Transformation und der beiden Alternativen, den
Zugriff auf lokale Variablen zu erm\*oglichen, dient der folgende Ausschnitt
eines Modula-Programms:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
PROCEDURE p;
.sp 0.4v
TYPE
  tCard = CARDINAL;
.sp 0.4v
VAR
  i, j  : tCard;
.sp 0.4v
.br
.ne 4
  PROCEDURE q;
  BEGIN
    i := 1;
  END q;
.sp 0.4v
.br
.ne 3
  PROCEDURE r;
  BEGIN
    j := 1;
    q;
  END r;
.sp 0.4v
.br
.ne 3
BEGIN
  r;
END p;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die erste Alternative einer Funktion \fIQ\fP, den Zugriff auf lokal in einer
Funktion \fIP\fP vereinbarte Variablen zu erm\*oglichen, geht von folgender
\*Uberlegung aus: Da die Prozedur \fIQ\fP im Modula-Programm lokal zur Prozedur
\fIP\fP vereinbart ist, ruft die Prozedur \fIP\fP irgendwann, m\*oglicherweise
indirekt \*uber den Aufruf weiterer lokaler Prozeduren, die Prozedur \fIQ\fP auf.
Ist dies nicht der Fall, dann ist die Prozedur \fIQ\fP ,,nutzlos'' und kann aus dem
Programm gestrichen werden. Um in C der Funktion \fIQ\fP den Zugriff auf ihre lokalen
Variablen zu erm\*oglichen, \*ubergibt \fIP\fP deren Adressen als zus\*atzliche
Parameter an \fIQ\fP. Wegen des m\*oglicherweise indirekten
Aufrufs von \fIQ\fP mu\*s zur Bestimmung der zus\*atzlichen Parameter der
Aufrufgraph der lokalen Prozeduren betrachtet werden. Einige der
zus\*atzlichen Parameter haben eventuell nur die Funktion, die Adressen
der Va\%ria\%blen entlang des Aufrufgraphen weiterzureichen. Prozedurvariablen
m\*ussen dabei nicht ber\*ucksichtigt werden, da in \%Modula-2 nur global
auf Ebene 0 vereinbarte Prozeduren als Wert von Prozedurvariablen zul\*assig
sind.
.sp 0.4v
.ne 2v
.ti +2n
Der folgende Datenflu\*salgorithmus berechnet die Mengen \%\fIParam\^(p)\fP,
die angeben, um welche Parameter die Parameterlisten der lokalen
Prozeduren bei der Abbildung nach C erweitert werden m\*ussen:
.sp 0.4v
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
BEGIN
  LocalProc := { p | p ist eine auf Ebene k \(>= 1 vereinbarte Prozedur }
.sp 0.4v
  GlobalVar := { v | v ist eine auf Ebene 0 vereinbarte Variable }
.sp 0.4v
.zA
  FORALL p \(mo LocalProc DO
    Local(p) := { v | v ist eine lokale Variable von p }
.sp 0.4v
    Call(p)  := { q | q \(mo LocalProc \(ba p ruft q auf }
.sp 0.4v
    Use(p)   := { v | v wird in p benutzt \(ba v \o'/\(mo' Local(p) \(ba v \o'/\(mo' GlobalVar }
.sp 0.4v
    Param(p) := Use(p)
  END
.zE
.sp 0.4v
.zA
  REPEAT
    Changed := FALSE
.sp 0.4v
    FORALL p \(mo LocalProc DO
      Old := Param(p)
.sp 0.4v
      Param(p) \(cu:= \(cu Param(q) \e Local(p)
\^                 q \(mo Call(p)
.sp 0.4v
      Changed := Changed OR (Param(p) \(!= Old)
    END
  UNTIL NOT Changed
END
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.sp 0.4v
.ne 2v
.ti +2n
Die REPEAT-Schleife im obigen Algorithmus
ist notwendig, weil der Aufrufgraph der lokalen Prozeduren
m\*oglicherweise aufgrund von Rekursion Zyklen enth\*alt. Die
Effizienz des Algorithmus ist stark abh\*angig von der Reihenfolge, in der die
Prozeduren der Menge \%\fILocalProc\fP
bearbeitet werden. Nach M\*oglichkeit sollte jede
Prozedur erst bearbeitet werden, wenn alle ihre Nachfolger im Aufrufgraph
bereits bearbeitet wurden. Enth\*alt der Aufrufgraph
keine Zyklen, dann sind bei dieser
Bearbeitungsreihenfolge h\*ochstens zwei Iterationen notwendig.
Mit diesem Algorithmus wird das obige Beispiel
in C zu:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
typedef CARDINAL tCard;
.sp 0.4v
static void q(i)
tCard *i;
{
    *i = 1;
}
.sp 0.4v
.br
.ne 3
static void r(i, j)
tCard *i, *j;
{
    *j = 1;
    q(i);
}
.sp 0.4v
.br
.ne 3
void p()
{
    tCard i, j;
.sp 0.4v
.br
.ne 2
    r(&i, &j);
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die zweite Alternative einer Funktion \fIQ\fP, den Zugriff auf lokal in \fIP\fP
vereinbarte Variablen zu erm\*oglichen ist, f\*ur jede dieser Variablen
eine globale Zei\%ger\%va\%ria\%ble zu vereinbaren. Am Anfang der Funktion \fIP\fP
werden die Adressen dieser lokalen Variablen an die globalen
Zeigervariablen zugewiesen. Damit dies auch funktioniert, wenn die Funktion \fIP\fP
rekursiv aufgerufen wird, werden die urspr\*unglichen Werte der globalen
Zeigervariablen am Anfang von \fIP\fP in lokalen Zeigervariablen gesichert
und am Ende von \fIP\fP wieder zur\*uckgeschrieben. Die Funktion \fIQ\fP kann jetzt
\*uber die globalen Zeigervariablen auf die lokalen Variablen von \fIP\fP
zugreifen. Damit wird das obige Beispiel
in C zu:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
typedef CARDINAL tCard;
.sp 0.4v
static tCard *G_1_i;
static tCard *G_2_j;
.sp 0.4v
.br
.ne 4
static void q()
{
    *G_1_i = 1;
}
.sp 0.4v
.br
.ne 3
static void r()
{
    *G_2_j = 1;
    q();
}
.sp 0.4v
.br
.ne 4
void p()
{
    tCard i, j;
    tCard *L_1, *L_2;
.sp 0.4v
.br
.ne 2
    L_1 = G_1_i; G_1_i = &i;
    L_2 = G_2_j; G_2_j = &j;
.sp 0.4v
    r();
.sp 0.4v
.br
.ne 3
    G_1_i = L_1;
    G_2_j = L_2;
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Eine m\*ogliche Optimierung w\*are, zu bestimmen, ob die Funktion \fIP\fP
rekursiv aufgerufen wird und nur in diesem Fall den Wert der globalen
Zeigervariablen lokal in \fIP\fP zu sichern.
.sp 0.4v
.ne 2v
.ti +2n
Beide oben vorgestellten Varianten funktionieren in \%Modula-2 auch im
Zusammenhang mit Prozedurvariablen, da in \%Modula-2 als Wert von
Prozedurvariablen nur global auf Ebene 0 vereinbarte Prozeduren zul\*assig
sind. Damit entf\*allt die z.B. in \%Pascal vorhandene Schwierigkeit,
beim Aufruf einer lokalen Prozedur die bei der Zuweisung an die
Prozedurvariable g\*ultige Umgebung zu bestimmen.
.sp 0.4v
.ne 2v
.ti +2n
Ein Vergleich der beiden oben vorgestellten Alternativen ergibt folgendes:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei der \*Ubersetzung nach C ist der Aufwand f\*ur die erste
Alternative, wegen der Notwendigkeit die Aufrufabh\*angigkeiten der
lokalen Prozeduren zu analysieren, erheblich
h\*oher als der Aufwand f\*ur die zweite Alternative.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Wird innerhalb einer Prozedur \fIP\fP eine lokale Prozedur \fIQ\fP mehrfach
aufgerufen, m\*ussen die Adressen der lokalen Variablen von \fIP\fP bei 
jedem Aufruf von \fIQ\fP als Parameter \*ubergeben werden. Au\*serdem haben die
Parameter manchmal nur die Funktion die Adressen der Va\%ria\%blen entlang des
Aufrufgraphen weiterzureichen. Im Gegensatz dazu
werden die Adressen der lokalen Variablen nur einmal an die globalen
Zeigervariablen zugewiesen, jedoch verursacht die lokale Sicherung der
Werte der globalen Zeigervariablen zus\*atzlichen Aufwand.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Speicheraufwand f\*ur beide Alternativen ist in der
Regel sehr gering.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da der Berechnungsaufwand f\*ur die erste Alternative bei der \*Ubersetzung
verh\*altnism\*a\*sig hoch ist und der Aufwand zur Laufzeit bei der zweiten
Alternative in den meisten F\*allen geringer ist,
wurde die zweite Alternative f\*ur den \*Ubersetzer ausgew\*ahlt.
.sp 0.4v
.ne 2v
.ti +2n
Ein besonderes Problem entsteht, wenn in der Deklaration einer lokalen
Variablen ein anonymer strukturierter Typ verwendet wird. \*Ubersetzt man
diese Variablendeklaration wie in Kapitel \n(h1.\n(h2.3
beschrieben nach C, dann ist der f\*ur den strukturierten Typ erzeugte
Strukturnamen nur lokal in der betreffenden Funktion sichtbar und kann
daher nicht in der Deklaration einer globalen Zeigervariablen verwendet werden.
Aus diesem Grund wird bei der \*Ubersetzung nach C f\*ur solche anonymen
strukturierten Typen zun\*achst eine globale Strukturdeklaration erzeugt,
die den Typ beschreibt. Der zu dieser Strukturdeklaration dazugeh\*orige
Strukturnamen kann dann in der Deklaration der globalen Zeigervariablen
benutzt werden. Damit wird folgender Ausschnitt eines Modula-Programms
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
PROCEDURE p;
.sp 0.4v
  VAR a : ARRAY [0..127] OF CHAR;
.sp 0.4v
.br
.ne 5
  PROCEDURE q;
  BEGIN
    (* Zugriff auf a *)
  END q;
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
struct S_9 {
    CHAR A [127 + 1];
};
  ...
struct S_9 *G_3_a;
.br
.ne 6
  ...
void p()
{
    struct S_9 a;
    struct S_9 *L_3;
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Formale Parameter\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Formale Parameter
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Bei der Abbildung der formalen Parameter m\*ussen drei F\*alle unterschieden
werden: offene Felder, Wertparameter und Referenzparameter.
Die offenen Felder m\*ussen bei der Abbildung getrennt
behandelt werden, da C kein vergleichbares Konzept kennt und daher,
insbesondere wenn das offene Feld als Wertparameter \*ubergeben wird,
in C eine Simulation
des gew\*unschten Effekts notwendig wird. Die Abbildung von ,,normalen''
Parametern macht hingegen wenig M\*uhe.
.hA 5 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4.\n(h5
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4.\n(h5'u
\&Wert- und Referenzparameter\fP
.hC 1v 0n 0v (4n+5n+7n+9n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4.\n(h5\ 
.hD 11n
\&Wert- und Referenzparameter
.hE (4n+5n+7n+9n) 11n 0v
.sp 0.4v
.ne 2v
.ti +2n
In C werden alle Parameter \(em mit Ausnahme der
Vektoren \(em als Wertparameter \*ubergeben. Daher
kann die Deklaration eines Wertparameters, mit der oben beschriebenen
Abbildung der Felder, direkt auf die entsprechende Parameterdeklaration
in C abgebildet werden.
Hierbei wird allerdings vorausgesetzt, da\*s der C-\*Ubersetzer
in der Lage ist auch beliebige Strukturen als Wertparameter zu \*ubergeben.
.sp 0.4v
.ne 2v
.ti +2n
Die semantische Bedeutung eines Referenzparameters in Modula-2 ist, da\*s dem
Unterprogramm die Adresse des aktuellen Parameters, der in diesem Fall
eine Variable sein mu\*s, \*ubergeben wird und das Unterprogramm dann
\*uber die Adresse direkt auf diese Variable zugreift. Da in C die
Adresse jeder Variablen mit dem Operator & bestimmt werden kann, erreicht
man in C den Effekt eines Referenzparameters, indem man den formalen Parameter
als Zeiger vereinbart und bei der Parameter\*ubergabe die Adresse der
Variablen an das Unterprogramm \*ubergibt. Innerhalb des
Unterprogramms wird dann \(em genau wie in Modula-2 \(em \*uber die
Adresse auf diese
Variable zugegriffen. Der einzige Unterschied ist, da\*s in C die
Operatoren zur Adre\*sbestimmung und zur Dereferenzierung explizit
aufgeschrieben werden m\*ussen. Semantisch besteht jedoch kein Unterschied.
.sp 0.4v
.ne 2v
.ti +2n
Der folgende Ausschnitt eines Modula-Programms, der die Verwendung von Wert-
und Referenzparametern zeigt,
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
VAR  GlobalRestartSet, LocalRestartSet : tTokenSet;
  ...
.br
.ne 3
PROCEDURE Union (VAR t1: tTokenSet; t2: tTokenSet);
BEGIN
  t1[0] := t1[0] + t2[0];
  t1[1] := t1[1] + t2[1];
END Union;
.br
.ne 2
   ...
Union (GlobalRestartSet, LocalRestartSet);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
tTokenSet GlobalRestartSet, LocalRestartSet;
  ...
.br
.ne 3
void Union(t1, t2)
tTokenSet *t1;
tTokenSet t2;
{
    t1->A[0] = t1->A[0] | t2.A[0];
    t1->A[1] = t1->A[1] | t2.A[1];
}
.br
.ne 2
  ...
Union(&GlobalRestartSet, LocalRestartSet);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 5 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4.\n(h5
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4.\n(h5'u
\&Offene Felder\fP
.hC 1v 0n 0v (4n+5n+7n+9n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4.\n(h5\ 
.hD 11n
\&Offene Felder
.hE (4n+5n+7n+9n) 11n 0v
.sp 0.4v
.ne 2v
.ti +2n
Offene Felder erfordern in C eine spezielle Behandlung,
die aber dadurch vereinfacht wird, da\*s in \%Modula-2 f\*ur sie
nur elementweiser Zugriff und die \*Ubergabe als aktueller Parameter an ein
Unterprogramm definiert ist, dessen formaler
Parameter ebenfalls ein offenes Feld ist.
.sp 0.4v
.ne 2v
.ti +2n
Die \*Ubergabe der offenen Felder wird in C dadurch realisiert, da\*s
als aktueller Parameter ein Zeiger auf den Feldanfang \*ubergeben wird.
Da diese Art der \*Ubergabe in C allgemein f\*ur die \*Ubergabe von Vektoren
benutzt wird, wird die Deklaration eines offenen Feldes in eine
Parameterdeklaration der Sprache C umgesetzt, die angibt, da\*s der Parameter
ein Vektor ist\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Zur Umgehung der damit verbundenen Einschr\*ankungen
werden die ,,normalen'' Felder auf Strukturen mit einem Vektor als Komponente
abgebildet (s. Kap. \n(h1.4.2.5).  F\*ur offene Felder sind diese
Einschr\*ankungen aber
unproblematisch, da f\*ur sie in \%Modula-2 \*ahnliche Einschr\*ankungen
gelten wie f\*ur die Vektoren in C.
.nE
\&.
Dabei spielt es bei der \*Ubergabe zun\*achst keine Rolle, ob das offene
Feld im Modula-Programm
als Wert- oder Referenzparameter vereinbart wurde (siehe unten).
.sp 0.4v
.ne 2v
.ti +2n
Ein zus\*atzlicher Parameter enth\*alt die aktuelle Anzahl von Feldelementen.
Dieser Parameter wird ben\*otigt, um innerhalb des Unterprogramms f\*ur
ein als Wertparameter vereinbartes offenes Feld einen lokalen Vektor
entsprechender Gr\*o\*se anlegen zu k\*onnen. Au\*serdem ist der
Parameter zur \*Ubersetzung
der Standardfunktionen \%HIGH und \%SIZE notwendig, mit denen die
obere Grenze bzw. die Gr\*o\*se des
offenen Feldes bestimmt werden kann.
.sp 0.4v
.ne 2v
.ti +2n
Erfolgt aus einer Prozedur \fIQ\fP, die lokal zu einer Prozedur \fIP\fP deklariert
ist, ein Zugriff auf ein offenes Feld \fIa\fP von \fIP\fP, dann mu\*s auch der
zus\*atzliche Parameter mit der aktuellen Anzahl von Elementen des Feldes \fIa\fP,
genau wie die Adresse von \fIa\fP (s. Kap. \n(h1.\n(h2.\n(h3), an eine globale Variable
zugewiesen werden, da auch in \fIQ\fP ein Aufruf
\%HIGH\^(\fIa\fP\|)
bzw.
\%SIZE\^(\fIa\fP\|)
m\*oglich ist und \fIQ\fP somit auch Zugriff auf den aktuellen Wert des
zus\*atzlichen Parameters von P haben mu\*s. 
.sp 0.4v
.ne 2v
.ti +2n
Beim Zugriff auf ein Element des
offenen Feldes, bei der Bestimmung seiner Adresse und seiner \*Ubergabe
als aktueller Parameter an eine Prozedur mu\*s entsprechend
ber\*ucksichtigt werden, da\*s die Abbildung der offenen Felder sich von der
Abbildung der ,,normalen'' Felder unterscheidet.
.sp 0.4v
.ne 2v
.ti +2n
Die Deklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
PROCEDURE Sort (VAR a : ARRAY OF CARDINAL);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C abgebildet auf
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
void Sort(a, O_1)
CARDINAL a[]; LONGCARD O_1;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Der erste Parameter \fIa\fP enth\*alt den Zeiger auf den Feldanfang, der zweite
Parameter \%\fIO_1\fP die aktuelle Anzahl von Feldelementen.
.sp 0.4v
.ne 2v
.ti +2n
Die Behandlung der \*Ubergabe eines offenen Feldes als Wertparameter
wird zun\*achst an einem Beispiel demonstriert:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
PROCEDURE WriteS (s : ARRAY OF CHAR);
VAR  i : CARDINAL;
BEGIN
  FOR i := 0 TO HIGH (s) DO WriteC (s[i]); END;
END WriteS;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
Diese Prozedur wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 5
void WriteS(s, O_2)
CHAR s[]; LONGCARD O_2;
{
    CARDINAL i;
    OPEN_ARRAY_LOCALS
.sp 0.4v
.br
.ne 4
    ALLOC_OPEN_ARRAYS(O_2 * sizeof(CHAR), 1)
    COPY_OPEN_ARRAY(s, O_2, CHAR)
    {
        CARDINAL B_1 = 0, B_2 = (O_2 - 1);
.sp 0.4v
.br
.ne 5
        if (B_1 <= B_2)
          for (i = B_1;; i += 1) {
              WriteC(s[i]);
              if (i >= B_2) break;
          }
.br
.ne 3
    }
    FREE_OPEN_ARRAYS
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Der zweite Parameter von \%\fIWriteS\fP
\%\fIO_2\fP enth\*alt wieder die aktuelle Anzahl von
Feldelementen. Der erste Parameter \fIs\fP enth\*alt beim Prozeduraufruf zun\*achst
die Anfangsadresse des \*ubergebenen Feldes.
\%OPEN_ARRAY_LOCALS,
\%ALLOC_OPEN_ARRAYS, \%COPY_OPEN_ARRAY und \%FREE_OPEN_ARRAYS
sind in \%SYSTEM_.h definierte Makros.
\%OPEN_ARRAY_LOCALS ist die Definition von lokalen Hilfsvariablen, die in
den \*ubrigen Makros ben\*otigt werden.
Die Aufgabe von
\%ALLOC_OPEN_ARRAYS ist, einen Speicherblock ausreichender Gr\*o\*se f\*ur das
als Wertparameter \*ubergebene Feld zu beschaffen.
\%COPY_OPEN_ARRAY bestimmt zun\*achst die Anfangsadresse eines
lokalen Vektors geeigneter Gr\*o\*se und Ausrichtung im von
\%ALLOC_OPEN_ARRAYS beschafften Speicherblock, kopiert das \*ubergebene
Feld in diesen lokalen Vektor und
weist schlie\*slich die Anfangsadresse des lokalen
Vektors an den Parameter \fIs\fP zu.
\%FREE_OPEN_ARRAYS gibt den Speicherplatz f\*ur den von
\%ALLOC_OPEN_ARRAYS beschafften Speicherblock wieder frei.
\%FREE_OPEN_ARRAYS mu\*s am Ende des Unterprogramms sowie vor
jeder RETURN-An\%wei\%sung
innerhalb des Unterprogramms stehen. Die genaue
Definition dieser Makros h\*angt von den auf der Zielmaschine verf\*ugbaren 
Bibliotheksfunktionen ab. Eine M\*oglichkeit w\*are folgende:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
#define SYSTEM_ALIGN            8
#define SYSTEM_MASK             (~(SYSTEM_ALIGN - 1))
.sp 0.4v
#define OPEN_ARRAY_LOCALS       char *BLOCK_POINTER, *FREE_POINTER;
.sp 0.4v
.br
.ne 5
#define ALLOC_OPEN_ARRAYS(size, arrays) \e
    BLOCK_POINTER = FREE_POINTER = \e
        malloc((unsigned)((size) + (arrays) * (SYSTEM_ALIGN - 1)));
.sp 0.4v
#define FREE_OPEN_ARRAYS        free(BLOCK_POINTER);
.sp 0.4v
.br
.ne 7
#define COPY_OPEN_ARRAY(array, elems, type) \e
{ \e
    int ARRAY_SIZE = elems * sizeof(type); \e
    \e
    array = (type *)memcpy(FREE_POINTER, (char *)array, ARRAY_SIZE); \e
    FREE_POINTER += (ARRAY_SIZE + (SYSTEM_ALIGN - 1)) & SYSTEM_MASK; \e
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Konstante \%SYSTEM_ALIGN ist maschinenabh\*angig und sorgt daf\*ur, da\*s
die Anfangsadressen der lokalen Vektoren korrekt ausgerichtet sind.
Die Bibliotheksfunktion \%\fImalloc\fP beschafft Speicherplatz auf der Halde,
\%\fIfree\fP gibt diesen Speicherplatz wieder frei. Die Bibliotheksfunktion
\%\fImemcpy\^(s1,\|s2,\|n)\fP kopiert \fIn\fP Zeichen von \fIs2\fP
nach \fIs1\fP und
liefert den Zeiger \fIs1\fP als Ergebnis.
.sp 0.4v
.ne 2v
.ti +2n
An einigen Maschinen stehen auch Bibliotheksfunktionen zur Verf\*ugung,
mit denen man den Speicherplatz erheblich effizienter in der Aufrufschachtel
des Unterprogramms beschaffen kann\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ An der \%SUN z.B. existiert eine
solche Bibliotheksfunktion mit dem Namen \%\fIalloca\fP.
.nE
\&.
Bei der R\*uckkehr wird dieser Speicherplatz dann automatisch freigegeben. Das
Makro \%FREE_OPEN_ARRAYS w\*are in diesem Fall leer.
.sp 0.4v
.ne 2v
.ti +2n
Da der zuletzt f\*ur die Speicherung von offenen Feldern beschaffte
Speicherblock
immer als erster wieder freigegeben wird,
k\*onnte man die Aufrufe von \%\fImalloc\fP und \%\fIfree\fP auch durch
Aufrufe von selbstprogrammierten Funktionen zur Speicherverwaltung ersetzen,
die den angeforderten
Speicher kellerartig verwalten und daher wahrscheinlich effizienter
programmiert werden k\*onnen als \%\fImalloc\fP und \%\fIfree\fP, die die
Anforderung und Freigabe von Speicherplatz in beliebiger Reihenfolge
unterst\*utzen.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Standardprozeduren und -funktionen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Standardprozeduren und -funktionen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Dieser Abschnitt enth\*alt die Definition der Standardprozeduren und -funktionen
in C. Alle diese Definitionen sind in \%SYSTEM_.h
bzw. \%SYSTEM_.c enthalten.
.sp 0.4v
.ne 2v
.ti +2n
Da \%ABS eine \*uberladene Funktion ist, existieren in C verschiedene
Definitionen von \%ABS.
Abh\*angig vom Typ und der Art des aktuellen Parameters, wird in
C ein Aufruf der entsprechenden Funktion bzw. des entsprechenden Makros
eingesetzt. Die verschiedenen Definitionen von \%ABS haben folgende Form:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
#define ABS(x)          ((x) < 0 ? -(x) : (x))
#define ABSSC(x)        ((SHORTCARD) (x))
#define ABSLC(x)        ((LONGCARD) (x))
#define ABSSI(x)        ((SHORTINT) ABSLI((LONGINT) (x)))
#define ABSR(x)         ((REAL) ABSLR(x))
.sp 0.4v
.br
.ne 2
extern LONGINT ABSLI();
extern LONGREAL ABSLR();
.sp 0.4v
.br
.ne 5
LONGINT ABSLI(x)
register LONGINT x;
{
    return (x < 0 ? -x : x);
}
.sp 0.4v
.br
.ne 5
LONGREAL ABSLR(x)
register LONGREAL x;
{
    return (x < 0 ? -x : x);
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Das Makro \%ABS, das nur benutzt wird, wenn der Parameter \fIx\fP
ein konstanter Ausdruck ist, kann nicht in allen F\*allen
verwendet werden, da \fIx\fP m\*oglicherweise ein Funktionsaufruf mit
Seiteneffekten ist und in diesem Fall die doppelte Auswertung von \fIx\fP
zu Fehlern f\*uhren w\*urde.
.sp 0.4v
.ne 2v
.ti +2n
Die Funktion \%CAP ist definiert als:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
extern CHAR CAP();
.sp 0.4v
.zA
CHAR CAP(ch)
register CHAR ch;
{
    return (ch >= 'a' && ch <= 'z' ? ch - 'a' + 'A' : ch);
}
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
CAP ist nicht als Makro definiert, um eine mehrfache Auswertung von \fIch\fP
zu verhindern.
.sp 0.4v
.ne 2v
.ti +2n
Die Funktionen f\*ur Typumwandlungen \%CHR, \%FLOAT, \%ORD,
\%TRUNC und \%VAL sind wie folgt definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define CHR(x)          ((CHAR) (x))
#define FLOAT(x)        ((REAL) (x))
#define ORD(x)          ((CARDINAL) (x))
.zE
.zA
#define TRUNC(x)        ((CARDINAL) (x))
#define VAL(T,x)        ((T) (x))
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Umwandlung von Gleitkommawerten in ganzzahlige Werte ist in C nicht exakt
definiert. In der Regel wird aber mit der obigen Definition von \%TRUNC der
gew\*unschte Effekt erzielt. Es ist jedoch nicht v\*ollig ausgeschlossen, da\*s
in manchen Implementierungen gerundet wird.
.sp 0.4v
.ne 2v
.ti +2n
Die Standardfunktion \%SIZE, zur Bestimmung der Anzahl der von einer Variablen oder
einem Typ ben\*otigten Speichereinheiten, wird normalerweise direkt
auf den C-Operator \%\fIsizeof\fP
abgebildet.
Ist der aktuelle Parameter von \%SIZE jedoch ein offenes Feld, dann ergibt
sich die von diesem Feld ben\*otigte Anzahl von Speichereinheiten aus:
\%\fIsizeof\^(Elementtyp)\fP * \fIaktueller Anzahl von Feldelementen\fP.
.sp 0.4v
.ne 2v
.ti +2n
Die Behandlung der Funktionen \%MAX und \%MIN h\*angt von der Art des an sie
als Argument \*ubergebenen Typs ab. F\*ur einen Aufz\*ahlungs- oder
einen Unterbereichstyp \fIT\fP ist der Wert von \%MIN\^(\fIT\fP\|) bzw.
\%MAX\^(\fIT\fP\|) aus der
Typdefinition bekannt und wird daher textuell in das erzeugte
C-Programm eingesetzt. F\*ur die vordefinierten Standardtypen,
auf die diese Funktionen anwendbar sind,
sind in \%SYSTEM_.h Definitionen von symbolischen Konstanten der Form
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define MIN_CARDINAL    ...
#define MAX_CARDINAL    ...
.zE
.zA
#define MIN_BOOLEAN     FALSE
#define MAX_BOOLEAN     TRUE
  ...
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
enthalten. Diese symbolischen Konstanten werden im C-Programm
f\*ur die Aufrufe von \%MIN bzw. \%MAX eingesetzt.
.sp 0.4v
.ne 2v
.ti +2n
Ist der aktuelle Parameter der Funktion \%HIGH kein offenes Feld, dann ist
der Wert von \%HIGH\^(\fIa\fP\|) bei der \*Ubersetzung bekannt und wird in das
C-Programm als Konstante eingesetzt. Ist der aktuelle Parameter jedoch ein
offenes Feld, dann wird \%HIGH\^(\fIa\fP\|) im C-Programm zum Ausdruck
\%(\fIO_nnn\fP\^\ -\ 1). Der Parameter \%\fIO_nnn\fP der Funktion,
die \fIa\fP als formalen Parameter hat, gibt \(em wie oben erw\*ahnt \(em die aktuelle
Anzahl der Feldelemente des offenen Feldes an.
.zA
.sp 0.4v
.ne 2v
.ti +2n
Die Standarfunktion \%ODD ist folgenderma\*sen definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define ODD(x)          ((BOOLEAN)((x) & 01))
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Die Standardprozeduren \%DEC, \%INC, \%EXCL und
\%INCL haben folgende Definition:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define DEC(x)          (x)--
#define DEC1(x,n)       x -= n
#define INC(x)          (x)++
#define INC1(x,n)       x += n
.zE
.zA
#define EXCL(s,i)       s &= ~(0X1L << (i))
#define INCL(s,i)       s |= 0X1L << (i)
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Ein Aufruf der Standardprozedur \%HALT wird in C zu einem Aufruf
der Bibliotheksfunktion \%\fIexit\fP. Da \%HALT in der Regel in
Fehlerf\*allen benutzt wird, wird \%\fIexit\fP, entsprechend der in C
\*ublichen Konvention, mit dem Argument 1 aufgerufen, um der Umgebung
den Fehler anzuzeigen.
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 definiert, da\*s Aufrufe
\%NEW\^(\^\fIp\fP\|) bzw. \%DISPOSE\^(\^\fIp\fP\|)
der Standardprozeduren \%NEW bzw. \%DISPOSE ersetzt werden durch
Aufrufe
\%ALLOCATE\^(\^\fIp\fP,\ TSIZE\^(\fIT\fP\|))
bzw.
\%DEALLOCATE\^(\^\fIp\fP,\ TSIZE\^(\fIT\fP\|)),
wobei \fIp\fP vom Typ
\%POINTER\ TO\ \fIT\fP
sein mu\*s und \%ALLOCATE bzw. \%DEALLOCATE vom Benutzer
definierte und an der Aufrufstelle
sichtbare Prozeduren mit folgender Definition sein m\*ussen:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
PROCEDURE ALLOCATE      (VAR a: ADDRESS; size: CARDINAL);
PROCEDURE DEALLOCATE    (VAR a: ADDRESS; size: CARDINAL);
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Daher wird folgendes Modula-Programmfragment
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
FROM Storage    IMPORT ALLOCATE, DEALLOCATE;
  ...
VAR p: POINTER TO INTEGER;
  ...
NEW (p); p^ := 1; DISPOSE (p);
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
  ...
INTEGER *p;
  ...
Storage_ALLOCATE(&p, sizeof(INTEGER));
*p = 1;
Storage_DEALLOCATE(&p, sizeof(INTEGER));
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Lokale Moduln\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Lokale Moduln
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
C kennt kein den lokalen Moduln entsprechendes Konzept. Daher mu\*s ein
Modula-Programm, das lokale Moduln enth\*alt derart transformiert werden, da\*s keine
lokalen Moduln mehr vorhanden sind. Dies wird mit folgender Transformation
erreicht:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle Objekte, die in einem lokalen Modul deklariert sind, werden zu
lokalen Objekten der Prozedur bzw. \*Ubersetzungseinheit, die das lokale
Modul in ihrem Deklarationsteil enth\*alt.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Rumpf des lokalen Moduls wird zu einer parameterlosen
Prozedur. Diese Prozedur wird am Anfang des Anweisungsteils der
Prozedur oder \*Ubersetzungseinheit aufgerufen, die den lokalen Modul
in ihrem Deklarationsteil enth\*alt. Sind
mehrere lokale Moduln vorhanden, dann erfolgen diese Aufrufe entsprechend
der Reihenfolge der lokalen Moduln im Quelltext. Dies entspricht der in
der Sprachdefinition
von \%Modula-2 geforderten Reihenfolge.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Da lokale Moduln mit Hilfe von Import- bzw. Exportanweisungen
eine explizite Kontrolle der Sichtbarkeit von Bezeichnern erlauben,
k\*onnen bei dieser Transformation m\*oglicherweise Namenskonflikte
entstehen. Diese werden in C durch eine Umbenennung von Bezeichnern gel\*ost.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Diese Transformation mu\*s durchgef\*uhrt werden,
bevor die Reihenfolge der Deklarationen umgeordnet wird und
bevor geschachtelte Prozedurdeklarationen transformiert werden.
.sp 0.4v
.ne 2v
.ti +2n
Die \*Ubersetzung des Moduls \fIGlobal\fP nach C soll die oben beschriebene
Transformation nochmals verdeutlichen:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
MODULE Global;
.sp 0.4v
VAR  a : INTEGER;
.sp 0.4v
.br
.ne 4
MODULE Local;
EXPORT QUALIFIED a;
VAR
  a : INTEGER;
.br
.ne 3
BEGIN
  a := 1;
END Local;
.sp 0.4v
.br
.ne 3
BEGIN
  a := Local.a;
END Global.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
In C wird \fIGlobal\fP zu:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
#include "SYSTEM_.h"
.sp 0.4v
static INTEGER a;
static INTEGER C_1_a;
.sp 0.4v
.br
.ne 4
static void Local()
{
    C_1_a = 1;
}
.sp 0.4v
.br
.ne 3
void Global()
{
    Local();
.sp 0.4v
    a = C_1_a;
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Ausdr\*ucke\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Ausdr\*ucke
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Bei der \*Ubersetzung von Ausdr\*ucken mu\*s darauf geachtet werden, da\*s die
Auswertungsreihenfolge im erzeugten C-Programm der Auswertungsreihenfolge im
Modula-Programm entspricht. Dabei ist insbesondere von Bedeutung, da\*s
sich der Vorrang der Operatoren in \%Modula-2 und C teilweise deutlich unterscheidet.
Eine korrekte Auswertungsreihenfolge mu\*s daher bei Bedarf durch das Setzen
von Klammern erzwungen werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Operanden\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Operanden
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung von Zeichenketten und Zahlen wurde bereits in Kapitel \n(h1.2 
besprochen.
.sp 0.4v
.ne 2v
.ti +2n
Mengen werden in einen C-Ausdruck umgesetzt,
der die gew\*unschte Menge liefert\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ So definierte Mengenkonstanten und
konstante Elemente werden vom C-\*Ubersetzer bereits bei der \*Ubersetzung
ausgewertet.
.nE
\&. Die folgende Menge
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
{1..2, i..j, j + 2}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
SET_cRNG(1, 2) | SET_RANGE(i, j) | SET_ELEM(j + 2)
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
\%SET_ELEM, \%SET_cRNG und \%SET_RANGE sind in \%SYSTEM_.h
bzw. \%SYSTEM_.c folgenderma\*sen definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define SYSTEM_MaxSet   (sizeof(unsigned long) * 8 - 1)
.sp 0.4v
#define SET_ELEM(el)    (0X1L << (el))
#define SET_cRNG(lo,hi) \e
    ((lo) <= (hi) ? ~0XL >> (lo) << (lo) + SYSTEM_MaxSet - (hi) \e
     >> SYSTEM_MaxSet - (hi) : 0XL)
.zE
.zA
#define SET_RANGE(lo, hi) \e
    SET_RANGE1((CARDINAL)(lo), (CARDINAL)(hi))
.sp 0.4v
extern unsigned long SET_RANGE1();
.zE
.sp 0.4v
.zA
unsigned long SET_RANGE1(lo, hi)
register CARDINAL lo, hi;
{
    return (lo <= hi ? ~0XL >> lo << lo + SYSTEM_MaxSet - hi
            >> SYSTEM_MaxSet - hi : 0XL);
}
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Die Funktion \%SET_RANGE1 wird f\*ur nicht konstante Elemente verwendet,
um eine mehrfache Auswertung von \fIlo\fP und \fIhi\fP zu verhindern.
.sp 0.4v
.ne 2v
.ti +2n
Alle von globalen Moduln exportierten Bezeichner werden im C-Programm in der
qualifizierten Form \fIModulname_Bezeichner\fP geschrieben.
Nicht von globalen Moduln exportierte
Bezeichner werden unver\*andert nach C \*ubernommen, sind aber bei Bedarf
zur L\*osung eines Namenskonfliktes mit einem Pr\*afix versehen.
.sp 0.4v
.ne 2v
.ti +2n
Die Selektion einer Verbundkomponente
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
R.f
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
R.f
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wenn die Komponente nicht in einem varianten Teil des Verbundes enthalten
ist. Ist die Komponente in einem varianten Teil enthalten, so erfolgt die
Selektion entsprechend der oben vorgestellten Abbildung von varianten Verbunden mit:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
R.U_xxx.V_nnn.f
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Der Zugriff auf ein Feldelement
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
A[E]
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird entsprechend der oben beschriebenen Abbildung von Feldern in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
A.A[E - Lwb]
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wenn \fIA\fP kein offenes Feld ist.
Da in C alle Vektoren die untere Grenze 0 besitzen, mu\*s beim
Zugriff auf ein Feldelement die in \%Modula-2 angegebene untere
Grenze \fILwb\fP des Feldes abgezogen werden, sofern diese ungleich 0 ist.
Ist \fIA\fP ein offenes Feld, so erfolgt der Zugriff entsprechend der
oben vorgestellten Abbildung von offenen Feldern auf Vektoren mit:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
A[E]
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Dereferenzierung von Zeigervariablen
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
P^
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
*P
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Eine Dereferenzierung ist, wegen der oben beschriebenen Abbildung
von Referenzparametern auf Zeiger, auch notwendig, wenn \fIP\fP ein
Referenzparameter ist.
.sp 0.4v
.ne 2v
.ti +2n
Der Funktionsaufruf
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
F()
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
F()
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wenn \fIF\fP keine Prozedurvariable ist. Ist \fIF\fP eine Prozedurvariable, so
ist, da Prozedurtypen in C als Zeiger auf Funktionen repr\*asentiert
werden, eine zus\*atzliche Dereferenzierung notwendig:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
(*F)()
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Die Klammerung von \%*\fIF\fP ist notwendig, weil in C der Vorrang von
() gr\*o\*ser ist als der Vorrang von *.
.sp 0.4v
.ne 2v
.ti +2n
Eine Dereferenzierung gefolgt von der Selektion einer Verbundkomponente
wird auf den in C speziell f\*ur diese Operationsfolge
vorgesehenen Operator \%\-> abgebildet.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Operatoren\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Operatoren
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die arithmetischen Operatoren werden entsprechend der folgenden
Tabelle nach C abgebildet:
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
ce| ce
cefTT| cefTT.
Modula-2|C
_
+|+
-|-
*|*
/|/
DIV|/
MOD|%
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.2\fP: Abbildung der arithmetischen Operatoren
.ce 0
.zE
.sp 0.4v
.sp 0.4v
.ne 2v
.ti +2n
Im Gegensatz zu \%Modula-2 ist allerdings in der C-Sprachbeschreibung
nicht eindeutig definiert, welches Ergebnis die Operatoren / und %
liefern, falls einer der Operanden eine negative Zahl ist. Bei
der Abbildung werden aber solche m\*oglichen Unterschiede in der
Arithmetik nicht ber\*ucksichtigt.
.sp 0.4v
.ne 2v
.ti +2n
Da sowohl \%Modula-2 als auch C die Kurzauswertung logischer Ausdr\*ucke
verlangen, k\*onnen die logischen Operatoren \%NOT, \%AND und \%OR
direkt auf die C-Operatoren \%!, \%&& und \%|| abgebildet werden.
.sp 0.4v
.ne 2v
.ti +2n
Mit der vereinfachenden Annahme, da\*s alle Mengen nur Wortgr\*o\*se
(\%\fIunsigned\fP \%\fIlong\fP) haben, k\*onnen die Mengenoperatoren
in C leicht mit Hilfe der Operatoren zur Bitmanipulation
realisiert werden. Die folgende Tabelle zeigt die
\*Ubersetzung der Mengenoperatoren:
.sp 1.5
.zA
.TS
delim($$)tab(;) center box;
ce| ce
cefTT| cefTT.
Modula-2;C
_
+;|
-;SET_DIFF
*;&
/;^
\&=;==
#;!=
<=;SET_IS_SUBSET1
>=;SET_IS_SUBSET2
IN;IN
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.3\fP: Abbildung der Mengenoperatoren
.ce 0
.zE
.sp 1.5
Die Makros \%SET_DIFF, \%IN,
\%SET_IS_SUBSET1 und \%SET_IS_SUBSET2 sind in \%SYSTEM_.h
wie folgt definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define SET_DIFF(s1,s2)         ((s1) & ~(s2))
#define IN(x,s)                 ((BOOLEAN)((s) >> (x) & 0X1L))
.zE
.zA
#define SET_IS_SUBSET1(s1,s2)   ((BOOLEAN)!((s1) & ~(s2)))
#define SET_IS_SUBSET2(s1,s2)   ((BOOLEAN)!((s2) & ~(s1)))
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Aufgrund der oben angegebenen Abbildung der Modula-Typen nach C, k\*onnen
die relationalen Operatoren von \%Modula-2 immer direkt auf die
relationalen Operatoren von C abgebildet werden.
.sp 0.4v
.ne 2v
.ti +2n
Die folgenden Ausdr\*ucke (s. Beispiele Kap. \n(h1.4.3)
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
i DIV 3
NOT p OR q
(i + j) * (i - j)
s - {8, 9, 13}
(1 <= i) AND (i < 100)
.br
.ne 3
t^.Key = 0
{13..15} <= s
i IN {0, 5..8, 15}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
werden in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
i / 3
!p || q
(i + j) * (i - j)
SET_DIFF(s, SET_ELEM(8) | SET_ELEM(9) | SET_ELEM(13))
1 <= i && i < 100
.br
.ne 3
t->Key == 0
SET_IS_SUBSET1(SET_cRNG(13, 15), s)
IN(i, SET_ELEM(0) | SET_cRNG (5, 8) | SET_ELEM(15))
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.br
.ne 4
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Anweisungen\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Anweisungen
.hE 4n 5n 0v
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Zuweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Zuweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Aufgrund der Abbildung der Typen nach C kann \(em mit
einer Ausnahme \(em die Zuweisung direkt auf den C-Zuweisungsoperator
= abgebildet werden. Die einzige Ausnahme ist die Zuweisung von
Zeichenketten, die mit der Bibliotheksfunktion \fIstrncpy\fP durchgef\*uhrt
wird. Die Funktion \%\fIstrncpy\^(s,\|t,\|n)\fP kopiert eine
Zeichenkette, die \(em wie in C \*ublich \(em durch ein NUL-Zeichen beendet
wird von \fIt\fP nach \fIs\fP.
Es werden jedoch maximal die als drittes Argument \fIn\fP \*ubergebene
Anzahl von Zeichen kopiert. Damit kann gerade die in \%Modula-2
f\*ur die Zuweisung von Zeichenketten geltende Regel ,,Zeichenketten
der L\*ange \fIn1\fP k\*onnen auch an Felder von Zeichen der L\*ange
\%\fIn2\ >\ n1\fP
zugewiesen werden. Der Wert der Zeichenkette wird in diesem Fall
um ein NUL-Zeichen verl\*angert.'' implementiert werden. Die
folgenden Zuweisungen (s. Beispiele Kap. \n(h1.4.3)
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
w := v;
F := log2;
s := {2, 3, 5..7, 11};
.br
.ne 3
t^.Key := j;
w[i+1].ch := "a";
S := "hello world";
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
werden somit in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
w = v;
F = log2;
s = SET_ELEM(2) | SET_ELEM(3) | SET_cRNG(5, 7) | SET_ELEM(11);
.br
.ne 3
t->Key = j;
w.A[i+1].ch = 'a';
(void)strncpy(S.A, "hello world", sizeof(S.A));
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Es sei an dieser Stelle noch einmal ausdr\*ucklich darauf hingewiesen, da\*s
auch das Feld \fIv\fP, wegen der Abbildung von Feldern auf Strukturen mit
einem Vektor als Komponente, an das Feld \fIw\fP als Ganzes zugewiesen werden kann.
Wie bereits erw\*ahnt, wird dabei allerdings vorausgesetzt, da\*s
der C-\*Ubersetzer Strukturen als Ganzes zuweisen kann.
.sp 0.4v
.ne 2v
.ti +2n
Der Name einer Funktion wird in C, wenn er nicht zum Aufruf der Funktion
verwendet wird, als Zeiger auf die Funktion verstanden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Prozeduraufruf\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Prozeduraufruf
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Aufruf einer Prozedur wird in einen Aufruf der
entsprechenden C-Funktion \*ubersetzt. Handelt es sich beim Bezeichner
der Prozedur um eine Prozedurvariable, dann ist, wegen der Abbildung
der Prozedurtypen auf Zeiger auf Funktionen, eine Dereferenzierung
beim Aufruf notwendig.
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung der aktuellen Parameter ist abh\*angig von der Art
der formalen Parameter:
.sp 0.4v
.ne 2v
.ti +2n
Ist der formale Parameter ein Wertparameter (kein offenes Feld), dann
wird der aktuelle Parameter in den entsprechenden C-Ausdruck
\*ubersetzt. Die \*Ubergabe von Zeichenketten
macht dabei aber aus zwei Gr\*unden Schwierigkeiten:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Zeichenketten werden in C auf Zeichenketten
oder einen initialisierten Vektor von Zeichen
abgebildet. Felder von Zeichen werden auf eine Struktur mit
einem Vektor von Zeichen als Komponente abgebildet.
Zeichenketten bzw. Vektoren werden in C aber im Gegensatz zu Strukturen nicht
als Ganzes an eine Funktion \*ubergeben, sondern es wird nur ein Zeiger auf den
Anfang der Zeichenkette bzw. des Vektors \*ubergeben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei der Parameter\*ubergabe gelten die gleichen Regeln wie bei
der Zuweisung. Das bedeutet, da\*s die L\*ange der Zeichenkette kleiner
sein darf, als die L\*ange des als formaler Parameter angegebenen
Feldes.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Diese beiden Probleme k\*onnen gel\*ost werden, indem die Zeichenkette
vor dem Aufruf der Funktion an eine tempor\*are
Feldvariable zugewiesen und dann diese Feldvariable als aktueller
Parameter \*ubergeben wird.
Die L\*osung ist allerdings wegen der zus\*atzlichen Zuweisung nicht
besonders effizient.
Der Aufruf der Prozedur \fIWriteString\fP aus dem
folgenden Ausschnitt eines Modula-Programms
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
PROCEDURE WriteString (s : tString);
  ...
WriteString ("hello world");
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
wird in C dann zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
tString X_1;
  ...
(void)strncpy(X_1.A, "hello world", sizeof(X_1.A));
  ...
WriteString(X_1);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Ist der formale Parameter ein Referenzparameter (kein offenes Feld), dann mu\*s
der aktuelle Parameter eine Variable sein. Da Referenzparameter in C auf
Zeiger abgebildet werden, mu\*s die Adresse dieser Variablen in C bei
der Parameter\*ubergabe mit dem Operator & bestimmt und \*ubergeben werden.
.sp 0.4v
.ne 2v
.ti +2n
Ist der formale Parameter ein offenes Feld, dann mu\*s in C
die Adresse des aktuellen Parameters \*ubergeben
werden. Dies gilt auch dann, wenn das als formaler
Parameter angegebene offene Feld ein Wertparameter ist
(vgl. Kap. \n(h1.4.4.1.2).
Dabei m\*ussen, entsprechend der Art des aktuellen Parameters,
folgende F\*alle unterschieden werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Wenn der aktuelle Parameter eine Zeichenkette ist, dann
wird in C automatisch ein Zeiger auf das erste Zeichen dieser
Zeichenkette \*ubergeben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ist der aktuelle Parameter ein offenes Feld, dann wird in C wegen
der Abbildung der offenen Felder auf Vektoren automatisch ein Zeiger auf
den Feldanfang \*ubergeben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Falls der aktuelle Parameter in C weder eine Zeichenkette
noch ein Vektor ist, dann mu\*s die Adresse
des aktuellen Parameters wie \*ublich mit dem Operator & bestimmt
werden.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Zus\*atzlich zur Adresse des Feldes mu\*s in C ein
Parameter mit der Anzahl von Feldelementen \*ubergeben werden. Falls der
aktuelle Parameter ebenfalls ein offenes Feld ist, wird der zu diesem
Feld dazugeh\*orige Parameter mit der Anzahl von Feldelementen
\*ubergeben. Sonst ist die Anzahl von Feldelementen bei der \*Ubersetzung
bekannt und wird als Konstante in das C-Programm eingesetzt.
.sp 0.4v
.ne 2v
.ti +2n
\%MOCKA erlaubt \(em im Gegensatz zur
Sprachbeschreibung von \%Modula-2 \(em auch Zeichenketten als aktuelle
Parameter, wenn das offene Feld ein Referenzparameter ist. Mit der oben
beschriebenen Abbildung wird auch dieser Fall abgedeckt.
.sp 0.4v
.ne 2v
.ti +2n
Die \*Ubersetzung des folgenden Ausschnitts eines Modula-Programms
demonstriert die \*Ubergabe von offenen Feldern
als Parameter noch einmal (s. Beispiele Kap. \n(h1.4.3):
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
PROCEDURE p (VAR s1: ARRAY OF CHAR; s2: ARRAY OF CHAR);
BEGIN
  q (s1, s2);
END p;
.zE
.zA
  ...
p (S, "hello world");
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Dieser Ausschnitt wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
void p(s1, O_3, s2, O_4)
CHAR s1[]; LONGCARD O_3;
CHAR s2[]; LONGCARD O_4;
{
    OPEN_ARRAY_LOCALS
.sp 0.4v
    ALLOC_OPEN_ARRAYS(O_4 * sizeof(CHAR), 1);
    COPY_OPEN_ARRAY(s2, O_4, CHAR);
.sp 0.4v
    q(s1, O_3, s2, O_4);
.sp 0.4v
    FREE_OPEN_ARRAYS
}
.br
.ne 2
  ...
p(S.A, 256L, "hello world", 11L);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&IF-Anweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&IF-Anweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die \fIif\fP\^-Anweisung
in C entspricht genau der IF-Anweisung in \%Modula-2,
wenn man bedenkt, da\*s der ELSIF-Teil von \%Modula-2 nur eine
abk\*urzende Schreibweise f\*ur Ketten von Bedingungen ist.
Damit wird
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
IF (ch >= "A") AND (ch <= "Z") THEN
  ReadIdentifier;
ELSIF (ch >= "0") AND (ch <= "9") THEN
  ReadNumber;
ELSE
  SpecialCharacter;
END
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
if (ch >= 'A' && ch <= 'Z') {
    ReadIdentifier();
} else if (ch >= '0' && ch <= '9') {
    ReadNumber();
.br
.ne 2
} else {
    SpecialCharacter();
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&CASE-Anweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&CASE-Anweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die CASE-Anweisung wird in eine \fIswitch\fP\^-Anweisung
\*ubersetzt. Alle in \%Modula-2 f\*ur die Fallmarken zul\*assigen Typen
sind, mit der oben beschriebenen Abbildung der Typen nach C, auch in
C f\*ur den \fIswitch\fP\^-Ausdruck und
die Fallmarken zul\*assig. Die Listen mit Fallmarken
und Bereichsangaben
werden in eine Folge von C-Fallmarken der Form
\%\fIcase\ constant\ :\fP umgesetzt. Konstante Ausdr\*ucke, die in
\%Modula-2 als Fallmarken zul\*assig sind, m\*ussen dabei bereits
w\*ahrend der \*Ubersetzung nach C ausgewertet werden, wenn der entsprechende
C-Ausdruck kein konstanter Ausdruck ist.
Die \fIdefault\fP\^-Marke der \fIswitch\fP\^-Anweisung entspricht
dem ELSE-Teil der
CASE-Anweisung.
.sp 0.4v
.ne 2v
.ti +2n
Die Anweisung
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
CASE ch OF
| "A".."Z" : ReadIdentifier;
| "0".."9" : ReadNumber;
ELSE
  SpecialCharacter;
END
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
switch (ch) {
case 'A' :
case 'B' :
  ...
.br
.ne 3
case 'Z' :
    ReadIdentifier();
    break;
.sp 0.4v
.br
.ne 2
case '0' :
  ...
.br
.ne 3
case '9' :
    ReadNumber();
    break;
.sp 0.4v
.br
.ne 3
default :
    SpecialCharacter();
    break;
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
In C mu\*s nach jeder Anweisungsfolge, die zu einer Folge von Fallmarken
geh\*ort, eine \fIbreak\fP\^-\%An\%wei\%sung stehen, damit die
\fIswitch\fP\^-Anweisung verlassen wird.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Schleifen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Schleifen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die \%WHILE-, \%REPEAT- und LOOP-Schleife werden folgenderma\*sen
nach C \*ubersetzt:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
while (...) {          do {                      for (;;) {
  ...                    ...                       ...
}                      } while (!(...))          } EXIT_xxx:;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Die Marke \fIEXIT_xxx\fP dient als Sprungziel f\*ur die \fIgoto\fP\^-Anweisungen, in
welche die EXIT-Anweisungen innerhalb der LOOP-Schleife \*ubersetzt werden.
.sp 0.4v
.ne 2v
.ti +2n
Eine direkte \*Ubersetzung der FOR-Schleife
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
FOR v := a TO b BY c DO ... END;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in die \fIfor\fP\^-Schleife der Sprache C
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
for (v = a; v <= b; v += c) { ... };    /* falls c >= 0 */
for (v = a; v >= b; v += c) { ... };    /* falls c <  0 */
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
ist wegen der unterschiedlichen Semantik der beiden Schleifenkonstrukte
in den meisten F\*allen nicht m\*oglich. \%Modula-2 verlangt, da\*s
Anfangs- und Endwert der Schleife genau einmal vor dem ersten
Schleifendurchlauf ausgewertet werden. Die Schrittweite \fIc\fP mu\*s ein
konstanter Ausdruck sein. In C wird der zweite Ausdruck der \fIfor\fP\^-Schleife
vor jedem Schleifendurchlauf ausgewertet. Ist au\*serdem der Typ \fIT\fP
der
Schleifenkontrollvariablen \fIv\fP ein arithmetischer Typ und gilt f\*ur den
Endwert der
Schleife \fIb\fP, da\*s
\%\fIb\fP\ \(>=\ MAX\^(\fIT\fP\|)\ -\ \fIc\fP\ +\ 1
(falls \%\fIc\fP\ >\ 0)
bzw.
\%\fIb\fP\ \(<=\ MIN\^(\fIT\fP\|)\ -\ \fIc\fP\ -\ 1
(falls \%\fIc\fP\ <\ 0), dann
terminiert die Schleife in C nicht, da die Schleifenkontrollvariable am
Schleifenende vor der erneuten Auswertung der Abbruchbedingung inkrementiert
wird und ein unbemerkter \*Uber- bzw. Unterlauf stattfindet.
.sp 0.4v
.ne 2v
.ti +2n
Daher wird die obige FOR-Schleife bei positiver Schrittweite \fIc\fP in
die folgende zusammengesetzte C-Anweisung \*ubersetzt:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
{
    T B_xxx = a, B_nnn = b;
.sp 0.4v
.br
.ne 6
    if (B_xxx <= B_nnn)
      for (v = B_xxx, B_nnn = FOR_LIMIT_UP(B_nnn, c, MIN(T));; v += c) {
          ...
          if (v >= B_nnn) break;
      }
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Bei negativer Schrittweite \fIc\fP wird die FOR-Schleife in C zu:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
{
    T B_xxx = a, B_nnn = b;
.sp 0.4v
.br
.ne 6
    if (B_xxx >= B_nnn)
      for (v = B_xxx, B_nnn = FOR_LIMIT_DOWN(B_nnn, c, MAX(T));; v += c) {
          ...
          if (v <= B_nnn) break;
      }
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Diese \*Ubersetzung der FOR-Schleife vermeidet die oben angesprochenen
Schwierigkeiten, da Anfangs- und Endwert der Schleife nur einmal ausgewertet
werden und die Abbruchbedingung am Schleifenende gepr\*uft wird, bevor die
Schleifenkontrollvariable inkrementiert wird.
Durch den Aufruf der in \%SYSTEM_.h definierten Makros
\%FOR_LIMIT_UP und \%FOR_LIMIT_DOWN wird der Schleifenendwert vor der
ersten Ausf\*uhrung des Schleifenrumpfes geeignet korrigiert, um einen
\*Uber- bzw. Unterlauf der Schleifenkontrollvariablen zu verhindern. Die
beiden Makros haben folgende Definition:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define FOR_LIMIT_UP(last, step, min) \e
    ((last) < (min) + ((step) - 1) ? (min) : (last) - ((step) - 1))
.sp 0.4v
#define FOR_LIMIT_DOWN(last, step, max) \e
    ((last) > (max) + ((step) + 1) ? (max) : (last) - ((step) + 1))
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Ist der Wert der Schrittweite \%\fIc\fP\ \(mo\ {-1,\ 0,\ 1}, dann ist die
Korrektur des Schleifenendwertes \*uberfl\*ussig und wird weggelassen.
.sp 0.4v
.ne 2v
.ti +2n
Wegen der damit verbundenen besseren Lesbarkeit der C-Programme, wird
die FOR-Schleife in die ,,normale'' \fIfor\fP\^-Schleife der Sprache C \*ubersetzt,
wenn der Endwert der Schleife eine Konstante ist und ein \*Uber- bzw.
Unterlauf der Schleifenkontrollvariablen nicht auftreten kann.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&WITH-Anweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&WITH-Anweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die WITH-Anweisung
hat kein direktes Gegenst\*uck in C. Sie wird in eine
zusammengesetzte Anweisung \*ubersetzt, die am Anfang die Deklaration
und Initialisierung einer Zeigervariablen enth\*alt. Diese Zeigervariable
wird mit der Adresse der Struktur initialisiert, die dem in
der WITH-Anweisung
angesprochenen Verbund des Modula-Programms entspricht.
Innerhalb der WITH-Anweisung
wird in C dann \*uber diese Zeigervariable
auf die Strukturkomponenten zugegriffen.
Diese \*Ubersetzung erf\*ullt die Forderung der Sprachdefinition von
\%Modula-2, da\*s der Selektor, welcher den in der
WITH-Anweisung
angesprochenen Verbund festlegt, nur einmal ausgewertet wird.
Damit wird die folgende Anweisung
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
WITH t^ DO
  Key := 0; Left := NIL; Right := NIL;
END
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
{
    register tNode *W_1 = t;
.sp 0.4v
    W_1->Key = 0; W_1->Left = NIL; W_1->Right = NIL;
}
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&RETURN-Anweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&RETURN-Anweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die \fIreturn\fP\^-Anweisung
in C entspricht genau der RETURN-An\%wei\%sung in
\%Modula-2, wobei allerdings die \(em aus der Sprachdefinition von
\%Modula-2 nicht eindeutig hervorgehende \(em Einschr\*ankung gemacht
wird, da\*s der Ergebnistyp einer Funktion kein Feld- oder Verbundtyp
sein darf\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ \%MOCKA macht diese Einschr\*ankung auch.
.nE
\&.
.sp 0.4v
.ne 2v
.ti +2n
Wie oben erw\*ahnt m\*ussen vor jeder RETURN-An\%wei\%sung die vor
dem Aufruf der betreffenden Prozedur bzw. Funktion \fIP\fP g\*ultigen Werte
der globalen Zeigervariablen, die zur \*Ubersetzung des Zugriffs auf lokale
Variablen von \fIP\fP ben\*otigt werden, wiederhergestellt werden.
Au\*serdem mu\*s der Speicherplatz wieder freigegeben werden, der
f\*ur die als Wertparameter \*ubergebenen offenen Felder angefordert wurde.
Enth\*alt bei einer Funktion der RETURN-Ausdruck aber einen
Zugriff auf ein offenes Feld oder den Aufruf einer (lokalen) Funktion, dann
d\*urfte das Zur\*uckschreiben der alten Werte der globalen Zeigervariablen und
die Freigabe des Speichers eigentlich erst nach der RETURN-Anweisung erfolgen,
was nicht m\*oglich ist. In diesem Fall wird daher die RETURN-Anweisung zu einer
zusammengesetzten Anweisung, die am Anfang die Deklaration einer lokalen
Variablen enth\*alt, welche mit dem RETURN-Ausdruck initialisiert wird. Danach erst
werden die alten Werte der globalen Zeigervariablen zur\*uckgeschrieben, der
Speicher f\*ur offene Felder freigegeben und der Wert des RETURN-Ausdrucks an
die aufrufende Prozedur zur\*uckgeliefert. Damit wird der folgende Ausschnitt
eines Modula-Prgramms
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
PROCEDURE p (a : ARRAY OF CHAR): CHAR;
BEGIN
  ...
  RETURN a[0];
END p;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
CHAR p(a, O_5)
CHAR a[]; LONGCARD O_5;
{
    ...
.br
.ne 3
    {
        CHAR R_1 = a[0];
.sp 0.4v
.br
.ne 4
        FREE_OPEN_ARRAYS
        RETURN R_1;
    }
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Laufzeitpr\*ufungen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Laufzeitpr\*ufungen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Durch die Angabe einer Option bei der \*Ubersetzung kann man \%\fIMtc\fP dazu
veranlassen, Laufzeitpr\*ufungen zu erzeugen, die die Abgabe einer
entsprechenden Fehlermeldung mit Angabe der Position im C-Quellprogramm und
den Abbruch des C-Programms zur Folge haben, falls
in einer CASE-Anweisung durch den Selektorausdruck keine Fallmarke ausgew\*ahlt
wird und der ELSE-Teil fehlt oder falls eine Funktion kein Ergebnis liefert.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Modul SYSTEM\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Modul SYSTEM
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
C ist eine relativ ,,maschinennahe'' Sprache. Daher steht ein gro\*ser
Teil der in Modula-2 vom Modul \%SYSTEM zur Verf\*ugung gestellten
Hilfsmittel f\*ur die maschinennahe Programmierung auch in C zur
Verf\*ugung.
.sp 0.4v
.ne 2v
.ti +2n
Da C allerdings keine Koroutinen kennt, m\*u\*ste man diese
in C auf geeignete Weise simulieren. Da aber eine Simulation sowohl
aufwendig als auch ineffizient w\*are und au\*serdem die Verwendung
von Koroutinen, wenn es sich nicht um spezielle Systemprogramme
handelt, relativ selten ist, unterst\*utzt der \*Ubersetzer die
Abbildung von \%NEWPROCESS, \%TRANSFER und \%IOTRANSFER nicht.
.sp 0.4v
.ne 2v
.ti +2n
Die vom \*Ubersetzer unterst\*utzten Objekte aus dem Modul \%SYSTEM
sind: die Typen \%WORD und \%ADDRESS, die Funktionen \%ADR
und \%TSIZE
sowie die Funktionen f\*ur den Typtransfer. Au\*serdem wird noch die
von \%MOCKA implementierte Spracherweiterung
um den Typ \%BYTE, der synonym zum Typ \%WORD ist, ber\*ucksichtigt.
.sp 0.4v
.ne 2v
.ti +2n
Eine Typtransferfunktion wird in C als eine explizite Umwandlung
in den angegebenen Typ realisiert, die dadurch ausgedr\*uckt wird, da\*s
dem betreffenden Wert der Name des gew\*unschten Datentyps in Klammern
vorangestellt wird.
.sp 0.4v
.ne 2v
.ti +2n
Die Typen \%BYTE und \%WORD sind in \%SYSTEM_.h folgenderma\*sen
definiert:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef unsigned char WORD;
typedef WORD          BYTE;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Damit die \*Ubergabe eines aktuellen Parameters an eine Prozedur, in
welcher der entsprechende formale Parameter den Typ \%WORD bzw. \%BYTE
hat, auch in C korrekt funktioniert, m\*ussen alle Typen, die bei der
Typabbildung von \%MOCKA die gleiche Gr\*o\*se wie \%WORD bzw.
\%BYTE zugewiesen bekommen, auch in C die gleiche Gr\*o\*se haben.
.sp 0.4v
.ne 2v
.ti +2n
Ist der formale Parameter einer Prozedur vom Typ \%ARRAY\ OF\ WORD
bzw. \%ARRAY\ OF\ BYTE, dann hat die entsprechende C-Funktion
\(em wie bei allen offenen Feldern \(em einen zus\*atzlichen Parameter,
der die aktuelle Anzahl von Feldelementen enth\*alt.
Bei der Parameter\*ubergabe mu\*s bestimmt werden, welche Gr\*o\*se in
Worten bzw. Bytes der aktuelle Parameter hat. Abgesehen davon
wird ein offenes Feld mit Elementen vom Typ \%WORD bzw. \%BYTE
genauso behandelt
wie jedes andere offene Feld auch. Der folgende Ausschnitt
eines Modula-Programms
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
PROCEDURE WriteBytes (VAR a: ARRAY OF WORD);
  ...
WriteBytes (w);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
wird in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
void WriteBytes(a, O_6)
WORD a[]; LONGCARD O_6;
  ...
WriteBytes(&w, sizeof(w));
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
Bei dieser Abbildung wird angenommen, da\*s
\%\fIsizeof\fP\|(WORD) bzw. \%\fIsizeof\fP\|(BYTE)
den Wert 1 haben.
Ist der aktuelle Parameter ein offenes Feld, dann ist die
Gr\*o\*se des aktuellen Parameters in Worten bzw. Bytes:
\%\fIsizeof\^(Elementtyp)\fP * \fIaktuelle Anzahl von Feldelementen\fP.
.sp 0.4v
.ne 2v
.ti +2n
Der Typ \%ADDRESS ist definiert als:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef unsigned char *ADDRESS;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
In \%Modula-2 ist der Typ \%ADDRESS kompatibel mit allen anderen
Zeigertypen. Wegen der in C vorhandenen M\*oglichkeit Zeiger verschiedenen
Typs einander zuzuweisen oder einen Zeiger an eine Funktion zu \*ubergeben,
dessen Typ sich vom Typ des formalen Parameters unterscheidet, erfordert
diese in \%Modula-2 definierte Typkompatibilit\*at bei der Abbildung
nach C keine spezielle Behandlung.
Allerdings wird bei der Zuweisung in C eine explizite Typumwandlung erzeugt,
um sonst vom C-\*Ubersetzer ausgegebene Warnungen zu unterdr\*ucken.
.sp 0.4v
.ne 2v
.ti +2n
In Modula-2 k\*onnen alle
arithmetischen Operatoren auf Operanden mit Typ \%ADDRESS angewandt
werden, da \%ADDRESS auch kompatibel mit dem Typ \%CARDINAL ist.
Damit k\*onnen beliebige Adre\*sberechnungen durchgef\*uhrt werden. In C kann nur
ein ganzzahliger Wert zu einem Zeiger addiert oder von einem Zeiger
subtrahiert werden und zwei Zeiger
k\*onnen subtrahiert werden. Au\*serdem ist in C Zeigerarithmetik so
definiert, da\*s der Ausdruck \fIp+1\fP den Wert von \fIp\fP, erh\*oht um
die Gr\*o\*se des Objekts auf welches \fIp\fP zeigt, liefert.
Hat \%\fIsizeof\^(ADDRESS)\fP den Wert 1, dann ergibt sich
hier allerdings
kein Unterschied zur
Adre\*sarithmetik in Modula-2.
Wird daher im Modula-Programm der Typ \%ADDRESS innerhalb von arithmetischen
Ausdr\*ucken in einer in C nicht zul\*assigen Kombination verwendet, dann wird
der betreffende Operand in C zuerst in den Typ \%CARDINAL umgewandelt und falls
notwendig der Wert des gesamten Ausdrucks in den Typ \%ADDRESS
zur\*uckgewandelt\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ MOCKA definiert, da\*s ein arithmetischer Ausdruck in dem
mindestens ein Operand den Typ \%ADDRESS hat den Resultattyp \%ADRRESS
hat.
.nE
\&.
.sp 0.4v
.ne 2v
.ti +2n
Die Funktion \%TSIZE wird, wie die Standardfunktion \%SIZE, auf den
C-Operator \%\fIsizeof\fP abgebildet.
.sp 0.4v
.ne 2v
.ti +2n
\%ADR ist in \%SYSTEM_.h mit Hilfe des C-Operators &
zur Adre\*sbestimmung als folgendes Makro definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define ADR(x)          ((ADDRESS) &(x))
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Da offene Felder auf Vektoren abgebildet werden und ein Vektorname als
Ausdruck einen Zeiger auf das erste Element des Vektors liefert,
wird f\*ur die Bestimmung der Adresse eines offenen Feldes das
Makro \%ADR1 anstelle von \%ADR benutzt:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define ADR1(x)         ((ADDRESS) x)
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.br
.ne 4
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&\*Ubersetzungseinheiten\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&\*Ubersetzungseinheiten
.hE 4n 5n 0v
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Definitionsmoduln\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Definitionsmoduln
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Ein Definitionsmodul \%\fIM.md\fP wird in eine Definitionsdatei
\%\fIM.h\fP \*ubersetzt, die die vom Modul \fIM\fP exportierten Gr\*o\*sen beschreibt.
Diese Definitionsdatei wird mit einer
\fI#include\fP\^-An\%wei\%sung in alle
Moduln, die \fIM\fP importieren und in das
C-Programm \%\fIM.c\fP, welches die \*Ubersetzung des zu
\%\fIM.md\fP dazugeh\*origen Implementierungsmoduls ist, eingef\*ugt.
.sp 0.4v
.ne 2v
.ti +2n
Alle im Definitionsmodul \%\fIM.md\fP vereinbarten
Objekte werden in C in der qualifizierten Form \%\fIM_Objektname\fP geschrieben\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ 
Ausnahme: Die Komponentennamen einer Struktur werden in unqualifizierter Form
geschrieben, da sie immer bereits durch den Namen der Struktur, die sie enth\*alt,
qualifiziert sind.
.nE
\&.
.sp 0.4v
.ne 2v
.ti +2n
Konstanten- und Typdefinitionen werden wie im Kapitel \*uber
Deklarationen besprochen nach C umgesetzt.
.sp 0.4v
.ne 2v
.ti +2n
Die Definitionsdatei enth\*alt
eine \fIextern\fP\^-Deklaration f\*ur jede exportierte Variable. Diese Deklaration
legt die Eigenschaften wie Datentyp und Speicherbedarf der Variablen fest,
damit sie in allen Moduln, die die Variable benutzen, bekannt sind. Mit der
\fIextern\fP\^-Deklaration wird aber kein Speicherplatz reserviert. Die eigentliche
Vereinbarung der Variablen, die daf\*ur sorgt, da\*s Speicherplatz reserviert
wird, ist in \%\fIM.c\fP enthalten.
.sp 0.4v
.ne 2v
.ti +2n
Wird in der Definition einer exportierten Variablen ein anonymer strukturierter
Typ verwendet, so enth\*alt in C nur die \fIextern\fP\^-Deklaration in der
Definitionsdatei die vollst\*andige Strukturdeklaration dieses Typs. In der
eigentlichen Vereinbarung in \%\fIM.c\fP wird der in der
\fIextern\fP\^-Deklaration eingef\*uhrte Strukturname zur Beschreibung des Typs
verwendet. Diese Unterscheidung ist notwendig, da eine doppelt vorhandene
vollst\*andige Strukturdeklaration vom C-\*Ubersetzer als unzul\*assige
Redeklaration der betreffenden Struktur zur\*uckgewiesen wird. Somit wird der
folgende Ausschnitt des Definitionsmoduls \fIParser.md\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
VAR ParsTab : ARRAY [0..127] OF CHAR;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in der Definitionsdatei \fIParser.h\fP zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
extern struct Parser_1 {
    CHAR A[127 + 1];
} Parser_ParsTab;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
und im Programm \fIParser.c\fP zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
struct Parser_1 Parser_ParsTab;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Da Zeichenketten der L\*ange \%n\ >\ 1 auf einen initialisierten Zeichenvektor
abgebildet werden, mu\*s eine in einem Definitionsmodul als Konstante vereinbarte
Zeichenkette bei der \*Ubersetzung nach C wie eine exportierte Variable behandelt
werden. Das bedeutet, da\*s in der Definitionsdatei \%\fIM.h\fP eine
\fIextern\fP\^-Deklaration und im Programm \%\fIM.c\fP die eigentliche
Vereinbarung und Initialisierung der Konstante enthalten ist.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur jede von \fIM\fP exportierte Prozedur ist
ebenfalls eine \fIextern\fP\^-Deklaration vorhanden, die den Namen und den
Ergebnistyp der f\*ur die Prozedur erzeugten C-Funktion in allen Moduln
bekannt macht, die die Prozedur importieren.
.sp 0.4v
.ne 2v
.ti +2n
Der Definitionsmodul \%\fITree.md\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 6
DEFINITION MODULE Tree;
.sp 0.4v
CONST  NoTree   = NIL;
.sp 0.4v
TYPE
  tTree         = POINTER TO tNode;
  tNode         = RECORD
                    Key   : INTEGER;
                    Left  ,
                    Right : tTree;
                  END;
.sp 0.4v
.br
.ne 5
VAR  Root       : tTree;
.sp 0.4v
PROCEDURE MakeNode (Key: INTEGER; Left, Right: tTree): tTree;
.sp 0.4v
END Tree.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zur Definitionsdatei \fITree.h\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
#define Tree_NoTree     NIL
.sp 0.4v
typedef struct Tree_1 *Tree_tTree;
.zA
typedef struct Tree_1 {
    INTEGER    Key;
    Tree_tTree Left, Right;
} Tree_tNode;
.zE
.sp 0.4v
.br
.ne 3
extern  Tree_tTree Tree_Root;
.sp 0.4v
extern  Tree_tTree Tree_MakeNode();
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&FOREIGN-Moduln\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&FOREIGN-Moduln
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%MOCKA erlaubt es, da\*s in C
geschriebene Prozeduren im Modula-Programm aufgerufen werden. Diese
Prozeduren m\*ussen in sogenannten \%FOREIGN-\%Mo\%dul deklariert sein,
die als Definitionsmoduln fungieren\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ FOREIGN-Mo\%duln k\*onnen auch
Typ- und Konstantendeklarationen enthalten.
.nE
\&.
Bei der \*Ubersetzung von \%Modula-2
nach C wird ein FOREIGN-\%Mo\%dul im Prinzip
wie ein
Definitionsmodul behandelt. Der einzige Unterschied ist, da\*s alle
dort definierten Prozeduren im erzeugten C-Programm nicht mit dem
Modulnamen qualifiziert werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Implementierungs- und Programmoduln\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Implementierungs- und Programmoduln
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Ein Implementierungs- oder Programmodul \%\fIM.mi\fP wird in ein C-Programm
\%\fIM.c\fP \*ubersetzt. \%\fIM.c\fP enth\*alt neben
der \*Ubersetzung der im Implementierungs- oder Programmodul enthaltenen
Konstanten-, Typ-, Variablen- und Prozedurdeklarationen
auch Vereinbarungen f\*ur die in der Definitionsdatei
\%\fIM.h\fP in \fIextern\fP\^-Deklarationen erw\*ahnten
exportierten Variablen.
.sp 0.4v
.ne 2v
.ti +2n
\%SYSTEM_.h mit der Definition der Standardtypen, -prozeduren
und -funktionen wird in
jedes erzeugte C-Programm als erste Definitionsdatei eingef\*ugt.
.sp 0.4v
.ne 2v
.ti +2n
Da auch in C eine getrennte \*Ubersetzung m\*oglich ist, k\*onnen alle vom
\*Ubersetzer f\*ur Implementierungs- bzw. Programmoduln erzeugten
C-Programme vom C-\*Ubersetzer getrennt \*ubersetzt werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&IMPORT-Anweisungen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&IMPORT-Anweisungen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
IMPORT-Anweisungen werden in eine Folge von
\fI#include\fP\^-An\%wei\%sun\%gen \*ubersetzt.
Damit eine Definitionsdatei nicht mehrfach in ein C-Programm eingef\*ugt
wird\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Mehrfach vorhandene identische Typ- bzw. Konstantendeklarationen innerhalb
einer Quelldatei sind in C nicht zul\*assig.
.nE
\&, wird am Anfang jeder
Definitionsdatei \%\fIM.h\fP der Makroname \%DEFINITION_\fIM\fP mit einer
\fI#define\fP\^-An\%wei\%sung definiert und die IMPORT-Anweisung
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
FROM M IMPORT ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in die Pr\*aprozessor-Anweisungen
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#ifndef DEFINITION_M
#include "M.h"
#endif
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
\*ubersetzt. Damit wird erreicht, da\*s die Definitionsdatei \%\fIM.h\fP
nur genau einmal in eine Quelldatei eingef\*ugt wird.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Opaque Typen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Opaque Typen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
In Modula-2 ist es erlaubt im Definitionsmodul nur den Namen eines Typs zu
vereinbaren, dessen vollst\*andige Definition dann im Implementierungsmodul
enthalten sein mu\*s. Diese Typen, deren Struktur den sie importierenden Moduln
unbekannt ist, werden als opaque Typen bezeichnet. Opaque Typen sind
immer Zeigertypen.
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung nach C wird folgenderma\*sen gehandhabt: In der Definitionsdatei
wird ein opaquer Typ als
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef OPAQUE Modulname_Typname;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
vereinbart. Der Typ
\%OPAQUE ist in \%SYSTEM_.h als
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef ADDRESS OPAQUE;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
definiert.
.sp 0.4v
.ne 2v
.ti +2n
Da auf opaque Typen in \%Modula-2 au\*serhalb des Moduls
in dem sie definiert sind, nur Zuweisung und Vergleich anwendbar sind,
ist bei der \*Ubersetzung von Moduln, die diese Typen importieren
keine spezielle Behandlung von opaquen Typen notwendig. Die im
Implementierungsmodul enthaltene vollst\*andige Definition des opaquen Typs
wird in eine zweite \fItypedef\fP\^-Anweisung
umgesetzt. Da der Typname in der
Definitionsdatei qualifiziert wird, ergeben sich dabei keine Namenskonflikte.
Auch innerhalb des nach C \*ubersetzten Implementierungsmoduls wird die
Typdefinition aus der Definitionsdatei in allen Deklarationen benutzt. Um
jedoch eine korrekte Anwendung des opaquen Typs in Anweisungen
zu erzwingen, wird vor jeder Dereferenzierung eine explizite Typumwandlung
in den vollst\*andigen Typ eingef\*ugt.
.sp 0.4v
.ne 2v
.ti +2n
Der Definitionsmodul \fILists.md\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 5
DEFINITION MODULE Lists;
.sp 0.4v
FROM SYSTEM     IMPORT ADDRESS;
.sp 0.4v
TYPE  tList;
.sp 0.4v
.br
.ne 3
PROCEDURE Insert (VAR List: tList; Elmt: ADDRESS);
  ...
END Lists.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zur Definitionsdatei \fILists.h\fP
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define DEFINITION_Lists
.sp 0.4v
typedef OPAQUE Lists_tList;
.sp 0.4v
extern  void Lists_Insert();
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Der Implementierungsmodul \fILists.mi\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 6
IMPLEMENTATION MODULE Lists;
.sp 0.4v
FROM SYSTEM     IMPORT ADDRESS;
.sp 0.4v
TYPE
  tList = POINTER TO tElmt;
  tElmt = RECORD
            Elmt : ADDRESS;
            Next : tList;
          END;
.sp 0.4v
.br
.ne 3
PROCEDURE Insert (VAR List: tList; Elmt: ADDRESS);
VAR  Head : tList;
BEGIN
  Head       := MakeElmt (Elmt);
  Head^.Next := List;
  List       := Head;
END Insert;
.br
.ne 2
  ...
END Lists.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zum Programm \fILists.c\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
#include "SYSTEM_.h"
.sp 0.4v
#ifndef DEFINITION_Lists
#include "Lists.h"
#endif
.sp 0.4v
typedef struct S_1 *tList;
.zA
typedef struct S_1 {
    ADDRESS     Elmt;
    Lists_tList Next;
} tElmt;
.zE
.sp 0.4v
.br
.ne 4
void Lists_Insert(List, Elmt)
Lists_tList *List; ADDRESS Elmt;
{
    Lists_tList Head;
.sp 0.4v
    Head = MakeElmt(Elmt);
    ((tList)Head)->Next = List;
    *List = Head;
}
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Modulinitialisierung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Modulinitialisierung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Modulinitialisierung wird in C mit folgendem Schema behandelt: F\*ur
jeden Implementierungsmodul wird in C eine parameterlose
Initialisierungsroutine erzeugt. Diese ruft zun\*achst
die Initialisierungsroutinen aller direkt importierten Moduln in der
textuellen Reihenfolge der zugeh\*origen IMPORT-Anweisungen
auf und enth\*alt dann die Anweisungen aus dem Rumpf des Moduls.
Um eine korrekte und vollst\*andige Initialisierung aller Moduln zu
erreichen, m\*ussen dabei auch die IMPORT-Anweisungen aus dem zum
Implementierungsmodul dazugeh\*origen Definitionsmodul ber\*ucksichtigt werden.
Diese Reihenfolge
der Initialisierung entspricht genau der in der Sprachdefinition
von Modula-2 geforderten Reihenfolge. Damit die Initialisierungsroutine nicht
mehrfach ausgef\*uhrt wird, enth\*alt sie eine boolesche Variable, die angibt,
ob die Routine bereits aufgerufen wurde. Nur beim ersten Aufruf wird sie
ausgef\*uhrt.
Somit haben die Initialisierungsroutinen folgende Form:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
void BEGIN_Modulname()
{
    static BOOLEAN has_been_called = FALSE;
.sp 0.4v
    if (!has_been_called) {
        has_been_called = TRUE;
.sp 0.4v
.br
.ne 3
        /*
         *  Initialisierungsroutinen der
         *  importierten Moduln aufrufen.
         *
.br
.ne 5
         *  Anweisungen des Modulrumpfs
         *  ausf\*uhren.
         */
    }
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Diese Behandlung der Modulinitialisierung erfordert zur Laufzeit einen etwas
erh\*ohten Aufwand, da ein Teil der Initialisierungsroutinen m\*oglicherweise
mehrfach aufgerufen wird. Der gro\*se Vorteil dieser L\*osung ist aber, da\*s
alle Moduln korrekt initialisiert werden, ohne da\*s bei der \*Ubersetzung
des Programmoduls bestimmt werden mu\*s, welche Moduln in einem Programm
benutzt werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Hauptprogramm\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Hauptprogramm
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Rumpf des Programmoduls bildet in \%Modula-2 das Hauptprogramm.
In C wird er zu der Funktion \%BEGIN_MODULE. Diese ruft zun\*achst die
Initialisierungsroutinen aller direkt importierten Moduln auf und enth\*alt dann
die Anweisungen aus dem Rumpf des Programmoduls.
.sp 0.4v
.ne 2v
.ti +2n
Die Datei \%SYSTEM_.c enth\*alt eine feste Definition der Funktion
\%\fImain\fP, die in C das Hauptprogramm
bildet. Diese Funktion hat folgendes Aussehen:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
int    SYSTEM_argc;
char **SYSTEM_argv;
char **SYSTEM_envp;
.sp 0.4v
.br
.ne 3
main(argc, argv, envp)
int argc;
char *argv[], *envp[];
{
  SYSTEM_argc = argc;
  SYSTEM_argv = argv;
  SYSTEM_envp = envp;
.sp 0.4v
  BEGIN_MODULE();
.sp 0.4v
.br
.ne 2
  exit(0);
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Vor dem Aufruf von \%BEGIN_MODULE werden in \%\fImain\fP die
Programmparameter behandelt. In C und unter \%UNIX k\*onnen beim Aufruf
eines Programms Argumente aus der Kommandozeile an das Programm \*ubergeben
werden. Das erste Argument \%\fIargc\fP ist die Anzahl der Argumente, das
zweite Argument \%\fIargv\fP ist ein Zeiger auf einen Vektor mit
Zeichenketten, die die Argumente enthalten. Das dritte Argument \%\fIenvp\fP
schlie\*slich erm\*oglicht den Zugriff auf UNIX-Variablen der Aufrufumgebung.
.sp 0.4v
.ne 2v
.ti +2n
Die MOCKA-Bibliothek enth\*alt ein \%FOREIGN-\%Mo\%dul,
welches die Definition von
Prozeduren enth\*alt, welche Modula-Programmen den Zugriff auf die
Programmparameter erm\*oglichen. Die Implementierung dieses FOREIGN-Moduls ist
bei \%MOCKA ein Teil des Laufzeitsystems. Die obige Behandlung der
Programmparameter in der Funktion \%\fImain\fP erm\*oglicht es, dieses
\%FOREIGN-\%Mo\%dul in C zu implementieren.
.sp 0.4v
.ne 2v
.ti +2n
Die Funktion \%\fImain\fP wird mit \%\fIexit\^(0)\fP beendet,
um der Aufrufumgebung anzuzeigen, da\*s die Ausf\*uhrung des Programms
erfolgreich war.
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Implementierung des \*Ubersetzers\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Implementierung des \*Ubersetzers
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
Bild \n(h1.1 gibt einen kurzen \*Uberblick \*uber die einzelnen Phasen
des \*Ubersetzers \%\fIMtc\fP, die f\*ur die Implementierung der Phasen verwendeten
\*Ubersetzerbauwerkzeuge (in Klammern hinter den Namen der Phasen)
sowie \*uber die wichtigsten intern auftretenden
Datenstrukturen, die der Kommunikation der einzelnen \*Ubersetzerphasen dienen.
.bA
\s-2
.PS
define data #
	box invis ht 0.3i wid 1.3i $2 $1
#
define text #
	$1 at $2.w - (1.8i, 0) ljust
#
lineht	= 0.2i
linewid	= 0.2i
moveht	= 0.2i
movewid	= 0.2i
boxwid	= 1.7i
boxht	= 0.7i
	down
	data("Aktuelle \*Ubersetzungseinheit", at (0,0))
	arrow
B1:	box "Lexikalische und" "syntaktische Analyse" "Baumaufbau"
	line
	data("Strukturbaum der aktuellen \*Ubersetzungseinheit")
	arrow
B2:	box "Behandlung der getrennten" "\*Ubersetzung"
	line
	data("Vollst\*andiger Strukturbaum")
	arrow
B3:	box "Semantische Analyse" "Berechnung von Attributen" "f\*ur die Codeerzeugung"
	line
	data("Attributierter Strukturbaum")
	arrow
B4:	box "Codeerzeugung"
	arrow
	data("C-Programm und/oder C-Definitionsdatei(en)")
	move to B2.e; move right
D:	data("Definitionsmoduln")
	arrow left from D.w 
	text("\fIParse (Rex, Ell, Ast)\fP", B1)
	text("\fIGetDefinitionModules\fP", B2)
	text("\fIEval (Ag)\fP", B3)
	text("\fIDoCode (Estra)\fP", B4)
.PE
\&\s+2
.sp 0.4v
.ce 9999
\&\fBBild \n(h1.1\fP: Phasen des \*Ubersetzers \%\fIMtc\fP
.ce 0
.bB 1v
.sp 0.4v
.ne 2v
.ti +2n
Die folgenden Kapitel enthalten eine genauere Besprechung der Aufgaben und
Implementierung der einzelnen Phasen des \*Ubersetzers, wobei besonderer Wert
auf die Darstellung des Einsatzes der Werkzeuge gelegt wird.
Grundlegende Begriffe und Techniken des \*Ubersetzerbaus
[Aho\|86, Waite\|84] werden dabei als weitgehend bekannt
vorausgesetzt.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Lexikalische Analyse\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Lexikalische Analyse
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Sym\%bol\%ent\%schl\*uss\%ler liest das Eingabeprogramm
zeichenweise und zerlegt es
in eine Folge von Grundsymbolen, die an den Zerteiler weitergereicht werden.
Seine Aufgaben sind im einzelnen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Erkennen der m\*oglichen Grundsymbole der Sprache \%Modula-2:
Bezeichner, ganze Zahlen (oktal, dezimal oder hexadezimal), reelle Zahlen,
Zeichenkonstanten, Zeichenketten, Schl\*usselw\*orter, Operatoren und
Trennsymbole.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Berechnung der Attribute der Grundsymbole:
.sp 0.1vv
.if \n(.nu<4n .sp -0.1vv
.nr a2 0
.af a2 a
.sp 0.1vv
.if \n(.nu>4n .sp -0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Quelltextposition
.in -4n
.sp 0.1vv
.sp 0.1vv
.if \n(.nu>4n .sp -0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&semantische Information
.in -4n
.sp 0.1vv
.sp 0.1vv
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\*Uberlesen von Kommentaren, Zwischenr\*aumen und Zeilenwechseln.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Melden von illegalen Zeichen und nicht geschlossenen Kommentaren und
Zeichenketten.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die Kodierung der erkannten Grundsymbole und deren Attribute werden an den
Zerteiler weitergereicht.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Attribute der Grundsymbole\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Attribute der Grundsymbole
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Quelltextposition der Grundsymbole wird f\*ur sp\*atere Fehlermeldungen
ben\*otigt.
Sie setzt sich zusammen aus dem Namen der Eingabedatei sowie aus Zeile und
Spalte des Grundsymbols innerhalb der Eingabedatei. Warum auch der Name der
Eingabedatei mit in die Quelltextposition aufgenommen wurde, wird im
Zusammenhang mit der Behandlung der getrennten \*Ubersetzung n\*aher erl\*autert.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur sp\*atere \*Ubersetzerphasen wird zus\*atzliche sematische Information
f\*ur solche Grundsymbole ben\*otigt, die durch die zugeh\*orige Zeichenkette
nicht eindeutig festgelegt sind.
Die Tabelle \n(h1.2 beschreibt diese Grundsymbole und die Bedeutung der
.bA
.sp 0.4v
.TS
delim($$)tab(|) center box;
c| c
l| lw(6.5c).
Grundsymbol|Semantische Information
_
Bezeichner|T{
Eindeutige Abbildung der zugeh\*origen Zeichenkette auf eine ganze Zahl
T}
Dezimalzahl|T{
Wert der Zahl
T}
Oktalzahl|T{
Wert der Zahl
T}
Hexadezimalzahl|T{
Wert der Zahl
T}
Zeichenkonstante|T{
Zugeh\*origes Zeichen
T}
Reelle Zahl|T{
Verweis in die Konstantentabelle
T}
Zeichenkette|T{
Verweis in die Konstantentabelle
T}
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.2\fP: Semantische Information der Grundsymbole
.ce 0
.sp 0.4v
.bB 1v
zugeh\*origen semantischen Information.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Symbol- und Konstantentabelle\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Symbol- und Konstantentabelle
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Symboltabellenmodul \%\fIIdents\fP zur eindeutigen Abbildung von
Zeichenketten auf ganze Zahlen, der Konstantentabellenmodul
\%\fIStringMem\fP zur Speicherung von Zeichenketten variabler
L\*ange sowie der von beiden verwendete Modul \%\fIStrings\fP
zur Manipulation von Zeichenketten und zur Konvertierung von Zeichenketten in
interne Darstellungen, wie z.B. ganze Zahlen, wurden aus der Bibliothek
\%\fIReuse\fP [Grosch\|87a] entnommen.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Spezifikation des Symbolentschl\*usslers\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Spezifikation des Symbolentschl\*usslers
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Sym\%bol\%ent\%schl\*uss\%ler wurde mit Hilfe des Generators \%\fIRex\fP
[Grosch\|87b]
aus einer
Beschreibung der Grundsymbole von \%Modula-2 erzeugt. Eine solche
Beschreibung besteht aus einer Reihe von regul\*aren Ausdr\*ucken, welche die
Grundsymbole beschreiben und Aktionen, die ausgef\*uhrt werden, wenn die
zugeh\*origen regul\*aren Ausdr\*ucke in der Eingabe erkannt werden. \%\fIRex\fP
\*ubersetzt diese Beschreibung in einen tabellengesteuerten
Sym\%bol\%ent\%schl\*uss\%ler, der im
Modul \%\fIScanner\fP enthalten ist.
.sp 0.4v
.ne 2v
.ti +2n
Die Aktionen bestehen in den meisten F\*allen aus der Berechnung der Attribute
des zugeh\*origen Grundsymbols und einer RETURN-An\%wei\%sung, mit der die
Kodierung des Grundsymbols an den Zerteiler zur\*uckgeliefert wird.
Zeile und Spalte der Grundsymbole im
Quelltext werden vom generierten Sym\%bol\%ent\%schl\*uss\%ler automatisch berechnet.
.sp 0.4v
.ne 2v
.ti +2n
Das folgende
Beispiel zeigt einige Ausschnitte aus der Spezifikation des
Sym\%bol\%ent\%schl\*uss\%lers:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#STD#      "(*"         :- {NestingLevel := 1; yyStart (Comment);}
#Comment#  "(*"         :- {INC (NestingLevel);}
#Comment#  "*)"         :- {DEC (NestingLevel);
                            IF NestingLevel = 0 THEN yyStart (STD); END;}
#Comment#  "(" | "*" | - {*(\et\en} + :- {}
.sp 0.4v
#STD# ARRAY             : {Attribute.Pos.File   := SourceFileName;
                           Attribute.Pos.Line   := Line;
                           Attribute.Pos.Column := Column;
                           RETURN TokArray;}
.sp 0.4v
#STD# letter (letter | digit) * : {
                           GetWord (Word);
                           Attribute.Ident      := MakeIdent (Word);
                           Attribute.Pos.File   := SourceFileName;
                           Attribute.Pos.Line   := Line;
                           Attribute.Pos.Column := Column;
                           RETURN TokIdent;}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
F\*ur komplexe Aufgaben und insbesondere f\*ur die Behandlung von Linkskontext
stehen sogenannte Startzust\*ande zur Verf\*ugung. In der Spezifikation kann
festgelegt werden, da\*s bestimmte Muster nur in bestimmten Startzust\*anden
erkannt werden. Zu Beginn ist der Sym\%bol\%ent\%schl\*uss\%ler immer im Startzustand
\%STD. Startzust\*ande k\*onnen mit speziellen Anweisungen in den Aktionen
gewechselt werden. Diese M\*oglichkeit wird im obigen Beispiel f\*ur die
Bearbeitung von Kommentaren benutzt. Die Variable \%\fINestingLevel\fP ist
notwendig, da Kommentare in \%Modula-2 geschachtelt sein k\*onnen
und geschachtelte Kommentare nicht durch einen regul\*aren Ausdruck
beschrieben werden k\*onnen.
Die Funktion \%\fIMakeIdent\fP aus dem Modul \%\fIIdents\fP bildet die vom
Sym\%bol\%ent\%schl\*uss\%ler erkannte Zeichenfolge eines Bezeichners eindeutig
auf eine ganze Zahl ab.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Syntaktische Analyse und Baumaufbau\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Syntaktische Analyse und Baumaufbau
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Aufgabe des Zerteilers ist es, die syntaktische Struktur des Quellprogramms
zu analysieren, dessen syntaktische Korrektheit zu \*uberpr\*ufen und einen
abstrakten Strukturbaum aufzubauen.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Zerteilerspezifikation\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Zerteilerspezifikation
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
F\*ur die Erstellung eines Zerteilers standen die beiden Zerteilergeneratoren
\%\fIEll\fP und \%\fILalr\fP [Vielsack\|88]
zur Verf\*ugung. Verglichen mit \%\fILalr\fP hat
\%\fIEll\fP die folgenden Vor- und Nachteile:
.sp 0.4v
Vorteile:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die von \%\fIEll\fP unterst\*utzte
L-Attributierung\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Bei der
L-Attributierung sind sowohl vererbte als auch synthetisierte Attribute
m\*oglich.
Dabei darf innerhalb einer Grammatikregel
\%\fIX\v'+0.3m'\s-4\&0\&\s+4\v'-0.3m'\|:\|X\v'+0.3m'\s-4\&1\&\s+4\v'-0.3m'\|...\|X\v'+0.3m'\s-4\&n\&\s+4\v'-0.3m'\|.\fP
ein Attribut des Symbols \%\fIX\v'+0.3m'\s-4\&i\&\s+4\v'-0.3m'\fP
(\|\%1\|\(<=i\|\(<=n\|)
nur von vererbten
Attributen des Symbols \%\fIX\v'+0.3m'\s-4\&0\&\s+4\v'-0.3m'\fP oder von Attributen der Symbole
\%\fIX\v'+0.3m'\s-4\&1\&\s+4\v'-0.3m'\fP bis \%\fIX\v'+0.3m'\s-4\&i-1\&\s+4\v'-0.3m'\fP abh\*angen.
.nE
\&,
mit der parallel zur Zerteilung Attributwerte berechnet werden k\*onnen,
ist m\*achtiger als die von \%\fILalr\fP unterst\*utzte
S-Attributierung\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Bei der S-Attributierung sind nur synthetisierte Attribute zul\*assig.
.nE
\&.
Au\*serdem kann die Attributierung bei \%\fIEll\fP
im Gegensatz zu \%\fILalr\fP
\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ \%\fILalr\fP benutzt die Pseudovariablen
\*(dO\*(dO bzw. \*(dOn, um auf das Nichtterminal der linken Seite bzw. das n-te Symbol der rechten
Seite einer Produktion zuzugreifen.
.nE
\&
symbolisch durchgef\*uhrt werden und ist damit weniger
fehleranf\*allig.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein von \%\fIEll\fP erzeugter Zerteiler ist etwa doppelt so schnell wie
ein von \%\fILalr\fP erzeugter.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
Nachteile:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der gravierendste Nachteil von \%\fIEll\fP ist, da\*s die von \%\fIEll\fP
akzeptierte Sprachklasse \%ELL(1) weniger m\*achtig ist als die von
\%\fILalr\fP akzeptierte Sprachklasse \%LALR(1).
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Von \%\fILalr\fP erzeugte Zerteiler sind in der Regel kleiner als von
\%\fIEll\fP erzeugte.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da bereits eine ELL(1)-Grammatik f\*ur \%Modula-2 vorlag, gaben die oben
genannten Vorteile von \%\fIEll\fP den Ausschlag f\*ur die Entscheidung \%\fIEll\fP
zu verwenden.
.sp 0.4v
.ne 2v
.ti +2n
Die Eingabe f\*ur \%\fIEll\fP besteht aus einer kontextfreien Grammatik in
erweiterter \%BNF, die die Struktur der Eingabesprache beschreibt. Jede
Produktion der Grammatik kann eine Reihe von semantischen Aktionen enthalten,
welche ausgef\*uhrt werden,
sobald der Zerteiler die zugeh\*origen Grammatikregeln analysiert.
.sp 0.4v
.ne 2v
.ti +2n
\%\fIEll\fP erzeugt aus der kontextfreien Grammatik
einen Zerteiler (enthalten im Modul \%\fIParser\fP), der nach dem Verfahren des
rekursiven Abstiegs arbeitet.
Die semantischen Aktionen werden an die
entsprechenden Stellen in den Quelltext des Zerteilers kopiert. Der erzeugte
Zerteiler besitzt eine automatische Fehlerbehandlung, die mit einem
r\*ucksetzungsfreien Fehlerkorrekturalgorithmus arbeitet.
Ist die vom Sym\%bol\%ent\%schl\*uss\%ler gelieferte Folge von Grundsymbolen nicht
syntaktisch korrekt, setzt der Zerteiler nach Abgabe einer Fehlermeldung die
Zerteilung fort, indem er Symbole \*uberliest und/oder einf\*ugt, so da\*s immer
ein syntaktisch korrekter Strukturbaum erzeugt wird.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Spezifikation des Strukturbaums\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Spezifikation des Strukturbaums
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Eine Spezifikation der abstrakten Syntax von \%Modula-2 wurde mit
der Spezifikationssprache des Generators \%\fIAst\fP [Grosch\|89a]
erstellt.
\%\fIAst\fP erzeugt aus der Spezifikation der abstrakten Syntax den Modul
\%\fITree\fP, der Typdeklarationen zur Implementierung des Strukturbaums und 
Prozeduren zum Aufbau von Baumknoten und zur Umkehr von Knotenlisten
enth\*alt.
.sp 0.4v
.ne 2v
.ti +2n
Die Struktur und die Eigenschaften der Knoten, aus denen ein abstrakter
Strukturbaum besteht, werden in einer \fIAst\fP\^-Spezifikation mit sogenannten
Knotentypen beschrieben. Jeder Knoten geh\*ort zu einem bestimmten Knotentyp.
Der Typ beschreibt die Kindknoten (Unterb\*aume) und die Attribute des Knotens.
Knotentypen k\*onnen als Erweiterung von anderen Knotentypen definiert werden;
letztere werden als Basistypen bezeichnet, erstere als abgeleitete Typen. Die
abgeleiteten Typen erben die Kindknoten und Attribute des Basistyps und k\*onnen
wiederum erweitert werden. \*Uberall dort, wo ein Knoten eines bestimmten
Basistyps erwartet wird, ist auch ein Knoten zul\*assig, dessen Typ aus dem Basistyp
abgeleitet wurde.
.sp 0.4v
.ne 2v
.ti +2n
Folgender Ausschnitt der \fIAst\fP\^-Spezifikation
beschreibt die abstrakte Syntax eines Teils der Anweisungen von \%Modula-2:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
Stmts         = <
  Stmts0      = .
  Stmt        = Next: Stmts REVERSE <
    Assign    = Designator Expr .
    Call      = Designator Actuals .
    If        = Cond: Expr Then: Stmts Elsifs Else: Stmts .
.br
.ne 5
    Case      = Expr Cases Else: Stmts [Default: BOOLEAN] .
    While     = Cond: Expr Stmts .
    ...
  >.
>.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Knotentypen \%\fIAssign\fP, \%\fICall\fP, usf. sind Erweiterungen des
Knotentyps \%\fIStmt\fP,
welcher wiederum eine Erweiterung des Knotentyps \%\fIStmts\fP ist. Attribute sind
in eckigen Klammern eingeschlossen. Die Spezifikation von Kindknoten besteht
aus dem zugeh\*origen Knotentyp und einem optionalen Selektornamen. Die
Knotentypen \%\fIAssign\fP, \%\fICall\fP, usf. erben den Kindknoten mit Namen \%\fINext\fP von
ihrem Basistyp \%\fIStmt\fP.
Die abstrakte Syntax enth\*alt im Gegensatz zur konkreten Syntax keine eigenen
Knotentypen f\*ur Listen. Stattdessen enth\*alt jeder Knotentyp f\*ur
Listenelemente einen Kindknoten \%\fINext\fP, der auf das n\*achste Element
der Liste verweist.
Die Angabe \%REVERSE wird von \%\fIAst\fP
zur Erzeugung der Prozedur f\*ur die Umkehr von Knotenlisten
ben\*otigt.
.sp 0.4v
.ne 2v
.ti +2n
Beim Entwurf der abstrakten Syntax wurde darauf geachtet, da\*s die
Strukturb\*aume m\*oglichst einfach und kompakt aufgebaut sind.
Dadurch wird nicht nur der Speicherbedarf der
Strukturb\*aume reduziert, sondern auch deren Verarbeitung beschleunigt, da bei
der Traversierung weniger Knoten besucht werden m\*ussen.
Anhang A
enth\*alt die vollst\*andige \fIAst\fP\^-Spezifikation der abstrakten Syntax von
\%Modula-2, wie sie f\*ur den \*Ubersetzer verwendet wurde.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Baumaufbau\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Baumaufbau
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Zum Aufbau des Strukturbaums w\*ahrend der Zerteilung wird der von \%\fIEll\fP
angebotene Mechanismus zur L-Attributierung, die von \%\fIAst\fP
generierten
Prozeduren f\*ur den Baumaufbau und die Prozedur \%\fIReverseTree\fP
zur Umkehr von Knotenlisten benutzt.
.sp 0.4v
.ne 2v
.ti +2n
Das folgende Beispiel zeigt
einen Ausschnitt der kontextfreien Grammatik f\*ur Fallmarken mit semantischen
Aktionen f\*ur den Baumaufbau:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 7
Labels          /* Tree: synthesized                    */
.sp 0.4v
                :
  { Label1.Tree := mLabels0 (); }
                  Label || ','
  { Labels0.Tree := ReverseTree (Label1.Tree); }
                .
.sp 0.4v
.br
.ne 9
Label           /* Tree: inherited and synthesized      */
.sp 0.4v
                : Expr
                    ( '..' Expr
    { Label0.Tree := mLabelRange (Label0.Tree, Expr1.Tree, Expr2.Tree); }
                    |
    { Label0.Tree := mLabel (Label0.Tree, Expr1.Tree); }
                    )
                .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Baumknoten werden aufgebaut durch Aufrufe der von \%\fIAst\fP f\*ur diesen
Zweck generierten Prozeduren. \%\fIAst\fP generiert
f\*ur jeden Knotentyp eine solche Prozedur. Die Kindknoten und Attribute des
Knotens werden als Parameter \*ubergeben und ein Zeiger auf den neu
angelegten Knoten wird zur\*uckgeliefert.
Die Nichtterminale der kontextfreien Grammatik besitzen ein Attribut
\%\fITree\fP, welches den Teilbaum beschreibt, dessen Wurzel das
Nichtterminal ist.
Die kontextfreie Grammatik enth\*alt noch verschiedene Nichtterminale
f\*ur Listen und Listenelemente. Im Baum existieren aber
nur noch Knotentypen f\*ur die Listenelemente mit einem
Verweis auf das jeweils n\*achste Element. Daher wird bei der Zerteilung
einer Liste der bisher aufgebaute Strukturbaum f\*ur die Liste, der aus
verketteten Listenelementen besteht, als vererbtes Attribut an das
Nichtterminal f\*ur die Listenelemente \*ubergeben und dort beim Aufbau
eines neuen Listenelements als Verweis auf das n\*achste Listenelement verwendet.
Dabei wird die Liste zun\*achst in der verkehrten
Reihenfolge aufgebaut. Dies wird aber in der Grammtikregel f\*ur die Liste
nach der Zerteilung der Liste durch einen Aufruf der von \%\fIAst\fP
generierten Prozedur \%\fIReverseTree\fP korrigiert.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Behandlung der getrennten \*Ubersetzung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Behandlung der getrennten \*Ubersetzung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die getrennte \*Ubersetzung erm\*oglicht es, Programme in kleinere Teile zu
zerlegen, die vom \*Ubersetzer einzeln \*ubersetzt werden k\*onnen. Die
wichtigsten Ziele einer solchen Zerlegung sind:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Aufteilung eines Programmsystems in \*uberschaubare und m\*oglichst
abgeschlossene Einheiten (Moduln), die eine definierte Schnittstelle nach
au\*sen besitzen und deren interne Implementierung nach au\*sen verborgen
bleibt.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Arbeitsteilige Erstellung von Programmsystemen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Reduktion des \*Ubersetzungsaufwands.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Entwicklung von Programmbibliotheken mit wiederverwendbarer Software.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Bei einer getrennten \*Ubersetzung sollte der \*Ubersetzer
zur Erzielung h\*oherer Zuverl\*assigkeit nach M\*oglichkeit
Korrektheitspr\*ufungen \*uber die
Grenzen von \*Ubersetzungseinheiten hinweg vornehmen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Eine h\*aufige
Fehlerquelle bei der Entwicklung von C-Programmen ist, da\*s in C solche
Pr\*ufungen vom \*Ubersetzer nicht automatisch vorgenommen werden.
.nE
\&.
.
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 unterst\*utzt die oben genannten Forderungen durch sein
Modulkonzept, insbesondere durch die Trennung von globalen Moduln in
Schnittstelle (Definitionsmodul) und Implementierung (Implementierungsmodul).
Soll in \%Modula-2 eine \*Ubersetzungseinheit \*ubersetzt werden, dann
m\*ussen dem \*Ubersetzer die Schnittstellen aller von der \*Ubersetzungseinheit
importierten Moduln bekannt sein. Auch bei der \*Ubersetzung von \%Modula-2
nach C m\*ussen die Schnittstellen der importierten Moduln bekannt sein, da f\*ur
eine korrekte \*Ubersetzung semantische Informationen
\*uber die importierten Objekte notwendig sind.
.sp 0.4v
.ne 2v
.ti +2n
Eine L\*osung f\*ur dieses Problem, die auch von \%MOCKA
implementiert wird, ist, bei der \*Ubersetzung eines
Definitionsmoduls eine sogenannte Symboldatei anzulegen, die einen Ausschnitt
der Definitionstabelle des \*Ubersetzers darstellt und eine Beschreibung aller
vom zugeh\*origen Modul exportierten Objekte enth\*alt.
Diese Symboldatei wird dann bei der \*Ubersetzung von abh\*angigen Moduln
benutzt, indem die dort enthaltene Information wieder
in die Definitionstabelle eingetragen wird.
.sp 0.4v
.ne 2v
.ti +2n
Eine alternative L\*osung ist, bei jedem \*Ubersetzungsvorgang den Quelltext
aller Schnittstellen von (transitiv) importierten Moduln von neuem einzulesen und
zu analysieren.
.sp 0.4v
.ne 2v
.ti +2n
Vergleicht man die beiden L\*osungen ergibt sich folgendes:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein \*Ubersetzer, welcher die L\*osung mit den Symboldateien verwendet, ist
schneller  und der gesamte \*Ubersetzungsaufwand reduziert sich, da eine
Schnittstelle nur einmal \*ubersetzt und
nur einmal eine (bin\*are) Symboldatei angelegt werden mu\*s; bei der
\*Ubersetzung aller abh\*angigen \*Ubersetzungseinheiten mu\*s dann nur jeweils die
einmal angelegte Symboldatei neu eingelesen werden, was sicher weniger Aufwand
verursacht als den Quelltext der Schnittstelle
jedesmal von neuem einzulesen und zu analysieren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Programmieraufwand f\*ur die L\*osung mit den
Symboldateien ist deutlich h\*oher, da Dateiformate f\*ur die Symboldateien
definiert und Operationen programmiert werden m\*ussen, die
a) die Information aus der Definitionstabelle lesen und auf die
Symboldatei schreiben und b)
die Symboldatei lesen und die Information in die Definitionstabelle
eintragen. Dieser zus\*atzliche Programmieraufwand entf\*allt
f\*ur die zweite L\*osung, da Einlesen und Analyse
der Schnittstellen sowieso ein Teil des \*Ubersetzers sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Zur Unterst\*utzung des Benutzers sollte ein \*Ubersetzer, der die erste
L\*osung realisiert, \*uberpr\*ufen, ob alle f\*ur die \*Ubersetzung einer bestimmten
\*Ubersetzungseinheit ben\*otigten Symboldateien vorhanden und auf dem neuesten
Stand, d.h. konsistent mit dem Quelltext des zugeh\*origen Definitionsmoduls,
sind und bei Bedarf zuerst die
(Neu-)\*Ubersetzung der zugeh\*origen Definitionsmoduln in eine Symboldatei
ansto\*sen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Ist eine derartige
automatische Unterst\*utzungsfunktion nicht implementiert,
mu\*s der Benutzer selbst die
Mo\%dul\%ab\%h\*an\%gig\%kei\%ten analysieren, mu\*s sich selbst um die
\*Ubersetzungsreihenfolge
und die Konsistenz der erzeugten Symboldateien bzw. Objektprogramme
k\*ummern. Eine u.U. recht aufwendige und fehleranf\*allige Arbeit, die
unbedingt vom \*Ubersetzer \*ubernommen werden sollte.
.nE
\&.
Dies entf\*allt bei der zweiten L\*osung automatisch, da sowieso alle
ben\*otigten Definitionsmoduln eingelesen werden\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Allerdings
wird dadurch nicht verhindert, da\*s die erzeugten
Objekt- bzw C-Programme m\*oglicherweise gegenseitig inkonsistent sind!
.nE
\&.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da \%\fIMtc\fP nicht f\*ur die Programmentwicklung gedacht ist und folglich ein
fertig entwickeltes Modula-Programm auch nur einmal nach C \*ubersetzt werden
mu\*s, ist es nicht kritisch, wenn der \*Ubersetzer aufgrund eines wiederholten
Einlesens und einer wiederholten Analyse von Schnittstellen
etwas langsamer ist. Daher gab der deutlich geringere Aufwand f\*ur die
Implementierung der zweiten L\*osung den Ausschlag, diese im \*Ubersetzer
\%\fIMtc\fP zu realisieren.
.sp 0.4v
.ne 2v
.ti +2n
Zur Realisierung der oben skizzierten L\*osung im \*Ubersetzer \%\fIMtc\fP
wurde zun\*achst die Definition
des Strukturbaums erweitert. Ein Strukturbaum besteht nicht nur aus einer
\*Ubersetzungseinheit, sondern aus einer Liste von \*Ubersetzungseinheiten:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
ROOT            = CompUnits .
.sp 0.4v
CompUnits       = <
  CompUnits0    = .
  CompUnit      = [Kind: SHORTCARD] [Ident: tIdent] [Pos: tPosition]
                  Next: CompUnits REVERSE <
    DefMod      = Import Decls .
    ProgMod     = Import Decls Stmts .
  >.
>.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Da die \*Ubersetzungseinheiten aus verschiedenen Quelldateien stammen, wird
jetzt auch klar, warum, wie im Kapitel \*uber die lexikalische Analyse bereits
erw\*ahnt, die Quelltextposition auch den Namen der Quelldatei enthalten mu\*s.
.sp 0.4v
.ne 2v
.ti +2n
Der Aufbau dieser Liste von \*Ubersetzungseinheiten, d.h. der Aufbau des
Strukturbaums in seiner endg\*ultigen Form und somit die Behandlung der
getrennten \*Ubersetzung, \*ubernimmt der Modul \%\fIDefMods\fP.
Der vom Zerteiler aufgebaute Strukturbaum f\*ur die aktuelle
\*Ubersetzungseinheit bildet die Eingabe f\*ur diesen Modul.
Innerhalb von \%\fIDefMods\fP werden die Importlisten aller bereits
eingelesenen \*Ubersetzungseinheiten traversiert und f\*ur alle
importierten und bisher
noch nicht eingelesenen (De\%fi\%ni\%ti\%ons-)Mo\%duln der Zerteiler aufgerufen,
welcher das Einlesen der Definitionsmoduln steuert und Strukturb\*aume
f\*ur sie aufbaut\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Entsprechend der von \%MOCKA implementierten
Konvention wird ein Definitionsmodul \fIM\fP in einer Datei mit Namen \%\fIM.md\fP
erwartet. Beim Aufruf von \%\fIMtc\fP k\*onnen auch Bibliotheken
angegeben werden, die dann nach den ben\*otigten
Definitionsmoduln durchsucht werden.
.nE
\&. Ist die aktuelle \*Ubersetzungseinheit ein
Implementierungsmodul, mu\*s auch der zugeh\*orige Definitionsmodul eingelesen
werden.
Aus dem Teilbaum der aktuellen \*Ubersetzungseinheit und aus
den vom Zerteiler gelieferten Teilb\*aumen der ben\*otigten Definitionsmoduln
wird schlie\*slich der vollst\*andige Strukturbaum aufgebaut
und an die semantische Analyse weitergereicht.
.sp 0.4v
.ne 2v
.ti +2n
Vergleicht man den Umfang der f\*ur die Behandlung der getrennten \*Ubersetzung
notwendigen Programmteile von \%\fIMtc\fP und \%MOCKA, best\*atigen sich die
oben gemachten Aussagen des Vergleichs hinsichtlich des Programmieraufwands der
beiden L\*osungen eindrucksvoll. Allein der Modul \%\fIDfFiles\fP von \%MOCKA,
der die Symboldateien liest und beschreibt sowie deren Daten aus der
Definitionstabelle liest und dort wieder eintr\*agt, umfa\*st ca. 1450 Zeilen
Modula-Code. Dazu kommt dann noch zus\*atzlich die von \%MOCKA implementierte
Steuerung der Nach\*ubersetzung bzw. der \*Ubersetzungsreihenfolge. Im Gegensatz
dazu umfa\*st der Modul \%\fIDefMods\fP von \%\fIMtc\fP, der die gesamte getrennte
\*Ubersetzung behandelt, nur ca. 250 Zeilen Modula-Code.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Semantische Analyse\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Semantische Analyse
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Normalerweise ist es die Aufgabe der semantischen Analyse,
die Bedeutung bzw. die Eigenschaften des Quellprogramms, welche zur statischen
Semantik\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Zur statischen Semantik einer Sprache geh\*oren alle Eigenschaften
eines Programms, die ohne eine Ausf\*uhrung des Programms abgeleitet werden
k\*onnen. Die dynamische Semantik eines Programms dagegen umfa\*st alle
Eigenschaften, die nur durch seine Ausf\*uhrung bestimmt werden k\*onnen.
.nE
\&
der Sprache geh\*oren, zu bestimmen und zu \*uberpr\*ufen, ob diese Eigenschaften
den Regeln der
statischen Semantik der Sprache, wie sie von der Sprachdefinition festgelegt
werden, gen\*ugen. Wie in der Einleitung bereits n\*aher erl\*autert und
begr\*undet, soll \%\fIMtc\fP die semantische Korrektheit der Eingabeprogramme
nicht \*uberpr\*ufen. Daher kann die semantische Analyse im \*Ubersetzer
\%\fIMtc\fP darauf beschr\*ankt werden, die Eigenschaften des Modula-Programms zu
bestimmen, soweit sie f\*ur eine korrekte \*Ubersetzung nach C bekannt sein
m\*ussen. Aus diesem Grund sind die zentralen Aufgaben der semantischen Analyse
im \*Ubersetzer \%\fIMtc\fP der Aufbau einer Definitionstabelle, die
Bezeichneridentifikation und die Typbestimmung in Ausdr\*ucken.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Spezifikation der semantischen Analyse mit einer Attributgrammatik und
abstrakten Datentypen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Spezifikation der semantischen Analyse mit einer Attributgrammatik und
abstrakten Datentypen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die semantische Analyse wurde mit einer Attributgrammatik spezifiziert. Der
Generator \%\fIAg\fP [Grosch\|89b] erzeugt aus dieser Attributgrammatik
einen Attributauswerter (enthalten im Modul \%\fISemantics\fP),
der mit rekursiven Besuchsprozeduren, welche den Strukturbaum
traversieren und die Attribute berechnen, implementiert ist.
.sp 0.4v
.ne 2v
.ti +2n
\%\fIAg\fP arbeitet eng mit \%\fIAst\fP zusammen. Die in Kapitel \n(h1.2.2
beschriebene Spezifikation der abstrakten Syntax ist nur der erste Teil einer
Attributgrammatik, deren zweiter Teil aus der Deklaration von Attributen und
aus Attributierungsregeln besteht, die die Werte dieser Attribute festlegen.
.sp 0.4v
.ne 2v
.ti +2n
Attribute und Attributierungsregeln werden den Knotentypen der abstrakten
Syntax zugeordnet. Als Typen f\*ur die Attribute sind alle Typen der Zielsprache
\%Modula-2, in welcher der Attributauswerter implementiert ist,
zul\*assig. Die Berechnung der Attribute wird ebenfalls mit Anweisungen
der Zielsprache \%Modula-2, wie z.B. Zuweisung oder bedingter Anweisung,
ausgedr\*uckt, aus denen \%\fIAg\fP
die At\%tri\%but\%ab\%h\*an\%gig\%kei\%ten
und eine geeignete Auswertungsreihenfolge ableitet.
Da die Anweisungen auch Aufrufe von externen Funktionen enthalten k\*onnen,
wird eine Verwendung von in der Zielsprache \%Modula-2 implementierten
abstrakten Datentypen in der Attributgrammatik
m\*oglich, die in getrennt \*ubersetzbaren Moduln definiert sind.
Die Attributberechnungen k\*onnen auch Seiteneffekte enthalten. Es
ist au\*serdem m\*oglich
k\*unstliche At\%tri\%but\%ab\%h\*an\%gig\%kei\%ten
zu definieren, um eine bestimmte
Auswertungsreihenfolge zu erzwingen, oder um bei einer Attributgrammatik die
von \%\fIAg\fP geforderte
Eigenschaft \%OAG [Kastens\|80] herbeizuf\*uhren, falls sie
diese noch nicht besitzt.
.sp 0.4v
.ne 2v
.ti +2n
Der in Kapitel \n(h1.2.2 beschriebene
Erweiterungsmechanismus f\*ur die Attribute und Kindknoten von Knotentypen gilt
auch f\*ur die Attributberechnungen. Abgeleitete Knotentypen erben die
Attributberechnungen ihrer Basistypen. Durch Angabe einer speziellen
Attributberechnung f\*ur den abgeleiteten Knotentyp kann die vererbte
Attributberechnung aber \*uberschrieben werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Abstrakte Datentypen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Abstrakte Datentypen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Dieses Kapitel enth\*alt eine kurze Beschreibung der wichtigsten abstrakten
Datentypen, die in der Attributgrammatik verwendet wurden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Spezifikation der Definitionstabelle und Bezeichneridentifikation\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Spezifikation der Definitionstabelle und Bezeichneridentifikation
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%\fIAst\fP wurde im \*Ubersetzer \%\fIMtc\fP nicht nur f\*ur
die Implementierung des Strukturbaums verwendet, sondern
auch f\*ur die Implementierung des Definitionstabellenmoduls \%\fIDefs\fP.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur jedes im Modula-Programm deklarierte Objekt sowie f\*ur alle
vordefinierten Objekte wird eine Objektbeschreibung angelegt, die
alle vorhandenen Informationen \*uber das Objekt enth\*alt.
Der
Knotentyp \%\fIObject\fP\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ In der abgebildeten Definition der
Objektbeschreibungen fehlen die Attribute f\*ur die Codeerzeugung (s. Kap.
\n(h1.5)
.nE
\& definiert die Struktur der Objektbeschreibungen:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
Object          = [Ident: tIdent] <
  Const1        = -> [Value: tValue] .
  EnumLiteral1  = Type [Index: SHORTCARD] .
  Field1        = Type .
  Module1       = ExportList: Objects -> Objects Locals: Objects .
  Proc1         = Type -> [IsExported: BOOLEAN] Locals: Objects .
  ProcHead1     = Type .
  TypeDecl1     = -> Type .
.br
.ne 3
  Var1          = Type [IsVAR: BOOLEAN] .
  ...
>.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Kindknoten bzw. Attribute, die rechts des Symbols \f(TT->\fP stehen,
werden als
,,non-input'' Attribute bezeichnet. Die Werte dieser Attribute werden beim
Aufbau der Objektbeschreibungen noch nicht festgelegt; es wird jedoch Speicherplatz f\*ur sie
reserviert, so da\*s ihr Wert zu einem sp\*ateren Zeitpunkt nachgetragen werden
kann.
Das Attribut \%\fIExportList\fP ist ein Ausschnitt der
vollst\*andigen Exportliste \%\fIObjects\fP eines Moduls und enth\*alt nur die von
diesem Modul exportierten Typnamen. Die Behandlung einiger Attribute als ,,non-input''
Attribute und die ,,doppelte'' Exportliste sind notwendig, da beim Aufbau
der Objekt- und Typbeschreibungen
zyklische Abh\*angigkeiten auftreten, die durch einen
schrittweisen Aufbau dieser Beschreibungen behandelt werden.
.sp 0.4v
.ne 2v
.ti +2n
Betrachtet man den folgenden Ausschnitt eines Modula-Programms, dann sieht man
sofort, da\*s die Typb\*aume der abstrakten Syntax in Modula-2
f\*ur eine Beschreibung der Typen innerhalb der Definitionstabelle
nur wenig geeignet sind:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
TYPE t1 = INTEGER; t2 = t1;
VAR  v1 : t1; v2 : t2;
.br
.ne 3
  ...
v1 := v2;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Typen der Variablen \%\fIv1\fP und \%\fIv2\fP sind identisch; aus den
Typb\*aumen f\*ur \%\fIt1\fP und \%\fIt2\fP ist dies aber nicht direkt ablesbar.
Daher werden f\*ur die Typen Typbeschreibungen aufgebaut,
deren Struktur \(em abgesehen von einigen
Vereinfachungen \(em mit der Struktur der Typb\*aume
\*ubereinstimmt, in denen aber
die Typnamen durch die Typbeschreibung dieser Typen ersetzt sind.
Neben Knotentypen f\*ur die Typkonstruktoren von \%Modula-2
existieren
auch Knotentypen f\*ur die Repr\*asentation von Grund- und Standardtypen sowie f\*ur eine Reihe
von speziellen Typen, die
nur intern im \*Ubersetzer verwendet werden und die keine direkte Entsprechung
in der Sprachdefinition von \%Modula-2 haben.
.sp 0.4v
.ne 2v
.ti +2n
Die Aufgabe der Bezeichneridentifikation ist es,
jedem angewandten Auftreten eines
Bezeichners das zugeh\*orige Objekt bzw. die zugeh\*orige Objektbeschreibung
zuzuordnen.
Die Sprachdefinition von \%Modula-2 legt durch ihre
G\*ultigkeitsbereichsregeln fest, wie die
Zuordnung zu treffen ist. \%Modula-2 ist eine blockstrukturierte Sprache
in der die G\*ultigkeitsbereiche der Bezeichner geschachtelt sind. Eine
Definition eines Bezeichners in einem inneren Block verdeckt die Definition
dieses Bezeichners in einem \*au\*seren Block.
In \%Modula-2 kommt zur
Blockstruktur noch das Modulkonzept hinzu, welches eine explizite Kontrolle der
G\*ultigkeitsbereiche von Bezeichnern
mit Hilfe von Import- und Exportanweisungen erm\*oglicht.
Innerhalb
der Attributgrammatik werden den Knotentypen der abstrakten
Syntax bei Bedarf
sogenannte Umgebungsattribute zugeordnet, welche die an der jeweiligen Stelle
g\*ultigen Definitionen repr\*asentieren.
Die Struktur der Umgebungsattribute wird in der \fIAst\fP\^-Spezifikation durch den
Knotentyp \%\fIEnv\fP beschrieben:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
Env = Objects HiddenEnv: Env .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
\%\fIObjects\fP sind die im aktuellen Block definierten Objekte,
\%\fIHiddenEnv\fP enth\*alt die in \*au\*seren Bl\*ocken definierten Objekte.
.sp 0.4v
.ne 2v
.ti +2n
Die Identifikation in der Attributgrammatik erfolgt durch den Aufruf der
ebenfalls im Modul \%\fIDefs\fP definierten Funktion
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
Identify : Ident \(mu Env \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Object .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
die jedem Bezeichner mit Hilfe des g\*ultigen Umgebungsattributs das
zugeh\*orige Objekt zuordnet.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Auswertung konstanter Ausdr\*ucke und Repr\*asentation ihrer Werte\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Auswertung konstanter Ausdr\*ucke und Repr\*asentation ihrer Werte
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Wie in Kapitel 4 erl\*autert, m\*ussen f\*ur die \*Ubersetzung nach C die
Werte einer Reihe von konstanten Ausdr\*ucken bekannt sein. Zu diesem Zweck
existiert der Modul \%\fIValues\fP, welcher Typdeklarationen zur Repr\*asentation
der Werte von konstanten Ausdr\*ucken und eine Operation f\*ur ihre Auswertung
enth\*alt. Den Objektbeschreibungen der Konstanten in der Definitionstabelle und
einigen Baumknoten wie z.B. den Fallmarken wird ein Attribut
zugeordnet, welches den Wert des zugeh\*origen konstanten Ausdrucks
repr\*asentiert. Die Funktion
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
CompConst : Tree \(mu Env \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Value .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
die in der Attributgrammatik aufgerufen wird, berechnet aus dem Baum f\*ur den
konstanten Ausdruck und der aktuell g\*ultigen Umgebung, die f\*ur den Zugriff
auf die Werte von benannten Konstanten ben\*otigt wird, den Wert des konstanten
Ausdrucks.
.sp 0.4v
.ne 2v
.ti +2n
Um den Aufwand f\*ur die Implementierung des Moduls \%\fIValues\fP zu reduzieren,
arbeitet \%\fIValues\fP nicht interpretativ, sondern mit einer direkten
Ausf\*uhrung der Operationen. Die meisten m\*oglichen Fehler, wie etwa Division
durch Null, werden aber durch entsprechende Abfragen abgefangen.
Arithmetische \*Uberl\*aufe werden allerdings nicht erkannt. Eine Auswertung von
Ausdr\*ucken, die ganzzahlige Konstanten im Bereich
\%MAX\^(INTEGER)\|+\|1 .. \%MAX\^(CARDINAL)
enthalten, ist nicht m\*oglich. \%\fICompConst\fP liefert in diesem Fall aber
einen definierten Wert zur\*uck, der dies anzeigt.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Operationen auf Typen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Operationen auf Typen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Definition der Typbeschreibungen und die Prozeduren f\*ur
ihren Aufbau sowie Prozeduren f\*ur den Zugriff auf in den Typbeschreibungen
enthaltene Informationen sind Teil des Moduls \%\fIDefs\fP.
.sp 0.4v
.ne 2v
.ti +2n
Der Modul \%\fITypes\fP enth\*alt alle
weiteren Informationen \*uber die Typen von \%Modula-2.
Dabei handelt es sich insbesondere um Operationen f\*ur die Typbestimmung in
Ausdr\*ucken.
.sp 0.4v
.ne 2v
.ti +2n
Au\*serdem enth\*alt
\%\fITypes\fP auch die meisten Details \*uber die Abbildung der Typen von
\%Modula-2 nach C, wie sie f\*ur die Codeerzeugung, insbesondere im
Zusammenhang mit der Erzeugung von expliziten Typumwandlungen, ben\*otigt
werden.
Die in Kapitel 4.4.1 erw\*ahnte Tabelle, die f\*ur eine Auswertung der
Standardfunktionen \%SIZE, \%TSIZE, \%MIN und \%MAX ben\*otigt
wird, ist ebenfalls Teil des Moduls \%\fITypes\fP.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Die Attributgrammatik\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Die Attributgrammatik
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die folgende Beschreibung der Attributgrammatik ist nur eine auszugsweise
Darstellung einiger interessanter Aspekte dieser Attributgrammatik.
Eine ausf\*uhrliche Darstellung der Spezifikation der semantischen
Analyse mit Attributgrammatiken und die L\*osung von typischen Problemen in
diesem Zusammenhang kann in [Waite\|84] gefunden werden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Aufbau der Definitionstabelle und Berechnung von Umgebungsattributen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Aufbau der Definitionstabelle und Berechnung von Umgebungsattributen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
In \%Modula-2 existieren eine Reihe von Regeln, die den Aufbau von Objekt-
und Typbeschreibungen und die Berechnung von Umgebungsattributen erschweren und
die dazu f\*uhren, da\*s die Objekt- und Typbeschreibungen nicht in einem
einzigen Schritt aufgebaut werden k\*onnen, da dies zu zyklischen
Abh\*angigkeiten in der Attributgrammatik f\*uhren w\*urde.
.sp 0.4v
.ne 2v
.ti +2n
Neben den ,,rekursiven'' Typdeklarationen (s. Kap. 4.3) ist hier
insbesondere die Tatsache zu nennen, da\*s in den Deklarationen eines Blocks
Typnamen verwendet werden k\*onnen, die im gleichen Block
textuell sp\*ater deklariert sind. Der
Aufbau von Objektbeschreibungen f\*ur die in einem Block deklarierten Objekte
erfordert daher ein Umgebungsattribut zur Identifikation
dieser Typnamen. F\*ur die Berechnung dieses Umgebungsattributs
werden aber umgekehrt die Objektbeschreibungen der
in diesem Block deklarierten Objekte ben\*otigt.
.sp 0.4v
.ne 2v
.ti +2n
Die L\*osung dieses Problems besteht darin, die Objekt- bzw. Typbeschreibungen
schrittweise aufzubauen und f\*ur die Deklarationen eine Reihe von
aufeinanderfolgenden Umgebungsattributen zu berechnen, die jeweils
etwas mehr Informationen \*uber die deklarierten Objekte enthalten.
.sp 0.4v
.ne 2v
.ti +2n
Da die meisten der oben genannten Probleme durch die Typdeklarationen entstehen,
werden
zuerst vorl\*aufige Objektbeschreibungen f\*ur die benannten Typen und
vollst\*andige Typbeschreibungen f\*ur alle Typknoten der abstrakten Syntax
aufgebaut, die in den Objektbeschreibungen verwendet werden k\*onnen.
.sp 0.4v
.ne 2v
.ti +2n
Zun\*achst wird f\*ur die Deklarationen aller Bl\*ocke ein Attribut
\%\fIObjects1\fP berechnet,
welches eine Liste von Objektbeschreibungen f\*ur Typen darstellt,
die
im Prinzip als einzige Information die im entsprechenden Block
deklarierten Typnamen
enth\*alt. In diese Objektliste werden f\*ur die Behandlung des Modulkonzepts
noch zus\*atzlich Objektbeschreibungen der
Moduln mit einer vorl\*aufigen Exportliste aufgenommen, die alle vom Modul
exportierten Typnamen umfa\*st.
Die Behandlung des Modulkonzepts
wird in einem der folgenden Abschnitte noch n\*aher erl\*autert.
Diese Objektlisten werden zu einem ersten
Umgebungsattribut \%\fIEnv1\fP kombiniert, welches in Typdeklarationen die
Zuordnung von Objektbeschreibungen zu den Typnamen erm\*oglicht.
Mit der Berechnung der beiden Attribute \%\fIObjects2\fP und \%\fIEnv2\fP
wird der Prozess des Aufbaus von Typbeschreibungen vervollst\*andigt. Wie das im
Detail funktioniert, wird im n\*achsten Kapitel beschrieben.
.sp 0.4v
.ne 2v
.ti +2n
Jetzt erst kann
eine Objektliste \%\fIObjects3\fP aufgebaut werden, die die
vollst\*andigen Objektbeschreibungen der Typen, Variablen, Prozeduren und Moduln
mit der kompletten Exportliste enth\*alt.
F\*ur die Konstanten fehlt in \%\fIObjects3\fP noch der
Wert der Konstanten, da hier ein \*ahnliches Problem wie f\*ur die
Typen auftritt. Zur Auswertung der Konstanten \%\fIa\fP in der folgenden
Deklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
CONST b = 1;
CONST a = b * 2;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird der Wert der Konstanten \%\fIb\fP ben\*otigt. Hier sind in \%Modula-2
die Probleme im Gegensatz zu den Typen nicht so gro\*s, da f\*ur die in
Konstantendeklarationen verwendeten Konstantennamen immer gelten
mu\*s, da\*s diese Namen textuell vor dieser Deklaration
definiert sein m\*ussen. Zyklische Abh\*angigkeiten der Konstantendeklarationen
k\*onnen daher in \%Modula-2 nicht auftreten.
.sp 0.4v
.ne 2v
.ti +2n
Mit der Objekliste \%\fIObjects3\fP wird die Umgebung
\%\fIEnv3\fP aufgebaut, die bis auf die Werte der Konstanten vollst\*andig
ist.
.sp 0.4v
.ne 2v
.ti +2n
Mit Hilfe der beiden
Attribute \%\fIObjects4In\fP und \%\fIObjects4Out\fP
wird schlie\*slich f\*ur die Deklarationen
aller Bl\*ocke eine weitere Objektliste aufgebaut, wobei die
zu den Konstantendeklarationen dazugeh\*origen
konstanten Ausdr\*ucke in der textuellen Reihenfolge der Deklarationen
mit Hilfe der Umgebung \%\fIEnv3\fP und der Funktion \%\fICompConst\fP
ausgewertet werden. Die Werte der Konstanten
werden dabei in deren Objektbeschreibungen \*ubernommen.
.sp 0.4v
.ne 2v
.ti +2n
Mit der Objektliste \%\fIObjects4Out\fP kann jetzt die vollst\*andige Umgebung
\%\fIEnv4\fP berechnet werden, die in den Anweisungen f\*ur die
Bezeichneridentifikation verwendet wird.
.sp 0.4v
.ne 2v
.ti +2n
Vorstehend war die Rede von schrittweisem Aufbau der Objekt- und
Typbeschreibungen.
In der Attributgrammatik werden selbstverst\*andlich
jeweils neue Attribute berechnet, die den bei diesem schrittweisen Aufbau
entstehenden Teilergebnissen entsprechen.
Durch die M\*oglichkeit von kontrollierten Seiteneffekten und dem Einsatz von
Zeigertypen (abstrakte Datentypen) f\*ur die Attributwerte, k\*onnen aber
vorhandene Beschreibungen erweitert werden.
Damit entf\*allt die Notwendigkeit mehrere
Objekt- bzw. Typbeschreibungen f\*ur das gleiche Objekt bzw. den gleichen Typ
aufbauen und eventuell noch eine gemeinsame
Repr\*asentation f\*ur diese finden zu m\*ussen. Au\*serdem wird
die Implementierung hinsichtlich Laufzeit
und Speicherbedarf effizienter. Der Nachteil dieser L\*osung ist allerdings,
da\*s man sich wegen der Seiteneffekte \*uber die
At\%tri\%but\%ab\%h\*an\%gig\%kei\%ten und
die Auswertungsreihenfolge Gedanken machen mu\*s und eventuell
geeignete Attribute und
At\%tri\%but\%ab\%h\*an\%gig\%kei\%ten einf\*uhren mu\*s,
die nur die Aufgabe haben, eine bestimmte
Auswertungsreihenfolge der Attribute und damit eine korrekte
Reihenfolge der Seiteneffekte zu erzwingen.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Aufbau von Typbeschreibungen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Aufbau von Typbeschreibungen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Allen Typknoten der abstrakten Syntax wird in der Attributgrammatik eine
Typbeschreibung als abgeleitetes Attribut zugeordnet. Um die oben genannten
zyklischen Abh\*angigkeiten der Typbeschreibungen behandeln zu k\*onnen,
erfolgt deren Aufbau in zwei Schritten.
Das Attribut \%\fIType2\fP ist die vollst\*andige Typbeschreibung; ein weiteres
Attribut \%\fIType1\fP ist eine vorl\*aufige und unvollst\*andige Typbeschreibung,
welche w\*ahrend des Aufbaus der vollst\*andigen Typbeschreibungen als
Zwischenergebnis auftritt.
.sp 0.4v
.ne 2v
.ti +2n
Folgender Ausschnitt der Attributgrammatik demonstriert den Proze\*s des Aufbaus
von Typbeschreibungen (vgl. Anh. A):
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
Type    = { Type2 AFTER Env2;                              } .
Pointer = { Type1  := mPointer1 ();
            Type2  := mPointer2 (Type1, TargetType:Type2); } .
.br
.ne 3
TypeId0 = { Object := Identify (Ident, Env1);
            Type1  := mQualident1 (Object);
            Type2  := GroundType (Type1);                  } .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die oben beschriebene Umgebung \%\fIEnv1\fP erm\*oglicht es,
den Typnamen die zugeh\*origen Objektbeschreibungen zuzuordnen, die
allerdings noch keine Typbeschreibung f\*ur den Typ enthalten.
\%\fIQualident1\fP bildet eine vorl\*aufige
Typbeschreibung f\*ur Typnamen, die einen Verweis auf die Objektbeschreibung des
Typnamens enth\*alt.
F\*ur andere Typknoten wird eine vorl\*aufige
Typbeschreibung angelegt, die zwar der endg\*ultigen Typbeschreibung entspricht,
die aber nur die Information enth\*alt, um welche Art von Typ es sich
handelt.
Die \*ubrigen Informationen \*uber den Typ, wie z.B. bei Zeigertypen der
Bezugstyp, werden als ,,non-input'' Attribute behandelt.
.sp 0.4v
.ne 2v
.ti +2n
In einem vollst\*andigen
Durchlauf durch alle Deklarationen
des Programms werden die vorl\*aufigen Typbeschreibungen
\%\fIType1\fP in die Objektbeschreibungen der benannten
Typen aufgenommen (Berechnung des
Attributs \%\fIObjects2\fP). \%\fIObjects2\fP wird f\*ur die Berechnung eines
zweiten ,,Umgebungsattributs'' \%\fIEnv2\fP verwendet, dessen einzige Funktion es
ist,
At\%tri\%but\%ab\%h\*an\%gig\%kei\%ten
zu definieren, die garantieren,
da\*s die vollst\*andigen Typbeschreibungen
\%\fIType2\fP erst berechnet werden, wenn alle vorl\*aufigen Typbeschreibungen
in die Objektbeschreibungen der benannten Typen eingetragen wurden. Wegen der
k\*unstlichen
At\%tri\%but\%ab\%h\*an\%gig\%keit
\%\fIType2\fP\ AFTER\ \fIEnv2\fP
wird \%\fIType2\fP erst nach \%\fIEnv2\fP berechnet.
.sp 0.4v
.ne 2v
.ti +2n
Mit Hilfe der im Modul \%\fIDefs\fP definierten Funktion \%\fIGroundType\fP kann
man dann aus der vorl\*aufigen Typbeschreibung eines Typnamens die endg\*ultige
Typbeschreibung dieses Typs bestimmen. \%\fIGroundType\fP ist folgenderma\*sen
definiert (vereinfacht ohne Fehlerbehandlung):
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
PROCEDURE GroundType    (Type: tType): tType;
BEGIN
  IF Type^.Kind = Qualident1 THEN
    RETURN GroundType (Type^.Qualident1.Object^.TypeDecl1.Type);
  END;
.br
.ne 2
  RETURN Type;
END GroundType;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Durch rekursive Aufrufe werden die Typ- bzw. Objektbeschreibungen
solange traversiert bis eine Typbeschreibung f\*ur einen Typnamen
gefunden wird, die keine vorl\*aufige Typbeschreibung der Form
\%\fIQualident1\fP ist
(Typgleichsetzungen k\*onnen \*uber eine beliebige Anzahl von Stufen geschrieben
werden). \%\fIGroundType\fP liefert die so gefundene Typbeschreibung
f\*ur den Typnamen an den Aufrufer zur\*uck.
.sp 0.4v
.ne 2v
.ti +2n
Der Aufbau der vollst\*andigen Typbeschreibung \%\fIType2\fP
erfolgt dann schlie\*slich dadurch, da\*s die noch fehlenden Informationen, wie
z.B. bei Zeigertypen die Typbeschreibung des Bezugstyps
\%\fITargetType\fP:\fIType2\fP, in die
vorl\*aufige Typbeschreibung \%\fIType1\fP eingetragen wird.
Diese vollst\*andigen Typbeschreibungen k\*onnen dann bei der Berechnung des
Attributs \%\fIObjects3\fP in die Objektbeschreibungen der benannten Typen
aufgenommen und als Typbeschreibung in den Objektbeschreibungen der
Variablen, Prozeduren, usf. verwendet werden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Behandlung des Modulkonzepts\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Behandlung des Modulkonzepts
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Zus\*atzlich zur Blockstruktur erm\*oglicht \%Modula-2 mit dem
Modulkonzept eine explizite Kontrolle des G\*ultigkeitsbereichs von Bezeichnern
durch Import- bzw. Exportanweisungen. Eine wichtige Sonderregel in diesem
Zusammenhang ist, da\*s mit dem Import- bzw. Export eines Aufz\*ahlungstyps auch
automatisch die zugeh\*origen Aufz\*ahlungsliterale importiert bzw. exportiert
werden. Die vordefinierten Objekte von \%Modula-2 m\*ussen nicht explizit
importiert werden, sondern sind automatisch in jedem Modul sichtbar. Bei der
Behandlung von Implementierungsmoduln mu\*s au\*serdem beachtet werden, da\*s alle
im zugeh\*origen Definitionsmodul definierten Konstanten, Typen und Variablen
im Implementierungsmodul ebenfalls automatisch sichtbar sind.
.sp 0.4v
.ne 2v
.ti +2n
Der folgende Ausschnitt der Attributgrammatik zeigt, wie die oben genannten
Regeln in der
Attributgrammatik behandelt werden (vgl. Anh. A):
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 5
ProgMod = { Import:Env2 := Env3;
            DefObjects3 := Filter (GetExport2 (Identify (Ident, Env3)));
            Decls:Env3  :=
              mEnv (UNION (UNION (UNION (Predefs, Import:Objects2),
                    Decls:Objects3), DefObjects3), NoEnv);            } .
From    = { Object2     := Identify (Ident, Env2);
            ImpIds:Env2 := mEnv (GetExport2 (Object2), NoEnv);
            Objects2    := UNION (ImpIds:Objects2, Next:Objects2);    } .
ImpIds1 = { Object2     := Identify (Ident, Env2);
            Type        := GetType (Object2);
            Objects2    := {
          IF (Object2^.Kind = TypeDecl1   ) AND
             (Type^.Kind    = Enumeration1) THEN
            Objects2    :=
              mElmt (Ident, Object2, UNION (Type^.Enumeration1.Objects,
                     Next:Objects2));
          ELSE
.br
.ne 2
            Objects2    := mElmt (Ident, Object2, Next:Objects2);
          END;          };                                            } .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Das Attribut \%\fIDefObjects3\fP ist eine Objektliste, welche die im zum
Implementierungsmodul dazugeh\*origen Definitionsmodul definierten Konstanten,
Typen und Variablen enth\*alt. Die Berechnung erfolgt dadurch, da\*s in der
Umgebung des Implementierungsmoduls zun\*achst durch einen Aufruf von
\%\fIIdentify\fP die Objektbeschreibung des (De\%fi\%ni\%ti\%ons-)Mo\%duls bestimmt
und aus dieser dann die Liste der exportierten Objekte entnommen wird. Da diese
Exportliste zun\*achst noch die Definition von Prozedurk\*opfen und opaquen Typen
enth\*alt, die im Implementierungsmodul redeklariert werden m\*ussen, wird mit
Hilfe der im Modul \%\fIDefs\fP definierten Funktion \%\fIFilter\fP eine neue
Objektliste aufgebaut, die diese nicht mehr enth\*alt.
.sp 0.4v
.ne 2v
.ti +2n
In einer Importanweisung der Form
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
FROM Module IMPORT Object1, ... , Objectn;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
ist die f\*ur den Bezeichner \%\fIModule\fP g\*ultige Umgebung, die Umgebung des
Moduls, der die Importanweisung enth\*alt. Die Umgebung der Bezeichner
\%\fIObject1\fP bis \%\fIObjectn\fP ergibt sich aus der Liste der
Objekte, die von \%\fIModule\fP exportiert werden.
Diese Tatsache wird im obigen Ausschnitt der
Attributgrammatik durch die Attributierungsregeln zur Berechnung der
Umgebungsattribute \%\fIImport\fP:\fIEnv2\fP und \%\fIImpIds\fP:\fIEnv2\fP
reflektiert.
.sp 0.4v
.ne 2v
.ti +2n
Die importierten Objekte werden in der Objektliste \%\fIObjects2\fP
gesammelt. Die Attributierungsregeln f\*ur den Knotentyp \%\fIImpIds1\fP zeigen
dabei, wie der implizite Import von Aufz\*ahlungsliteralen behandelt wird.
.sp 0.4v
.ne 2v
.ti +2n
Die Umgebung \%\fIEnv3\fP der Deklarationen des
Implementierungsmoduls
ergibt sich schlie\*slich aus einer Vereinigung der vordefinierten
Objekte \%\fIPredefs\fP, der explizit importierten Objekte
\%\fIImport\fP:\fIObjects2\fP, der Objekte aus dem Definitionsmodul
\%\fIDefObjects3\fP und aus den lokal deklarierten Objekten
\%\fIDecls\fP:\fIObjects3\fP. Die Tatsache, da\*s die \*au\*sere Umgebung eines
Moduls vollst\*andig verdeckt wird, ist aus der Verwendung der leeren Umgebung
\%\fINoEnv\fP als \*au\*sere Umgebung des Moduls im Aufruf von \%\fImEnv\fP zu
entnehmen.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Typbestimmung in Ausdr\*ucken\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Typbestimmung in Ausdr\*ucken
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Den Ausdr\*ucken wird ein abgeleitetes Attribut \%\fIType\fP zugeordnet, welches
den Typ des Ausdrucks beschreibt. Die Berechnung dieses Attributs erfolgt, wie
der folgende Beispielausschnitt der Attributgrammatik zeigt (vgl.  Anh. A),
mit Hilfe der in
\%\fITypes\fP definierten Operationen auf Typen und den in \%\fIDefs\fP enthaltenen
Operationen f\*ur den Zugriff auf Objekt- und Typbeschreibungen.
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
Binary    = { Type := ResultType (Operator, Lop:Type, Rop:Type);  } .
RealConst = { Type := TypeREAL;                                   } .
Qualid0   = { Type := GetType (Object);                           } .
Subscript = { Type := GetElemType (Designator:Type);              } .
Deref     = { Type := GetTargetType (Designator:Type);            } .
FuncCall  = { Type := {
            IF Designator:Type^.Kind = StdProcType1 THEN
              Type := StdResultType (Designator:Type, Actuals:Types);
            ELSIF Designator:Type^.Kind = ProcType1 THEN
              Type := GetResultType (Designator:Type);
            ELSE /* may be a type transfer function  */
.br
.ne 2
              Type := Designator:Type;
            END;   };                                             } .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die in \%\fITypes\fP definierte Funktion \%\fIStdResultType\fP ermittelt aus dem
Typ einer Standardprozedur und den Typen der aktuellen Parameter
den Resultattyp des Aufrufs dieser Standardprozedur. Die
Typen der aktuellen Parameter sind notwendig, da ein Teil der
Standardprozeduren wie z.B. \%ABS, \%MIN und \%MAX in
\%Modula-2 \*uberladen sind.
.sp 0.4v
.ne 2v
.ti +2n
Die Typen der Ausdr\*ucke werden
f\*ur die Codeerzeugung ben\*otigt, um z.B. den korrekten
C-Operator f\*ur \*uberladene Modula-Operatoren einsetzen zu k\*onnen.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Berechnung von Attributen f\*ur die Codeerzeugung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Berechnung von Attributen f\*ur die Codeerzeugung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
F\*ur die Durchf\*uhrung der Codeerzeugung m\*ussen weitere Informationen \*uber
das Quellprogramm abgeleitet werden, die \*uber die in der semantischen Analyse
berechneten Attribute hinausgehen und die f\*ur eine korrekte \*Ubersetzung
nach C ben\*otigt werden. Diese
Attributberechnungen sind ebenfalls Teil der im vorigen Kapitel beschriebenen
Attributgrammatik.
.sp 0.4v
.ne 2v
.ti +2n
Zur besseren Gliederung der Attributgrammatik erm\*oglicht \%\fIAg\fP deren
Unterteilung in sogenannte Moduln, die es erlauben, logisch zusammengeh\*orige
Attributdeklarationen und die
zugeh\*origen Attributberechnungen auch textuell zusammenzufassen.
Daher sind die Attributberechnungen
f\*ur die semantische Analyse und die Berechnung von Attributen f\*ur die
Codeerzeugung textuell eindeutig getrennt. Diese Trennung erleichtert eine
eventuelle Wiederverwendung des Front-Ends von \%\fIMtc\fP.
.sp 0.4v
.ne 2v
.ti +2n
Die Trennung der
Attributberechnungen in semantische Analyse und Berechnung von Attributen f\*ur
die Codeerzeugung ist auf den ersten Blick teilweise etwas willk\*urlich,
da z.B. die in der
semantischen Analyse bestimmten Typen der Ausdr\*ucke auch f\*ur die
Codeerzeugung ben\*otigt werden. Die Unterscheidung wurde aber auf folgender
Basis getroffen: Alle Attribute, die auch ben\*otigt w\*urden, falls man die
semantische Korrektheit der Modula-Programme \*uberpr\*ufen wollte, werden zur
semantischen Analyse gez\*ahlt. Alle anderen Attribute, die ausschlie\*slich f\*ur
eine \*Ubersetzung nach C notwendig sind, z\*ahlen zu den Attributen f\*ur die
Codeerzeugung. Im Folgenden sollen die wichtigsten dieser
Attribute \*ubersichtsartig vorgestellt werden.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur die Operatoren der Sprache \%Modula-2 ist eine Operatoridentifikation
notwendig, da eine Reihe von Operatoren in \%Modula-2 \*uberladen sind und
daher auf unterschiedliche C-Operatoren abgebildet werden m\*ussen. Die
Knotentypen, welche die Operatoren als Attribute enthalten (vgl. Anh. A),
erhalten daher ein Attribut
\%\fICOperator\fP, welches den zugeh\*origen C-Operator beschreibt. Die
Berechnung dieses Attributs erfolgt mit Hilfe des Modula-Operators und den
Typen der Operanden des zugeh\*origen Ausdrucks.
.sp 0.4v
.ne 2v
.ti +2n
Wie in Kapitel 4 erl\*autert, mu\*s f\*ur eine Reihe
von Modula-Ausdr\*ucken bekannt
sein, ob diese Ausdr\*ucke in C konstant sind. Sie erhalten daher ein
boolesches Attribut \%\fIIsCConst\fP.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur die \*Ubersetzung des Zugriffs auf lokale Variablen von statisch umfassenden
Prozeduren nach C (s. Kap. 4.4.4) existieren die folgenden
Attribute:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Das boolesche Attribut \%\fIIsGlobalPtr\fP wird jedem Bezeichner
in Ausdr\*ucken oder Anweisungen zugeordnet. Das Attribut ist wahr, falls der
Bezeichner eine lokale Variable einer statisch umfassenden Prozedur bezeichnet
und daher der Zugriff in C mit Hilfe einer globalen Zeigervariablen realisiert
werden mu\*s.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Das Attribut \%\fILocalPtrs\fP, welches jeder Deklaration einer
Prozedur \%\fIp\fP
zugeordnet wird, ist eine Liste aller lokalen Variablen von \%\fIp\fP, die in
lokal zu \%\fIp\fP deklarierten Prozeduren benutzt werden.
Es wird ben\*otigt, um f\*ur die nach C \*ubersetzte Prozedur \%\fIp\fP den
entsprechenden \%Code f\*ur eine Realisierung des Zugriffs auf diese lokalen
Variablen zu erzeugen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Programm- und Implementierungsmoduln wird ein Attribut \%\fIGlobalPtrs\fP
zugeordnet, welches eine Vereinigung der Attribute \%\fILocalPtrs\fP ist und
f\*ur die Erzeugung der oben erw\*ahnten
globalen Zeigervariablen benutzt wird.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die \*Ubersetzung der varianten Teile der Verbunde nach C erfordert die
Berechnung von zus\*atzlichen Komponentenselektoren (s. Kap. 4.4.2.7). Die
entsprechenden Selektoren werden den varianten Teilen der Verbunde im
Strukturbaum zugeordnet und auch in die Objektbeschreibungen der zugeh\*origen
Verbundkomponenten \*ubernommen, um Zugriffe auf diese
Komponenten korrekt \*ubersetzen zu k\*onnen.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Umbenennung von Bezeichnern\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Umbenennung von Bezeichnern
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
In Kapitel 4 wurde ausf\*uhrlich dargelegt, welche Bezeichner im
C-Programm f\*ur die Modula-Objekte verwendet werden. Es wurden im wesentlichen
2 F\*alle unterschieden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Bezeichner eines von einem globalen Modul
exportierten Objekts wird in C in der
qualifizierten Form \%\fIModulname_Bezeichner\fP geschrieben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle \*ubrigen Bezeichner werden direkt aus dem Modula-Programm
\*ubernommen, werden aber bei Bedarf zur Vermeidung von Namenskonflikten mit
einem Pr\*afix \%\fIC_nnn_\fP versehen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
In der Attributgrammatik wird f\*ur jedes im Modula-Programm deklarierte Objekt
ein Attribut \%\fICIdent\fP berechnet,
welches den C-Bezeichner dieses Objekts darstellt. Dieser Bezeichner mu\*s auch
in die Objektbeschreibung \*ubernommen werden, um bei jedem angewandten
Auftreten des Bezeichners den richtigen C-Bezeichner einsetzen zu
k\*onnen.
.sp 0.4v
.ne 2v
.ti +2n
Zur Entdeckung und Vermeidung von m\*oglichen Namenskonflikten
existiert der Modul \%\fIUniqueIds\fP, welcher die Verwaltung der im
C-Programm verwendeten unqualifizierten Bezeichner
entsprechend den G\*ultigkeitsbereichsregeln der Sprache C \*ubernimmt.
Qualifizierte Bezeichner der Form \%\fIModulname\fP_\fIBezeichner\fP
brauchen nicht von
\%\fIUniqueIds\fP verwaltet zu werden, da f\*ur sie auf Grund der Eindeutigkeit
von globalen Modulnamen keine Namenskonflikte entstehen k\*onnen.
Die wichtigsten Operationen des Moduls \%\fIUniqueIds\fP sind:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
NameConflict : Ident \(mu IdentClass \(mu Idents \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' BOOLEAN .
DeclareIdent : Ident \(mu IdentClass \(mu Idents \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Idents .
.br
.ne 2
EnterProc    : Idents \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Idents .
LeaveProc    : Idents \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Idents .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
\%\fINameConflict\fP \*uberpr\*uft, ob die
Verwendung eines bestimmten Bezeichners zu einem Namenskonflikt mit einem
bereits verwendeten Bezeichner f\*uhren w\*urde. \%\fIDeclareIdent\fP deklariert
einen Bezeichner als im C-Programm verwendet. \%\fIEnterProc\fP und
\%\fILeaveProc\fP werden zu Beginn und am Ende der Behandlung der lokalen
Deklarationen einer Prozedur aufgerufen.
.sp 0.4v
.ne 2v
.ti +2n
Die Bezeichner werden entsprechend ihrer Art bzw.
der Art des zugeh\*origen Objekts in folgende Klassen eingeteilt (vgl. Kap. 4):
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Schl\*usselw\*orter: \%\fIUniqueIds\fP behandelt eine Reihe von
Bezeichnern als Schl\*usselw\*orter (Bezeichner f\*ur vom \*Ubersetzer
vordefinierte Objekte und Schl\*usselw\*orter der Sprache C).
\%\fINameConflict\fP liefert f\*ur einen Schl\*usselwortbezeichner
immer wahr, was dazu f\*uhrt, da\*s der Bezeichner auf jeden Fall durch einen
Pr\*afix umbenannt wird.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Konstanten- und Typbezeichner, die im C-Programm
innerhalb einer Quelldatei nur genau einmal auftreten d\*urfen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Prozedurbezeichner: alle Prozedurbezeichner sind in C globale
Bezeichner.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bezeichner von Verbundkomponenten.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Variablenbezeichner, die nicht in lokalen Moduln deklariert sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Variablenbezeichner, die in lokalen Moduln deklariert sind.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die Variablen, die in einem in \%Modula-2
lokal zu einer Prozedur deklarierten Modul enthalten sind,
werden in C zu lokalen Variablen
dieser Prozedur. Im folgenden Beispiel
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
PROCEDURE p;
  ...
PROCEDURE q;
  MODULE l;
    ...
    VAR p: INTEGER;
    ...
  END l;
.br
.ne 3
BEGIN
  p;
END q;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
mu\*s bei der \*Ubersetzung nach C die lokale Variable \%\fIp\fP (in
C lokal zu \%\fIq\fP deklariert) umbenannt werden,
da sonst der globale Prozedurbezeichner \%\fIp\fP im Rumpf von
\%\fIq\fP verdeckt w\*urde. Aus diesem
Grund werden in lokalen Moduln deklarierte Variablen von \%\fIUniqueIds\fP immer
behandelt, als w\*urde in C f\*ur diese Variablen sowohl eine lokale Deklaration
in der entsprechenden Prozedur als auch eine globale Deklaration existieren.
Diese Behandlung f\*uhrt dazu, da\*s im obigen Beispiel die Variable \%\fIp\fP
umbenannt wird, da im gleichen G\*ultigkeitsbereich bereits der
Prozedurbezeichner \%\fIp\fP deklariert wurde.
Bei einer Behandlung von \%\fIp\fP ausschlie\*slich als lokale
Variable von \%\fIq\fP w\*urde
kein Namenskonflikt entdeckt, da \%\fIUniqueIds\fP nur Informationen \*uber die
Deklaration der Bezeichner und nicht auch \*uber deren Anwendung enth\*alt.
F\*ur in \%Modula-2 lokal in einer Prozedur deklarierte Variablen
kann das Problem nicht auftreten, da sowohl in \%Modula-2
als auch in C identische globale Bezeichner
durch diese Deklaration verdeckt werden.
.sp 0.4v
.ne 2v
.ti +2n
Die meisten Operationen des Moduls \%\fIUniqueIds\fP haben einen Seiteneffekt.
In der Attributgrammatik garantieren die beiden Attribute \%\fIIdsIn\fP und
\%\fIIdsOut\fP, welche die jeweils aktuelle Menge von
C-Bezeichnern repr\*asentieren, da\*s diese Seiteneffekte in der richtigen
Reihenfolge ausgef\*uhrt werden und insbesondere, da\*s der C-Bezeichner
\%\fICIdent\fP zum richtigen Zeitpunkt berechnet wird.
Der gro\*se Vorteil dieser L\*osung mit Seiteneffekten ist, da\*s die Operationen
des Moduls
\%\fIUniqueIds\fP sehr zeit- und speichereffizient programmiert werden k\*onnen.
Insbesondere ist der Aufwand f\*ur \%\fINameConflict\fP und \%\fIDeclareIdent\fP
in der Gr\*o\*senordnung \%O(1).
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Codeerzeugung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Codeerzeugung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Eingabe f\*ur die Codeerzeugung ist der attributierte Strukturbaum des
Modula-Programms, der alle f\*ur die \*Ubersetzung nach C notwendigen
semantischen Informationen enth\*alt. Die Ausgabe
der Codeerzeugung ist ein C-Programm bzw. eine C-Definitionsdatei f\*ur die
aktuelle \*Ubersetzungseinheit.
.sp 0.4v
.ne 2v
.ti +2n
Durch Angabe einer Option kann man
\%\fIMtc\fP dazu veranlassen, auch Definitionsdateien f\*ur alle
transitiv importierten Definitionsmoduln zu erzeugen. Diese Option ist
insbesondere dann n\*utzlich, wenn man \(em
z.B. f\*ur Testzwecke \(em zun\*achst nur einen
einzelnen Implementierungs- oder Programmodul nach C \*ubersetzen und diesen
dann vom C-\*Ubersetzer in ein Objektprogramm \*ubersetzen lassen m\*ochte.
F\*ur diese
\*Ubersetzung ben\*otigt der C-\*Ubersetzer die Definitionsdateien aller transitiv
importierten Definitionsmoduln, da diese mit \fI#include\fP\^-An\%wei\%sun\%gen in das
C-Programm eingef\*ugt werden. Durch die oben genannte Option wird es
\*uberfl\*ussig diese Definitionsmoduln einzeln nach C zu \*ubersetzen;
insbesondere braucht man nicht m\*uhsam abzuleiten, welche
(De\%fi\%ni\%ti\%ons-)Mo\%duln
denn tats\*achlich importiert werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Spezifikation des Codegenerators\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Spezifikation des Codegenerators
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Codegenerator, der im Modul \%\fICode\fP enthalten ist, wurde mit Hilfe des
Generators \%\fIEstra\fP [Vielsack\|89]
aus einer formalen Spezifikation der Codeerzeugung
generiert. \%\fIEstra\fP ist ein Werkzeug f\*ur die Spezifikation und
Implementierung der Transformation von attributierten B\*aumen. Im Folgenden
wird kurz darauf eingegangen, wie eine solche Spezifikation und die
daraus abgeleitete Implementierung im Prinzip aussehen. Die Spezifikation
der Codeerzeugung wird nicht
im Detail er\*ortert, da es sich dabei lediglich um eine Umsetzung der
in Kapitel
4 verbal beschriebenen Abbildung von \%Modula-2 nach C in eine
formale Spezifikation f\*ur \%\fIEstra\fP handelt.
.sp 0.4v
.ne 2v
.ti +2n
Die Beschreibung der Transformation besteht im wesentlichen aus zwei Teilen:
Einer Baumgrammatik, welche die Struktur der zu transformierenden B\*aume
beschreibt und einer oder mehreren Funktionen, die die Abbildung der B\*aume
beschreiben. Eine Funktion besteht aus der Festlegung des
Definitionsbereichs, aus einer Angabe von synthetisierten und
vererbten Attributen sowie aus Vorschriften wie die
Transformation durchgef\*uhrt werden soll. Der Definitionsbereich legt fest, auf
welche Knotentypen die Funktion anwendbar ist. Die Vorschriften, die
die Abbildung im Einzelnen festlegen, bestehen aus
einem Muster, welches angibt auf welche
Teilb\*aume die betreffende Vorschrift angewandt werden kann
und aus Anweisungen, die
festlegen wie der Teilbaum behandelt werden soll. Diese Anweisungen
k\*onnen insbesondere Aufrufe von Funktionen f\*ur die Transformation von
Unterb\*aumen enthalten. Die Anwendbarkeit bestimmter Vorschriften kann durch
Bedingungen eingeschr\*ankt werden. Damit wird es m\*oglich, die vom
Attributauswerter berechneten semantischen Informationen
f\*ur die Festlegung der Transformation zu ber\*ucksichtigen.
F\*ur eine Aufl\*osung von Mehrdeutigkeiten dient die Angabe von Kosten f\*ur die
Anwendung von Vorschriften. Werden diese Kosten durch eine Konstante
festgelegt, so ergeben sich die Kosten der Anwendung einer Vorschrift aus der
Summe dieser Konstanten und den Kosten der Funktionsaufrufe f\*ur die
Transformation der Unterb\*aume, die in
den Anweisungen enthalten sind. Wird dies nicht gew\*unscht, so besteht auch die
M\*oglichkeit die Kosten durch einen Ausdruck der Quellsprache (in
geschweiften Klammern) direkt
festzulegen. Bei der Transformation wird immer die kosteng\*unstigste
Vorschrift angewandt.
.sp 0.4v
.ne 2v
.ti +2n
Folgender Ausschnitt der Funktion f\*ur die Spezifikation der Codeerzeugung
f\*ur Ausdr\*ucke
soll obenerw\*ahntes noch einmal erl\*autern:
.br
.ne 2
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
FUNCTION CodeExpr  Prec: SHORTCARD  ->  /Expr, Elems/
  ...
.br
.ne 3
Subscript   (Qualid0 (), Index: Expr)
            CONDITION { IsOpenArray (Qualid0.Object) }
            COSTS { 1 }
.br
.ne 4
{
    CodeExpr (Qualid0, pSubscript); @[@ CodeExpr (Index, pMinPrec); @]@
}
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Das vererbte Attribut \%\fIPrec\fP ist der C-Vorrang des Operators im
Vaterausdruck und wird ben\*otigt, um die Ausdr\*ucke in C korrekt zu klammern.
Da die Indexoperation in C den h\*ochsten Vorrang hat, ist in obigem Beispiel
eine Klammerung nicht notwendig. Die Bedingung in der Vorschrift schr\*ankt
ihre Anwendbarkeit auf offene Felder ein (vgl. Kap.
4.5.1). Die Anweisungen legen die Abbildung des Zugriffs auf offene Felder
fest und enthalten Funktionsaufrufe f\*ur die Transformation der Unterb\*aume.
\%@[@ ist eine Anweisung f\*ur einen Pr\*aprozessor, der
f\*ur eine bessere Lesbarkeit der Spezifikation und zur Vereinfachung der
Schreibweise f\*ur Anweisungen zur Ausgabe von C-Programmtext mit Hilfe des
Zeileneditors \%\fIsed\fP implementiert wurde,
die in \%WriteC\ (f,\ '['); umgesetzt wird.
.sp 0.4v
.ne 2v
.ti +2n
Da die meisten Attribute bereits vom Attributauswerter berechnet werden, wird
von der von \%\fIEstra\fP angebotenen M\*oglichkeit f\*ur die Attribut\ierung nur
wenig Gebrauch gemacht. Eine
unterschiedliche Transformation bestimmter Knotentypen, abh\*angig vom Ort des
zugeh\*origen Teilbaums, wie z.B. die unterschiedliche Abbildung von
Deklarationen in Definitionsmoduln bzw. Implementierungs- und Programmoduln
(s. Kap. 4.8) oder auch die mehrfache Transformation eines Teilbaums
auf unterschiedliche Art und Weise, wie sie z.B. f\*ur die Umordnung der
Deklarationen (s. Kap. 4.3) ben\*otigt wird, wird dadurch erreicht,
da\*s f\*ur jede dieser
unterschiedlichen Transformationen eine eigene Funktion existiert, die dann an
den entsprechenden Stellen aufgerufen wird.
.sp 0.4v
.ne 2v
.ti +2n
Die Spezifikation des Codegenerators wird von \%\fIEstra\fP in eine
Implementierung umgesetzt. Diese Implementierung f\*uhrt die Transformation in
zwei Schritten durch. Zun\*achst wird in einem vorbereitenden
Schritt festgelegt, welche
Vorschriften f\*ur die Transformation des vorhandenen Baums anzuwenden sind.
Dazu wird bei einem Bottom-Up-Baumdurchlauf gepr\*uft, welche Muster auf
welche Knoten (Teilb\*aume) passen und ob die
zugeh\*origen Bedingungen erf\*ullt sind. F\*ur jede existierende Funktion wird
aus den anwendbaren Vorschriften diejenige mit den geringsten Kosten
ausgew\*ahlt und im Knoten zusammen mit ihren Kosten festgehalten. Die
eigentliche Durchf\*uhrung der Transformation erfolgt im zweiten Schritt durch
Anwendung der ersten Funktion auf die Wurzel des Baums. Die Transformation
erfolgt dann unter Ber\*ucksichtigung der im ersten Schritt festgelegten
Vorschriften durch Ausf\*uhrung der in den Anweisungen dieser
Vorschriften enthaltenen Funktionsaufrufe f\*ur die Teilb\*aume.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\& Nachoptimierung des Codegenerators\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\& Nachoptimierung des Codegenerators
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%\fIEstra\fP ist ein im Rahmen einer Diplomarbeit entwickelter
Prototyp. Die Spezifikation des Codegenerators von \%\fIMtc\fP war die erste
gr\*o\*sere Anwendung von \%\fIEstra\fP und es lagen aus diesem Grund
bisher noch keine
praktischen Erfahrungen mit gro\*sen Anwendungen vor. Nachdem eine erste
(Teil-)Spezifikation der Codeerzeugung vorlag, ergaben Tests,
da\*s der von \%\fIEstra\fP aus dieser Spezifikation erzeugte
Codegenerator einen
extrem hohen Speicherbedarf besa\*s, der trotz der
heutigen relativ gro\*sen Hauptspeichergr\*o\*sen f\*ur gro\*se Eingabeprogramme
einen Trashing-Effekt zur Folge hatte. Der hohe Hauptspeicherbedarf ergibt sich
daraus, da\*s der Codegenerator bei der Vorbereitung der
Transformation (s. Kap. \n(h1.\n(h2.1)
in jedem Knoten f\*ur jede existierende
Funktion die anwendbare Vorschrift (4 Byte) und die Kosten f\*ur
diese Anwendung (4 Byte) ablegt. Die erste Version der Spezifikation der
Codeerzeugung bestand aus ca. 40 Funktionen, d.h. f\*ur jeden Baumknoten
wurden etwa 320 Byte dynamischer Speicher angefordert.
.sp 0.4v
.ne 2v
.ti +2n
Um die Codeerzeugung nicht doch noch aus praktischen Gr\*unden ,,von Hand''
programmieren zu m\*ussen, war es notwendig, diesen Speicherbedarf durch eine
Ver\*anderung der Spezifikation und durch eine automatische Nachoptimierung des
von \%\fIEstra\fP erzeugten Codegenerators zu reduzieren.
.sp 0.4v
.ne 2v
.ti +2n
Ein erster Schritt zur Reduktion des Speicherbedarfs war, die Anzahl der
Funktionen in der Spezifikation und damit die in jedem Knoten
abgelegte Menge von Informationen zu reduzieren. Dies ist aber aus den folgenden
Gr\*unden nicht unbegrenzt m\*oglich bzw. sinnvoll:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&F\*ur bestimmte Knotentypen m\*ussen verschiedene Funktionen existieren,
da sie wie oben beschrieben mehrfach auf unterschiedliche Art und Weise
transformiert werden m\*ussen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine gew\*unschte Modularisierung der Spezifikation f\*ur Zwecke der
Verst\*andlichkeit und Wartbarkeit l\*a\*st es nicht sinnvoll erscheinen, eine
Spezifikation von mehreren tausend Zeilen mit einer einzigen Funktion
festzulegen, selbst wenn dies theoretisch m\*oglich w\*are.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Beim Einsatz von Attributen sind in der Regel
f\*ur verschiedene Knotentypen
auch unterschiedliche Attribute und somit verschiedene
Funktionen notwendig.
.in -4n
.sp 0.1vv
.sp 0.3vv
Soweit dies logisch vertretbar erschien, wurden
einzelne Funktionen zusammengefa\*st, so da\*s die endg\*ultige Spezifikation der
Codeerzeugung nur noch aus 22 Funktionen besteht.
Allerdings hat sich die Lesbarkeit der Spezifikation
durch diese Zusammenfassung verschlechtert.
.sp 0.4v
.ne 2v
.ti +2n
Ein Ansatz f\*ur eine automatische Nachoptimierung ergab sich aus folgender
\*Uberlegung: Die Kosten werden von \%\fIEstra\fP dazu benutzt, die
kosteng\*unstigste Vorschrift auszuw\*ahlen. Die Kosten f\*ur die
Transformation eines Baumknotens h\*angen dabei im
allgemeinen \(em wie es z.B. in Codegeneratoren
f\*ur Maschinensprache sinnvoll ist \(em von den Kosten f\*ur die Transformation
beliebiger Unterb\*aume ab. Daher m\*ussen die
Kosten f\*ur die Anwendung der einzelnen Vorschriften im Baum abgelegt werden.
F\*ur eine Abbildung des attributierten Strukturbaums nach C kann man aber immer
bereits lokal an einem bestimmten Knoten entscheiden, wie dieser nach C
abzubilden ist, ohne dabei die Abbildung der Unterb\*aume bzw. deren Kosten
ber\*ucksichtigen zu m\*ussen.
Die Kosten werden f\*ur eine Abbildung nach C nur
ben\*otigt, um bei der Vorbereitung der Transformation
f\*ur jeden Knoten lokal die kosteng\*unstigste Vorschrift ausw\*ahlen zu k\*onnen.
Aus diesem Grund w\*urde es
v\*ollig ausreichen, die Kosten, anstatt sie im Baum
abzuspeichern, in einer lokalen Variablen der Besuchsprozedur abzulegen, die
die Transformation vorbereitet. Nur die
Vorschrift selbst m\*u\*ste dann noch im Baum gespeichert werden, um im zweiten
Schritt die Transformation durchf\*uhren zu k\*onnen.
.sp 0.4v
.ne 2v
.ti +2n
In der Spezifikation wurden alle Kosten so
festgelegt, da\*s die Kosten der Transformation eines bestimmten Knotens
nicht mehr von den Kosten der Transformation der Kindknoten (Unterb\*aume)
abh\*angen. Mit Hilfe des Zeileneditors \%\fIsed\fP wurde der von \%\fIEstra\fP
erzeugte Codegenerator \(em wie oben angedeutet \(em
automatisch nachoptimiert. Das daf\*ur verwendete \fISed\fP\^-Skript ist relativ
einfach und umfa\*st nur ca. 40 Zeilen. Besonders wichtig ist, da\*s diese
Nachoptimierung ohne Eingreifen des Benutzers automatisch durchgef\*uhrt werden
kann, da es keinesfalls sinnvoll w\*are, ein von einem \*Ubersetzerbauwerkzeug
generiertes Programm noch nachtr\*aglich ,,von Hand'' nachzuoptimieren, was dann
selbstverst\*andlich bei jeder noch so kleinen \*Anderung der Spezifikation
durchgef\*uhrt werden m\*u\*ste.
.sp 0.4v
.ne 2v
.ti +2n
Durch die oben beschriebenen Ma\*snahmen konnte der Speicherbedarf
der endg\*ultigen Version des Codegenerators auf etwa
1/4 des Speicherbedarfs der ersten Version reduziert werden.
Der Trashing-Effekt tritt daher f\*ur Modula-Programme in praktisch
vorkommenden Gr\*o\*sen nicht mehr (so stark) in Erscheinung.
Im n\*achsten Kapitel wird bei der
Bewertung der Werkzeuge ein Vorschlag gemacht, wie \%\fIEstra\fP
unter Ausnutzung von in
der Spezifikation enthaltenen Informationen den
Speicherbedarf auf allgemeine Weise drastisch reduzieren k\*onnte.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Fehlerbehandlung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Fehlerbehandlung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Lexikalische Fehler wurden in der Spezifikation des
Sym\%bol\%ent\%schl\*uss\%lers
ber\*ucksichtigt und werden daher vom \*Ubersetzer behandelt und gemeldet.
.sp 0.4v
.ne 2v
.ti +2n
Wie in Kapitel \n(h1.2.1 besprochen, besitzt der generierte Zerteiler eine
automatische Fehlerbehandlung. Dem Benutzer werden daher syntaktische Fehler
und die vom Zerteiler durchgef\*uhrte Fehlerreparatur gemeldet.
.sp 0.4v
.ne 2v
.ti +2n
Bei der Behandlung der getrennten \*Ubersetzung k\*onnen zwei Fehler auftreten,
die vom \*Ubersetzer gemeldet werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein f\*ur die \*Ubersetzung der aktuellen \*Ubersetzungseinheit ben\*otigter
Definitionsmodul kann nicht gefunden werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Es existieren \(em in \%Modula-2 verbotene \(em
zyklische Abh\*angigkeiten zwischen den Definitionsmoduln.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Tritt w\*ahrend der lexikalischen und syntaktischen Analyse oder bei der
Behandlung der getrennten \*Ubersetzung ein Fehler auf, dann wird die
\*Ubersetzung nach der entsprechenden \*Ubersetzerphase abgebrochen.
Da die aktuelle \*Ubersetzungseinheit und die
Definitionsmoduln aus verschiedenen Quelldateien stammen, enthalten die
Fehlermeldungen neben der Angabe von Zeile und Spalte im Quelltext auch immer
den Namen der zugeh\*origen Quelldatei.
.sp 0.4v
.ne 2v
.ti +2n
Wie bereits besprochen, soll die semantische Korrektheit der
Eingabeprogramme vom \*Ubersetzer nicht \*uberpr\*uft werden.
Nat\*urlich ist es trotzdem m\*oglich, da\*s ein semantisch falsches Programm als
Eingabe auftritt. Daher m\*ussen m\*ogliche semantische Fehler, wie
z.B. eine bei der Bezeichneridentifikation entdeckte fehlende Deklaration f\*ur
einen Bezeichner, zumindest intern behandelt werden, auch wenn solche Fehler
dem Benutzer nicht gemeldet werden.
F\*ur die Behandlung dieser Fehler wird eine f\*ur Attributgrammatiken
\*ubliche Technik angewandt: F\*ur die Attributtypen werden spezielle
Fehlerwerte eingef\*uhrt, welche im Fehlerfall von den
entsprechenden Operationen zur\*uckgeliefert werden. Au\*serdem erfolgt der
Zugriff auf semantische Informationen wie z.B. die Typ- und Objektbeschreibungen
nicht direkt, sondern durch spezielle Zugriffsoperationen, die \*uberpr\*ufen, ob
die Beschreibungen bestimmte semantische
Bedingungen erf\*ullen und die bei Nichterf\*ullung
der Bedingungen entsprechende Fehlerwerte zur\*uckliefern.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur semantisch falsche Programme wird aber in jedem Fall C-Code erzeugt.
Allerdings sind diese C-Programme in 95\^% der F\*alle entweder semantisch oder
meist sogar syntaktisch fehlerhaft und daher wird in der Regel der
C-\*Ubersetzer entdecken, da\*s die urspr\*unglichen Modula-Programme fehlerhaft
waren.
.sp 0.4v
.ne 2v
.ti +2n
Falls eines der vom \*Ubersetzer nicht unterst\*utzten Modula-Konstrukte
im Quellprogramm auftritt, wird dies von der Codeerzeugung gemeldet.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Umfang der Implementierung des \*Ubersetzers\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Umfang der Implementierung des \*Ubersetzers
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.3 zeigt den Umfang der f\*ur die Implementierung des
\*Ubersetzers \%\fIMtc\fP verwendeten Spezifikationen und den Umfang der
Quellmoduln, die aus diesen Spezifikationen erzeugt wurden.
.sp 1.5
.zA
\s-2
.TS
delim($$)tab(|) center box;
c| c s s| c s s
c| c c c| c c c
l| n n n| n n n .
\*Ubersetzerteil|Spezifikation|Erzeugter Quellmodul
_
|Formaler Teil|Quellcode|Summe|Def.-Modul|Impl.-Modul|Summe
_
Symbolentschl\*ussler|392|133|525|56|1320|1376
Zerteiler|934|87|1021|80|2918|2998
Strukturbaum|189|51|240|579|3234|3813
Definitionstabelle|118|985|1103|417|1549|1966
Attributauswerter|2071|159|2230|9|3591|3600
Codegenerator|2775|1030|3805|50|7448|7498
_
Summe|6479|2445|8924|1191|20060|21251
.TE
\s+2
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.3\fP: Umfang der Spezifikationen und der
daraus erzeugten Quellmoduln in Zeilen
.ce 0
.zE
.sp 1.5
Die Zahlen f\*ur den Codegenerator beziehen sich auf die nachoptimierte Version.
Vor der Nachoptimierung betr\*agt seine Gr\*o\*se 7571 Zeilen.
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.4 zeigt Umfang (in Zeilen) und Anzahl der Moduln, aus denen
\%\fIMtc\fP besteht, wobei unterschieden wird zwischen aus
Spezifikationen erzeugten Moduln, Bibliotheksmoduln und ,,von Hand''
programmierten Moduln.
.sp 1.5
.zA
\s-2
.TS
delim($$)tab(|) center box;
c| c| c
l| n| n.
\*Ubersetzermoduln|Anzahl|Umfang
_
Aus Spezifikationen erzeugte Moduln|6|21251
Bibliotheksmoduln|18|3541
,,Von Hand'' programmierte Moduln|11|3871
_
Summe|35|28663
.TE
\s+2
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.4\fP: Umfang und Anzahl der Moduln von \%\fIMtc\fP
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Wie die beiden obigen Tabellen zeigen, besteht der \*uberwiegende Teil des
\*Ubersetzers \%\fIMtc\fP aus
Moduln, die mit Hilfe von Werkzeugen aus Spezifikationen erzeugt wurden und
aus wiederverwendbaren Bibliotheksmoduln. Nur
ein relativ kleiner Teil des \*Ubersetzers besteht aus Moduln, die
ausschlie\*slich ,,von Hand'' programmiert sind. Betrachtet man den gesamten
Umfang von \%\fIMtc\fP, dann wird klar, da\*s die
Implementierung eines Programms dieses Umfangs und dieser Komplexit\*at ohne den
Einsatz von Werkzeugen und wiederverwendbarer Software kaum im Rahmen einer
Diplomarbeit m\*oglich gewesen w\*are. 
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Praktische Ergebnisse\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Praktische Ergebnisse
.hE 0 4n 0.1v
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Test und erste Eins\*atze des \*Ubersetzers\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Test und erste Eins\*atze des \*Ubersetzers
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Da schon seit mehreren Jahren an der GMD Forschungsstelle Karlsruhe die Sprache
\%Modula-2 und der \*Ubersetzer \%MOCKA eingesetzt werden, bestand an
Testprogrammen f\*ur den \*Ubersetzer \%\fIMtc\fP kein Mangel.
Anf\*anglich noch vorhandene Schw\*achen in der Abbildung von
\%Modula-2 nach C, insbesondere solche urspr\*unglich nicht
ber\*ucksichtigten
Spezialf\*alle, wie die in Kapitel
4.2.2 beschriebenen Probleme bei der Abbildung von gro\*sen ganzzahligen
Konstanten oder von Zeichenkonstanten, konnten daher relativ schnell entdeckt
und beseitigt werden.
.sp 0.4v
.ne 2v
.ti +2n
Der erste gro\*se Test des \*Ubersetzers \%\fIMtc\fP, der auch mit dem Betreuer
zu Beginn der Diplomarbeit als Abnahmetest vereinbart worden war, war die
\*Ubersetzung von \%\fIMtc\fP selbst nach C. Dieser Test wurde von \%\fIMtc\fP
erfolgreich absolviert, so da\*s \%\fIMtc\fP jetzt sowohl in der
urspr\*unglichen Modula-Version als auch in einer daraus erzeugten C-Version
vorliegt.
.sp 0.4v
.ne 2v
.ti +2n
Wichtigster und anspruchsvollster Test von \%\fIMtc\fP war die \*Ubersetzung des
Modula-\*Ubersetzers \%MOCKA nach C.
.sp 0.4v
.ne 2v
.ti +2n
Das erste dabei auftretende Problem war, da\*s \%MOCKA eine
M\*oglichkeit f\*ur eine bedingte \*Ubersetzung mit Hilfe von
\*Ubersetzerschaltern besitzt, die in den Quellen von \%MOCKA
verwendet wird, um die
verschiedenen \%MOCKA-Versionen f\*ur unterschiedliche
Zielmaschinen zu verwalten. Diese bedingte \*Ubersetzung wird von \%\fIMtc\fP
nicht unterst\*utzt. Die \%MOCKA-Versionen f\*ur die SUN- und
PCS-Workstations mu\*sten daher erst aus den Quellen mit den
\*Ubersetzerschaltern erzeugt werden. Dies konnte allerdings automatisch mit
Hilfe des Zeileneditors \%\fIsed\fP durchgef\*uhrt werden.
.sp 0.4v
.ne 2v
.ti +2n
Das zweite auftretende Problem war, da\*s von \%MOCKA eine im
Benutzerhandbuch nicht dokumentierte, aber in den Quellen benutzte
Spracherweiterung vorgenommen wird: \%MOCKA erlaubt es das Zeichen _ in
Bezeichnern wie einen Buchstaben zu verwenden. Daraufhin wurde die Spezifikation
des Sym\%bol\%ent\%schl\*uss\%lers von \%\fIMtc\fP so erweitert, da\*s \%\fIMtc\fP diese
Spracherweiterung auch akzeptiert. Allerdings kann es jetzt, da die Umbenennung von
Bezeichnern davon ausgeht, da\*s dieses Zeichen in Modula-Bezeichnern nicht
vorkommt, in ung\*unstigen F\*allen zu Namenskonflikten in den erzeugten
C-Programmen
kommen. Bei Verwendung des Zeichens _ in Bezeichnern gibt \%\fIMtc\fP daher
eine entsprechende Warnung aus.
.sp 0.4v
.ne 2v
.ti +2n
Ein weiteres Problem trat an den PCS-Workstations auf. Der Modul
\%\fISuValues\fP enth\*alt Konstantendeklarationen der Form
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
CONST UPBdiv8 = MaxLongCard DIV 8;
CONST UPBmod8 = MaxLongCard MOD 8;
...
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wobei \%\fIMaxLongCard\fP den Wert \%MAX(LONGCARD) hat. Trotz der in Kapitel
4.2.2 besprochenen Typumwandlungen ist der C-\*Ubersetzer nicht in der
Lage,
diese Konstanten korrekt auszuwerten, da offensichtlich intern nur mit
\fIlong\fP\^-Werten gerechnet und \*Uber- bzw. Unterlauf nicht erkannt wird.
Diese Konstanten mu\*sten daher an den PCS-Workstations in den
C-Programmen ,,von Hand'' ausgewertet und eingesetzt werden. Der
C-\*Ubersetzer der Firma \%SUN ist dagegen in der Lage, diese konstanten
Ausdr\*ucke korrekt auszuwerten. \%\fIMtc\fP gibt jetzt bei der Verwendung einer
Konstanten im Bereich von
\%MAX\^(INTEGER)\|+\|1\|..\|\%MAX\^(CARDINAL)
eine entsprechende Warnung ab.
.sp 0.4v
.ne 2v
.ti +2n
Das letzte auftretende Problem war folgender Typtransfer im Modul
\%\fICgMobil\fP:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
GenLongIntMode (SHORTINT (0FFFFH), LowWordMaskOp);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Der erste formale Parameter von \%\fIGenLongIntMode\fP hat den Typ
\%LONGINT. Der Wert des aktuellen Parameters nach der \*Ubergabe
ist in \%Modula-2 65535. Die \*Ubersetzung nach C liefert
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
GenLongIntMode((SHORTINT)0XFFFF, &LowWordMaskOp);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
In C ist der Wert des aktuellen Parameters nach der \*Ubergabe -1. In den
erzeugten C-Programmen mu\*ste daher die Typumwandlung entfernt werden, damit
\%MOCKA auch in C korrekt funktioniert. Da der Wert 0FFFFH
(=\%MAX(SHORTCARD)) eigentlich als SHORTINT-Wert \*uberhaupt nicht
darstellbar ist
und au\*serdem der Typtransfer keine erkennbare Funktion hat,
scheint die obige
Konstruktion aber prinzipiell fragw\*urdig zu sein und sollte aus den
Modula-Quellen von \%MOCKA entfernt werden.
.sp 0.4v
.ne 2v
.ti +2n
Nach der Beseitigung der obengenannten Probleme lag auch der
Modula-\*Ubersetzer \%MOCKA sowohl auf den PCS- als auch auf den
SUN-Workstations in einer C-Version vor und wurde auch bereits
f\*ur die \*Ubersetzung von zahlreichen Modula-Programmen wie z.B.
\%\fIMtc\fP und \%MOCKA eingesetzt.
.sp 0.4v
.ne 2v
.ti +2n
Neben den beiden obengenannten gro\*sen Testf\*allen wurden
noch folgende Modula-Programme mit \%\fIMtc\fP nach C
\*ubersetzt: Der
Minilax-\*Ubersetzer aus dem \*Ubersetzerbaupraktikum, die komplette Bibliothek
\%\fIReuse\fP, die Standardbibliothek des \*Ubersetzers \%MOCKA sowie ein
mit dem Zerteilergenerator \%PGS [Klein\|86] erzeugter Zerteiler,
der starken Gebrauch
vom Zugriff auf lokale Variablen von statisch umfassenden Prozeduren macht und
daher als Testfall ausgew\*ahlt wurde.
Insgesamt wurden vom Verfasser dieser Diplomarbeit Modula-Programme mit einem
Gesamtumfang von etwa 80000 Zeilen erfolgreich nach C \*ubertragen.
.sp 0.4v
.ne 2v
.ti +2n
Vom Betreuer dieser Diplomarbeit Dr. J. Grosch wurden au\*serdem
w\*ahrend der Anfertigung dieser schriftlichen Ausarbeitung
die \*Ubersetzerbauwerkzeuge \%\fIRex\fP, \%\fILalr\fP und \%\fIEll\fP
erfolgreich nach C \*ubertragen.
Diese Programme haben einen Umfang von etwa 35000 Zeilen \%Mo\%du\%la-Code.
.sp 0.4v
.ne 2v
.ti +2n
Die erzeugten C-Programme wurden bisher an den folgenden Maschinen getestet:
PCS- und SUN-Workstations (MC68020-Prozessor), DEC VAX 8530 und
DEC 3100 (MIPS-Prozessor) und sind daher als gut portabel anzusehen.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Gr\*o\*se, Laufzeit und Speicherbedarf des \*Ubersetzers\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Gr\*o\*se, Laufzeit und Speicherbedarf des \*Ubersetzers
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
S\*amtliche Messungen in diesem und den folgenden Abschnitten wurden an einer
SUN-Workstation (MC68020-Prozessor, 20 MHZ Taktfrequenz) durchgef\*uhrt. Alle
Angaben f\*ur den \*Ubersetzer \%\fIMtc\fP beziehen sich auf die
Modula-Version des \*Ubersetzers.
.sp 0.4v
.ne 2v
.ti +2n
Die Gr\*o\*se des ausf\*uhrbaren Objektprogramms von \%\fIMtc\fP, gemessen
mit dem \fIsize\fP\^-Kommando [UNIX\|79], kann Tabelle \n(h1.1 entnommen
werden.
.sp 1.5
.zA
.TS
delim($$)tab(|) center allbox;
c c c c
n n n n.
Text|Data|Bss|Summe
294912|8192|6344|309448
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.1\fP: Gr\*o\*se des Objektprogramms von \%\fIMtc\fP in Byte
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.2 enth\*alt Laufzeit und Leistung von \%\fIMtc\fP f\*ur die
\*Ubersetzung des Modula-\*Ubersetzers \%MOCKA, der aus 35 Moduln besteht, die
insgesamt 37792 Zeilen Modula-Code umfassen. Die Laufzeit wurde gemessen mit dem
\fItime\fP\^-Kommando [UNIX\|79] und ist die Summe aus
User- und System-Zeit.
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
c| c| c s
c| c| c| c
c| n| n| n.
Messung|Laufzeit|Leistung
|[s]|[Zeilen/s]|[Grundsymbole/s]
_
A|303|125|496
_
B|255|148|589
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.2\fP: Laufzeit und Leistung von \%\fIMtc\fP f\*ur die
\*Ubersetzung von \%MOCKA
.ce 0
.zE
.sp 1.5
Bei der Messung A wurde jeder Definitions-, Implementierungs- und Programmodul
einzeln nach C \*ubersetzt. Bei der Messung B wurde \%\fIMtc\fP nur f\*ur
Implementierungs- und Programmoduln aufgerufen und bei jedem
\*Ubersetzungsvorgang mit Hilfe der in Kapitel 5.6 erw\*ahnten Option die
Definitionsdateien aller transitiv importierten Definitionsmoduln
ausgegeben. Die Laufzeit (Messung A) verteilt sich folgenderma\*sen auf die
einzelnen \*Ubersetzerphasen:
.sp 0.4v
.TS
delim($$)tab(|) center;
l r.
\fIParse\fP|19\^%
\fIGetDefinitionModules\fP|29\^%
\fIEval\fP|31\^%
\fIDoCode\fP|21\^%
.TE
.sp 0.4v
Dabei ist noch erw\*ahnenswert, da\*s \(em neben dem Aufruf des
Sym\%bol\%ent\%schl\*uss\%lers \(em
die mit Abstand aufwendigste
Einzeloperation,
die Operation \%\fIIdentify\fP f\*ur
die Bezeichneridentifikation ist, die ca. 10\-20\|% der gesamten
\*Ubersetzungszeit beansprucht.
.sp 0.4v
.ne 2v
.ti +2n
Im Vergleich zu \%\fIMtc\fP ist die Laufzeit bzw. Leistung von
\%MOCKA bei der
\*Ubersetzung von \%MOCKA 178 Sekunden bzw. 212 Zeilen pro Sekunde
und die Laufzeit bzw. Leistung
des C-\*Ubersetzers
f\*ur die \*Ubersetzung der C-Version von
\%MOCKA (36665 Zeilen C-Code) 408 Sekunden bzw. 90 Zeilen pro Sekunde.
.sp 0.4v
.ne 2v
.ti +2n
Alle Leistungsangaben wurden berechnet aus: Gesamtumfang von
\%MOCKA geteilt durch die
\*Ubersetzungszeit. Dabei wird nicht ber\*ucksichtigt, da\*s
\%\fIMtc\fP bei jedem \*Ubersetzungsvorgang auch noch alle transitiv importierten
Definitionsmoduln einliest bzw., da\*s der C-\*Ubersetzer
die Definitionsdateien dieser Definitionsmoduln in das
C-Quellprogramm einf\*ugt.
.sp 0.4v
.ne 2v
.ti +2n
Ber\*ucksichtigt man, da\*s \%\fIMtc\fP im Gegensatz zu \%MOCKA bei jedem
\*Ubersetzungsvorgang alle transitiv importierten Definitionsmoduln von neuem
einliest und analysiert und da\*s die Bezeichneridentifikation wegen der
Verwendung einer Attributgrammatik \*uber Listen erfolgt, dann ist die Leistung
von \%\fIMtc\fP auch im Vergleich mit \%MOCKA sehr gut.
Insbesondere scheint der Preis f\*ur
eine Vereinfachung der Behandlung der getrennten \*Ubersetzung durchaus
vertretbar zu sein.
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.3 enth\*alt den Speicherbedarf von \%\fIMtc\fP (dynamisch
angeforderter Speicher) f\*ur die \*Ubersetzung der gr\*o\*sten
vorhandenen \*Ubersetzungseinheit,
dem Implementierungsmodul des Codegenerators von
\%\fIMtc\fP, der 7448 Zeilen Modula-Code umfa\*st. Bei der \*Ubersetzung dieses
Moduls werden zus\*atzlich noch 18
Definitionsmoduln mit einem Gesamtumfang von 1992 Zeilen eingelesen.
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
c| c
l| n.
Zweck|Dynamischer Speicherbedarf
_
Baum und Attribute|2243
Definitionstabelle|328
Vorbereitung der Codeerzeugung|4751
Gesamter Speicherbedarf|7484
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.3\fP: Dynamischer Speicherbedarf von \%\fIMtc\fP
f\*ur die \*Ubersetzung des Codegenerators von \%\fIMtc\fP in Kilobyte
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Der Speicherbedarf ist mit 793 Kilobyte pro 1000 Zeilen Quellcode
relativ hoch. Der
gr\*o\*ste Anteil entf\*allt allerdings auf den Codegenerator. Ohne die in Kapitel
5.6.2
besprochene automatische Nachoptimierung w\*urde dieser 9155 Kilobyte Speicher
ben\*otigen. Bei der Angabe des Speicherbedarfs f\*ur Baum und Attribute ist zu
ber\*ucksichtigen, da\*s der von \%\fIAg\fP erzeugte Attributauswerter
zur Zeit keine
Optimierung der Attributspeicherung enth\*alt und
daher s\*amtliche Attribute im Baum
gespeichert werden. Da\*s der Speicherbedarf sich trotzdem in vertretbaren
Grenzen h\*alt, liegt im wesentlichen daran, da\*s die meisten Attribute als
abstrakte Datentypen
in der Zielsprache realisiert werden und im Baum nur jeweils Zeiger auf die
eigentlichen Attributwerte gespeichert werden.
Eine entsprechende Optimierung der Attributspeicherung durch \%\fIAg\fP und eine
bessere Darstellung der in den Knoten des Strukturbaums
bei der Vorbereitung der Codeerzeugung abgelegten
Informationen durch \%\fIEstra\fP w\*urde den Speicherbedarf des
\*Ubersetzers deutlich reduzieren.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Qualit\*at des erzeugten C-Codes\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Qualit\*at des erzeugten C-Codes
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
F\*ur eine Bewertung der Qualit\*at des von \%\fIMtc\fP erzeugten C-Codes wurden
die Modula- und die C-Version von \%MOCKA miteinander verglichen.
Um eine Verf\*alschung der Me\*sergebnisse zu vermeiden, wurde die Modula-Version
von \%MOCKA ohne Laufzeitpr\*ufungen \*ubersetzt, d.h. auch die Modula-Version
enth\*alt \(em wie die C-Version \(em keine \*Uberpr\*ufung von Bereichs- und
Feldgrenzen.
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.4 enth\*alt die Gr\*o\*se der ausf\*uhrbaren Objektprogramme der
beiden MOCKA-Versionen.
.sp 1.5
.zA
.TS
delim($$)tab(|) center allbox;
c c c c c
l n n n n.
MOCKA-Version|Text|Data|Bss|Summe
Modula-2|385024|8192|62680|455896
C|327680|32768|66288|426736
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.4\fP: Gr\*o\*se der beiden \%MOCKA-Versionen in Byte
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.5 enth\*alt Laufzeit und Leistung der beiden Versionen f\*ur die
\*Ubersetzung von \%MOCKA (37792 Zeilen Modula-Code).
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
c| c| c s
c| c| c| c
l| n| n| n.
MOCKA-Version|Laufzeit|Leistung
|[s]|[Zeilen/s]|[Grundsymbole/s]
_
Modula-2|178|212|844
_
C|165|229|910
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.5\fP: Laufzeit und Leistung der MOCKA-Versionen f\*ur die
\*Ubersetzung von \%MOCKA
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Wie den beiden Tabellen entnommen werden kann, ist die C-Version von
\%MOCKA sowohl kleiner als auch schneller wie die Modula-Version.
.sp 0.4v
.ne 2v
.ti +2n
Eine leicht durchf\*uhrbare M\*oglichkeit f\*ur eine Nachoptimierung der erzeugten
C-Programme auf Quellsprachebene, die in \%Modula-2 nicht vorhanden ist,
ist die M\*oglichkeit in C bestimmte Variablen in der Speicherklasse
\%\fIregister\fP (s. Kap. 3.2) zu
deklarieren. Mit einigen wenigen solcher Deklarationen f\*ur h\*aufig
benutzte Variablen kann u.U. noch eine deutliche Leistungssteigerung
der C-Programme erreicht werden.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Implementierung eines Makefile-Generators\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Implementierung eines Makefile-Generators
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Mit Hilfe der Werkzeuge \%\fIRex\fP und \%\fIEll\fP und des Interpreters f\*ur
eine Sprache zur Textmusterverarbeitung \%\fIawk\fP [UNIX\|79] wurde der
Makefile-Generator \%\fImakemake\fP implementiert, der aus den Quellen eines
Modulaprogramms durch Analyse der Importanweisungen eine Beschreibung der
Abh\*angigkeiten zwischen den nach C \*ubersetzten Quellen erzeugt,
wie sie vom UNIX-Kommando \%\fImake\fP [UNIX\|79] verarbeitet werden kann.
Diese Beschreibung enth\*alt au\*serdem Kommandos, die folgende Schritte
veranlassen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\*Ubersetzung der Modula-Quellen durch \%\fIMtc\fP nach C.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\*Ubersetzung der erzeugten C-Quellen durch den C-\*Ubersetzer in
Objektprogramme.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Binden der Objektprogramme zu einem ausf\*uhrbaren Programm.
.in -4n
.sp 0.1vv
.sp 0.3vv
Durch einen Aufruf von \%\fImake\fP, welches die obige Beschreibungsdatei
(Makefile) als
Eingabe erh\*alt, werden die Kommandos in der richtigen
Reihenfolge ausgef\*uhrt und eine ausf\*uhrbare C-Version des jeweiligen
Modula-Programms erzeugt.
.sp 0.4v
.ne 2v
.ti +2n
Das Programm f\*ur den Interpreter \%\fIawk\fP konnte aus einem \*ahnlichen
Makefile-Generator, der f\*ur eine alte Version des Modula-\*Ubersetzers
\%MOCKA ohne automatische Nach\*ubersetzung implementiert worden war,
\*ubernommen und entsprechend angepa\*st werden.
.sp 0.4v
.ne 2v
.ti +2n
Der Makefile-Generator war f\*ur die Testphase und die ersten praktischen
Eins\*atze von \%\fIMtc\fP eine wichtige Hilfe, da z.B. f\*ur die Erzeugung der
C-Version von \%MOCKA ca. 150 Aufrufe von \%\fIMtc\fP und des C-\*Ubersetzers
mit einer Vielzahl von Optionen und Parametern notwendig sind, die au\*serdem
noch in
der richtigen Reihenfolge erfolgen m\*ussen. Durch die automatisch erzeugte
Beschreibungsdatei reduziert sich dieser Aufwand auf einen Aufruf des Kommandos
\%\fImake\fP.
.sp 0.4v
.ne 2v
.ti +2n
Die Beschreibungdatei enth\*alt \*ubrigens auch gen\*ugend
Abh\*angigkeitsinformationen f\*ur eine Verwaltung der C-Quellen: Bei einer
Modifikation einer oder mehrerer C-Quellen werden durch einen Aufruf von
\%\fImake\fP alle abh\*angigen C-Programme nach\*ubersetzt.
Die Beschreibung reicht allerdings nicht aus, um bei einer Modifikation der
Modula-Quellen eine vollst\*andige Nach\*ubersetzung nach C zu veranlassen, da
f\*ur eine Vereinfachung der Beschreibung in dieser nur vermerkt ist, da\*s
\%\fIM.c\fP von \%\fIM.mi\fP und \%\fIM.h\fP von \%\fIM.md\fP abh\*angt.
Es w\*are allerdings \(em wenn dies ben\*otigt werden sollte \(em nicht besonders
aufwendig, \%\fImakemake\fP so zu erweitern, da\*s auch die Abh\*angigkeit einer
\*Ubersetzungseinheit von allen transitiv importierten
(De\%fi\%ni\%ti\%ons-)Mo\%duln beschrieben wird.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Bewertung der \*Ubersetzerbauwerkzeuge\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Bewertung der \*Ubersetzerbauwerkzeuge
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Dieser Abschnitt enth\*alt einige spezielle Anmerkungen zu den
\*Ubersetzerbauwerkzeugen sowie eine Reihe von Verbesserungsw\*unschen und
-vorschl\*agen.
.sp 0.4v
.ne 2v
.ti +2n
\%\fIRex\fP und \%\fIEll\fP erm\*oglichen es, in k\*urzester Zeit einen
Sym\%bol\%ent\%schl\*uss\%ler bzw. einen Zerteiler mit automatischer Fehlerbehandlung
aus einer knappen und leicht verst\*andlichen formalen Spezifikation zu
erstellen. Ein wichtiges Merkmal der erzeugten \*Ubersetzerteile f\*ur den
praktischen Einsatz ist ihre hohe Laufzeiteffizienz.
.sp 0.4v
.ne 2v
.ti +2n
Auch der Einsatz von \%\fIAst\fP ist eine enorme Arbeitserleichterung f\*ur den
\*Ubersetzerbauer: Aus einer sehr kurzen formalen Spezifikation der abstrakten
Syntax (vgl. Anh. A) kann ein zwar relativ leicht ,,von Hand''
programmierbarer aber
umfangreicher Modul f\*ur die Implementierung des Strukturbaums erzeugt werden.
.sp 0.4v
.ne 2v
.ti +2n
Ein interessanter Aspekt in diesem Zusammenhang w\*are, ob
aus einer eventuell gemeinsamen Spezifikation des Zerteilers und der
abstrakten Syntax nicht auch die semantischen Aktionen f\*ur den Baumaufbau
automatisch erzeugt werden
k\*onnten, die bei der erstellten Zerteilerspezifikation den meisten
Aufwand erforderten.
.sp 0.4v
.ne 2v
.ti +2n
Insgesamt nahm die Implementierung der ersten beiden Phasen von \%\fIMtc\fP
(lexikalische und syntaktische Analyse, Baumaufbau und Behandlung der
getrennten \*Ubersetzung) weniger als 1/7 der gesamten Implementierungszeit in
Anspruch.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Ag\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Ag
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die zur Zeit vorliegende Version von \%\fIAg\fP ist ein noch in der Entwicklung
befindlicher Prototyp.
.sp 0.4v
.ne 2v
.ti +2n
Die aus der Sicht des Verfassers wichtigste Verbesserung der
Spezifikationssprache w\*are, eine M\*oglichkeit
innerhalb der Attributierungsregeln
auf Attribute von Vorg\*angerknoten im Strukturbaum zugreifen
zu k\*onnen (analog \%INCLUDING des GAG-Systems [Kastens\|82]).
Durch eine solche M\*oglichkeit k\*onnte die Attributgrammatik deutlich
verkleinert werden und eine nicht unerhebliche Anzahl von Attributen und
Attributberechnungen, die nur
f\*ur Attributtransfers ben\*otigt werden, k\*onnte entfallen.
.sp 0.4v
.ne 2v
.ti +2n
W\*ahrend der Entwicklung der Attributgrammatik trat h\*aufig das Problem auf,
da\*s diese nicht mehr der Klasse \%OAG angeh\*orte. In diesem Fall war es
notwendig, geeignete k\*unstliche
At\%tri\%but\%ab\%h\*an\%gig\%kei\%ten einzuf\*uhren, die
wieder die Eigenschaft \%OAG erzwangen. Da auf der einen Seite die von
\%\fIAg\fP ausgedruckten Informationen \*uber die
At\%tri\%but\%ab\%h\*an\%gig\%kei\%ten sehr
umfangreich sind und au\*serdem die Eigenschaft \%OAG nicht besonders leicht
nachvollziehbar ist, war es jedesmal nicht ganz einfach, geeignete k\*unstliche
At\%tri\%but\%ab\%h\*an\%gig\%kei\%ten
zu finden. Es w\*are daher w\*unschenswert, wenn
\%\fIAg\fP \(em \*ahnlich wie das GAG-System \(em in der Lage w\*are, diese
k\*unstlichen
Abh\*angigkeiten zur Erzielung der OAG-Eigenschaft ohne Einwirkung des Benutzers
automatisch einzuf\*uhren.
.sp 0.4v
.ne 2v
.ti +2n
F\*ur eine formale Spezifikation der statischen Semantik einer Sprache im Rahmen
der Sprachdefinition ist eine volle Funktionalit\*at der Attributgrammatik
sicher unerl\*a\*slich. F\*ur eine praktische Implementierung der semantischen
Analyse, die hinsichtlich Laufzeit und Speicherbedarf des Attributauswerters
m\*oglichst effizient sein soll, ist der kontrollierte Einsatz von
Seiteneffekten manchmal nahezu unerl\*a\*slich. Au\*serdem lassen sich zyklische
Abh\*angigkeiten innerhalb von Objekt- und Typbeschreibungen, wie sie in den
meisten in der Praxis verwendeten Sprachen einfach auftreten, durch einen
schrittweisen Aufbau dieser Beschreibungen noch am einfachsten aufl\*osen. Ein
Problem, welches durch den Einsatz von kontrollierten Seiteneffekten nat\*urlich
hinzukommt ist, da\*s man sich in diesem Zusammenhang Gedanken \*uber die
Reihenfolge der Seiteneffekte machen und diese Reihenfolge eventuell durch
die Einf\*uhrung von geeigneten Attributen bzw.
At\%tri\%but\%ab\%h\*an\%gig\%kei\%ten
erzwingen mu\*s.
.sp 0.4v
.ne 2v
.ti +2n
Durch den Einsatz von in \%Modula-2 implementierten abstrakten Datentypen,
durch kontrollierte Seiteneffekte und durch die von \%\fIAg\fP verwendete
direkte Implementierung der Besuchssequenzen mit rekursiven Prozeduren ist es
gelungen, einen Attributauswerter aus einer Attributgrammatik zu erzeugen, der
insbesondere im Hinblick auf Laufzeiteffizienz mit ,,von Hand'' implementierten
\*Ubersetzern wie \%MOCKA durchaus mithalten kann.
.sp 0.4v
.ne 2v
.ti +2n
Die Entwicklung einer Attributgrammatik f\*ur die semantische Analyse ist eine
relativ komplexe und aufwendige Aufgabe und der Teil der Arbeit, der
dabei von einem Generator wie \%\fIAg\fP \*ubernommen werden kann, ist im
Vergleich
z.B. zur Arbeitserleichterung bei der automatischen Erzeugung eines Zerteilers
aus einer kontextfreien Grammatik relativ klein. Die f\*ur die semantische
Analyse von \%\fIMtc\fP entwickelte Attributgrammatik ist sicher nur ein erster
Ansatz im Hinblick auf Kombination von abstrakten Datentypen und
Attributgrammatiken einschlie\*slich dem Einsatz von kontrollierten
Seiteneffekten und k\*onnte in mancherlei Hinsicht verbessert werden. Die
Entwicklung einer kompletten Attributgrammatik f\*ur die semantische Analyse von
Modula-2, die sowohl Forderungen hinsichtlich Lesbarkeit,
Verst\*andlichkeit und Vollst\*andigkeit als auch hinsichtlich Effizienz des
daraus erzeugten Attributauswerters erf\*ullt, ist sicher ein interessantes
Forschungs- und/oder Diplomarbeitsthema.
.sp 0.4v
.ne 2v
.ti +2n
Eine letzte Bemerkung zu \%\fIAg\fP gilt der Speicherung der Attributwerte. In
der bisherigen Version von \%\fIAg\fP werden s\*amtliche Attribute im Baum
gespeichert. Wie die Messungen in Kapitel \n(h1.2
zeigen ist dies \(em im Gegensatz zu anderslautenden
Feststellungen in der Literatur \(em heute aufgrund der gewachsenen
Hauptspeichergr\*o\*sen durchaus m\*oglich. Allerdings sollten dabei die folgenden
Punkte ber\*ucksichtigt werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der \*Ubersetzer \%\fIMtc\fP
enth\*alt keine vollst\*andige semantische Analyse. Eine
solche vollst\*andige semantische Analyse w\*urde zu einer h\*oheren
Anzahl von Attributen und damit zu einem h\*oheren Attributspeicherbedarf
f\*uhren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei der Implementierung wurde wegen der fehlenden Speicheroptimierung
stark auf den Speicherbedarf der Attributwerte geachtet und f\*ur die
Attributtypen wann immer m\*oglich Typen der Zielsprache mit m\*oglichst geringem
Speicherbedarf verwendet.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Durch den Einsatz von
in der Zielsprache implementierten abstrakten Datentypen, die mit Hilfe von
Zeigertypen realisiert wurden, wird erreicht, da\*s die meisten
im Baum gespeicherten Attribute nur Zeiger auf die eigentlichen Attributwerte
(Objekt- und Typbeschreibungen, Umgebungsattribute, usf.)
sind.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Somit wurde ein wesentlicher
Teil der Optimierung des Attributspeicherbedarfs bereits ,,von Hand''
vorweggenommen.
Es ist daher fraglich, ob es nicht doch sinnvoll w\*are
trotz der heutigen Hauptspeichergr\*o\*sen,
eine Optimierung der Attributspeicherung in \%\fIAg\fP einzubauen.
Eine solche eventuelle Optimierung wurde in der Attributgrammatik
bereits vorbereitet, indem alle Attribute, die noch in der Codeerzeugung
ben\*otigt werden, als ,,output'' Attribute [Grosch\|89a]
gekennzeichnet wurden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Estra\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Estra
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Erfahrungen des Verfassers bei diesem Einsatz von \%\fIEstra\fP sind sehr
positiv. Der \*Ubergang von einer direkten Implementierung zu
einer Spezifikation des Codegenerators mit \%\fIEstra\fP hat eine Reihe von
Vorteilen.
Der Benutzer wird durch die Spezifikation von
implementierungstechnischen Details wie der Traversierung des Baums entlastet.
Die Auswahl bestimmter Transformationsvorschriften durch den Codegenerator kann
auf einem h\*oheren Abstraktionsniveau mit Mustern, Bedingungen und Kosten
beschrieben werden. Au\*serdem werden die Zugriffe auf in den Mustern
vorkommende Teilb\*aume und deren Attribute von \%\fIEstra\fP unterst\*utzt und
vereinfacht. Insgesamt ergibt sich eine bessere Lesbarkeit und
Verst\*andlichkeit der Codeerzeugung aufgrund des h\*oheren Abstraktionsniveaus
der Spezifikation. Au\*serdem wird eine leichtere \*Anderbarkeit und Wartbarkeit
des Codegenerators erreicht.
.sp 0.4v
.ne 2v
.ti +2n
Die Laufzeiteffizienz des erzeugten Codegenerators ist, wie die Messungen aus
Kapitel \n(h1.2 zeigen, ebenfalls gut. Allerdings f\*allt der Codegenerator
mit insgesamt 7571 Zeilen recht gro\*s aus. Hier w\*are vielleicht eine M\*oglichkeit
zur Modularisierung sowohl der Spezifikation als auch der daraus erzeugten
Implementierung angebracht.
.sp 0.4v
.ne 2v
.ti +2n
Hauptkritikpunkt an \%\fIEstra\fP ist der bereits in Kapitel 5.6.2
erw\*ahnte und in den Messungen in Kapitel \n(h1.2 noch einmal deutlich
dokumentierte extrem hohe Speicherbedarf des von \%\fIEstra\fP erzeugten
Codegenerators. Dieser Speicherbedarf resultiert daraus, da\*s \%\fIEstra\fP bei
der Vorbereitung der Transformation f\*ur jeden Knoten des Strukturbaums einen
Informationsblock anlegt, der f\*ur jede Funktion der Spezifikation die auf
diesen Knoten anwendbare Vorschrift und die Kosten dieser Anwendung enth\*alt
(vgl. Kap. 5.6.2). Es mu\*s aber bereits in der Spezifikation f\*ur jede
Funktion angegeben werden, auf welche Knotentypen diese Funktion anwendbar ist.
Betrachtet man die Spezifikation des Codegenerators von \%\fIMtc\fP, die 22
Funktionen umfa\*st, dann stellt man fest, da\*s im Mittel nur ca. 2 der 22
Funktionen auf jeden Knotentyp anwendbar sind. Das bedeutet aber, da\*s
\*uber 90\|% des
dynamisch angeforderten Speichers v\*ollig umsonst
angefordert werden, da dort nur die bereits aus der Spezifikation bekannte
Tatsache festgehalten wird, da\*s die meisten Funktionen auf den jeweiligen
Knoten des Strukturbaums \*uberhaupt nicht anwendbar sind. W\*urde \%\fIEstra\fP
f\*ur jeden Knoten nur einen Informationsblock anlegen, der Informationen \*uber
die auf diesen Knoten anwendbaren
Funktionen enth\*alt, k\*onnte der
Speicherbedarf des Codegenerators auf unter 1/10 reduziert werden.
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Zusammenfassung und Ausblick\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Zusammenfassung und Ausblick
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
Zentraler Teil dieser Diplomarbeit bildet die Definition einer
vollst\*andigen Abbildung von \%Modula-2 nach C. Insbesondere wurde auch
gezeigt wie statisch geschachtelte Prozedurdeklarationen und das Modulkonzept
von \%Modula-2 nach C abgebildet werden k\*onnen. \%Modula-2
besitzt zwar ein deutlich h\*oheres Abstraktionsniveau, aber durch eine
Kombination von primitiveren C-Konstrukten k\*onnen auch in C nicht direkt
vorhandene Modula-Konstrukte realisiert werden. Einzige Ausnahme hierbei bilden die
Koroutinen f\*ur deren Abbildung kein geeignetes C-Konstrukt existiert.
.sp 0.4v
.ne 2v
.ti +2n
Im Rahmen dieser Diplomarbeit wurde ebenfalls der \*Ubersetzer \%\fIMtc\fP
entwickelt, der die oben beschriebene Abbildung implementiert und
die Modula-Programme in lesbaren C-Code umsetzt. Etwa 3/4 des Quellcodes von
\%\fIMtc\fP besteht aus Moduln, die mit den an der GMD Forschungsstelle
Karlsruhe entwickelten \*Ubersetzerbauwerkzeugen \%\fIRex\fP, \%\fIEll\fP,
\%\fIAst\fP, \%\fIAg\fP und \%\fIEstra\fP aus Spezifikationen erzeugt wurden.
Da \%\fIMtc\fP nicht f\*ur die Programmentwicklung, sondern f\*ur die \*Ubertragung
von fertig entwickelten Modula-Programmen nach C gedacht ist, wird die
semantische Korrektheit der Eingabeprogramme nicht \*uberpr\*uft.
Die \*Ubersetzungsleistung von \%\fIMtc\fP ist mit ca. 150 Zeilen in der Sekunde
an einer SUN-Workstation (MC68020-Prozessor) sehr gut;
allerdings ist der Speicherbedarf
mit bis zu 800 Kilobyte je 1000 Zeilen Quellprogramm relativ hoch.
.sp 0.4v
.ne 2v
.ti +2n
Da an der GMD Forschungsstelle Karlsruhe \%Modula-2 seit mehreren Jahren
f\*ur die Pro\%gramm\%ent\%wick\%lung eingesetzt wird, bestand an geeigneten
Testprogrammen f\*ur \%\fIMtc\fP kein Mangel und anf\*anglich noch
vorhandene Schw\*achen der Abbildung konnten schnell aufgedeckt und beseitigt
werden.
Bisher wurden u.a. folgende Programme mit \%\fIMtc\fP erfolgreich nach C
\*ubertragen: der \*Ubersetzer \%\fIMtc\fP selbst, der Modula-\*Ubersetzer
\%MOCKA sowie die \*Ubersetzerbauwerkzeuge \%\fIRex\fP, \%\fIEll\fP und
\%\fILalr\fP.
Wie erste Messungen zeigen ist die Qualit\*at des erzeugten C-Codes
ebenfalls gut: Die erzeugten C-Programme sind kleiner und schneller als
die urspr\*unglichen Modula-Programme.
.sp 0.4v
.ne 2v
.ti +2n
Erste Benutzerw\*unsche legen den Schlu\*s nahe, da\*s die in Kapitel 4.2.4
begr\*undete Entscheidung, Kommentare nicht von \%Modula-2 nach C zu
\*ubersetzen, doch noch einmal \*uberdacht werden sollte. Durch eine
Ber\*ucksichtigung von ,,typischen'' Konventionen, die f\*ur die Kommentierung in
der Regel unbewu\*st eingehalten werden, w\*are es vielleicht m\*oglich, eine
L\*osung zu implementieren, die die Kommentare wenigstens in den meisten F\*allen
im C-Programm richtig plaziert und nur in wenigen F\*allen eine manuelle
Verschiebung durch den Benutzer erfordert. Allerdings sollte aus diesem Grund
die \*Ubersetzung der Kommentare optional sein und nur auf ausdr\*ucklichen
Wunsch des Benutzers stattfinden.
.sp 0.4v
.ne 2v
.ti +2n
Die Implementierung von \%\fIMtc\fP lie\*se sich sicher noch in mancher Hinsicht
verbessern. Wichtigster Punkt w\*are eine Reduktion des in Kapitel 6.2
dokumentierten hohen Speicherbedarfs von \%\fIMtc\fP.
Eine bessere Darstellung der in den Knoten des Strukturbaums
bei der Vorbereitung der Codeerzeugung abgelegten
Informationen durch \%\fIEstra\fP
und eine Optimierung der Attributspeicherung durch \%\fIAg\fP
w\*urde den Speicherbedarf des \*Ubersetzers deutlich reduzieren.
.sp 0.4v
.ne 2v
.ti +2n
Ein weiterer Punkt w\*are eine interpretative Auswertung
von konstanten Ausdr\*ucken, die es
auch erm\*oglicht, \*Uberl\*aufe zu erkennen und konstante Ausdr\*ucke mit
Operanden im Bereich
\%MAX\^(INTEGER)\|+\|1\|..\|\%MAX\^(CARDINAL)
auswerten zu k\*onnen.
.sp 0.4v
.ne 2v
.ti +2n
Der hohe Aufwand f\*ur die Bezeichneridentifikation, der auf eine Implementierung
der Umgebungsattribute mit Listen zur\*uckzuf\*uhren ist (f\*ur gro\*se Programme
ca. 20\|% der gesamten \*Ubersetzungszeit), k\*onnte m\*oglicherweise durch eine
Implementierung der Umgebungsattribute mit Hilfe von Suchb\*aumen reduziert
werden.
.sp 0.4v
.ne 2v
.ti +2n
Die \*Ubersetzerbauwerkzeuge \%\fIRex\fP, \%\fIEll\fP und \%\fIAst\fP sind
weitgehend ausgereift und eignen sich wegen der enormen Arbeitserleichterung
f\*ur den \*Ubersetzerbauer, aber auch wegen der hohen Laufzeiteffizienz der
erzeugten \*Ubersetzerteile, f\*ur einen Einsatz auch in der Konstruktion von
\*Ubersetzern mit Produktionsqualit\*at.
.sp 0.4v
.ne 2v
.ti +2n
Die Prototypen \%\fIAg\fP und \%\fIEstra\fP bieten erste interessante Ans\*atze
f\*ur eine Spezifikation der semantischen Analyse und der
(Zwischen-)Codeerzeugung, insbesondere sind die erzeugten \*Ubersetzerteile sehr
laufzeiteffizient. Allerdings besteht nach Ansicht des Verfassers dieser Diplomarbeit noch
ein Entwicklungsbedarf sowohl hinsichtlich Ausdruckskraft der Spezifikationen
als auch hinsichtlich des Speicherbedarfs der erzeugten \*Ubersetzerteile bevor
ein Einsatz dieser Werkzeuge auch au\*serhalb von Forschungsprojekten m\*oglich
ist.
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Anhang\ A: Abstrakte Syntax von Modula-2\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Anhang\ A: Abstrakte Syntax von Modula-2
.hE 0 4n 0.1v
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TREE
.sp 0.4v
IMPORT  {
FROM StringMem  IMPORT tStringRef;
FROM Idents     IMPORT tIdent;
FROM Errors     IMPORT tPosition;
}
.sp 0.4v
EXPORT  {
CONST
  Definition            =  1;           (* compilation unit kind        *) 
  Foreign               =  2;
  Implementation        =  3;
  Program               =  4;
.sp 0.4v
  NotEqual              =  1;           (* operators                    *)
  Times                 =  2;
  Plus                  =  3;
  Minus                 =  4;
  Divide                =  5;
  Less                  =  6;
  LessEqual             =  7;
  Equal                 =  8;
  Greater               =  9;
  GreaterEqual          = 10;
  And                   = 11;
  Div                   = 12;
  In                    = 13;
  Mod                   = 14;
  Not                   = 15;
  Or                    = 16;
.sp 0.4v
  Decimal               =  1;           (* integer constant kind        *)
  Octal                 =  2;
  Hexadecimal           =  3;
}
.sp 0.4v
GLOBAL  {
FROM StringMem  IMPORT tStringRef;
FROM Idents     IMPORT tIdent;
FROM Errors     IMPORT tPosition;
}
.sp 0.4v
RULE
.sp 0.4v
ROOT            = CompUnits .
.sp 0.4v
CompUnits       = <
  CompUnits0    = .
  CompUnit      = [Kind: SHORTCARD] [Ident: tIdent] [Pos: tPosition]
                  Next: CompUnits REVERSE <
    DefMod      = Import Decls .
    ProgMod     = Import Decls Stmts .
  >.
>.
.sp 0.4v
Import          = <
  Import0       = .
  Import1       = Next: Import REVERSE <
    From        = [Ident: tIdent] [Pos: tPosition] ImpIds .
    Objects     = ImpIds .
  >.
>.
.sp 0.4v
ImpIds          = <
  ImpIds0       = .
  ImpIds1       = [Ident: tIdent] [Pos: tPosition] Next: ImpIds REVERSE .
>.
.sp 0.4v
Export          = <
  Export0       = .
  Export1       = [Qualified: BOOLEAN] ExpIds .
>.
.sp 0.4v
ExpIds          = <
  ExpIds0       = .
  ExpIds1       = [Ident: tIdent] Next: ExpIds REVERSE .
>.
.sp 0.4v
Decls           = <
  Decls0        = .
  Decl          = Next: Decls REVERSE <
    Var         = VarIds Type .
    Object      = [Ident: tIdent] <
      Const     = Expr .
      TypeDecl  = Type [Pos: tPosition] .
      Proc      = Formals ResultType: PrimaryType Decls Stmts .
      ProcHead  = Formals ResultType: PrimaryType [Pos: tPosition] .
      Module    = Import Export Decls Stmts .
      Opaque    = .
    >.
  >.
>.
.sp 0.4v
VarIds          = <
  VarIds0       = .
  VarIds1       = [Ident: tIdent] Next: VarIds REVERSE .
>.
.sp 0.4v
Formals         = <
  Formals0      = .
  Formals1      = [IsVAR: BOOLEAN] ParIds Type Next: Formals REVERSE .
>.
.sp 0.4v
ParIds          = <
  ParIds0       = .
  ParIds1       = [Ident: tIdent] Next: ParIds REVERSE .
>.
.sp 0.4v
Type            = <
  Array         = [IsOpen: BOOLEAN] IndexType: SimpleType ElemType: Type .
  Record        = Fields .
  SetType       = BaseType: SimpleType .
  Pointer       = TargetType: Type .
  ProcType      = FormalTypes ResultType: PrimaryType .
  SimpleType    = <
    Enumeration = EnumIds .
    Subrange    = BaseType: PrimaryType Lwb: Expr Upb: Expr .
    PrimaryType = <
      Void      = .
      TypeId    = [Ident: tIdent] [Pos: tPosition] <
        TypeId0 = .
        TypeId1 = TypeId .
      >.
    >.
  >.
>.
.sp 0.4v
Fields          = <
  Fields0       = .
  Fields1       = Next: Fields REVERSE <
    RecordSect  = FieldIds Type .
    VariantSect = TagField Variants Else: Fields.
  >.
>.
.sp 0.4v
FieldIds        = <
  FieldIds0     = .
  FieldIds1     = [Ident: tIdent] Next: FieldIds REVERSE .
>.
.sp 0.4v
TagField        = Type: TypeId <
  TagField0     = .
  TagField1     = [Ident: tIdent] .
>.
.sp 0.4v
Variants        = <
  Variants0     = .
  Variant       = Labels Variant: Fields Next: Variants REVERSE .
>.
.sp 0.4v
FormalTypes     = <
  FormalTypes0  = .
  FormalType    = [IsVAR: BOOLEAN] Type Next: FormalTypes REVERSE .
>.
.sp 0.4v
EnumIds         = <
  EnumIds0      = .
  EnumIds1      = [Ident: tIdent] Next: EnumIds REVERSE .
>.
.sp 0.4v
Expr            = <
  Binary        = [Operator: SHORTCARD] Lop: Expr Rop: Expr .
  Unary         = [Operator: SHORTCARD] Mop: Expr .
  IntConst      = [Kind: SHORTCARD] [IntVal: CARDINAL] [Pos: tPosition] .
  RealConst     = [RealVal: tStringRef] .
  StringConst   = [StringVal: tStringRef] .
  CharConst     = [CharVal: CHAR] .
  FuncCall      = Designator Actuals .
  Set           = BaseType: Qualid Elems .
  BitSet        = Elems .
  Designator    = [Pos: tPosition] <
    Qualid      = [Ident: tIdent] <
      Qualid0   = .
      Qualid1   = Qualid .
    >.
    Subscript   = Designator Index: Expr .
    Deref       = Designator .
    Select      = Designator [Field: tIdent] .
  >.
>.
.sp 0.4v
Elems           = <
  Elems0        = .
  Elems1        = Next: Elems REVERSE <
    Elem        = Elem: Expr .
    ElemRange   = Lwb: Expr Upb: Expr .
  >.
>.
.sp 0.4v
Actuals         = <
  Actuals0      = .
  Actual        = Expr Next: Actuals REVERSE .
>.
.sp 0.4v
Stmts           = <
  Stmts0        = .
  Stmt          = Next: Stmts REVERSE <
    Assign      = Designator Expr .
    Call        = Designator Actuals .
    If          = Cond: Expr Then: Stmts Elsifs Else: Stmts .
    Case        = Expr Cases Else: Stmts [Default: BOOLEAN] .
    While       = Cond: Expr Stmts .
    Repeat      = Stmts Cond: Expr .
    Loop        = Stmts .
    For         = Qualid From: Expr To: Expr By: Expr Stmts .
    With        = Designator Stmts .
    Exit        = .
    Return1     = .
    Return2     = Result: Expr .
  >.
>.
.sp 0.4v
Elsifs          = <
  Elsifs0       = .
  Elsifs1       = Cond: Expr Stmts Next: Elsifs REVERSE .
>.
.sp 0.4v
Cases           = <
  Cases0        = .
  Cases1        = Labels Stmts Next: Cases REVERSE .
>.
.sp 0.4v
Labels          = <
  Labels0       = .
  Labels1       = Next: Labels REVERSE <
    Label       = Label: Expr .
    LabelRange  = Lwb: Expr Upb: Expr .
  >.
>.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Anhang\ B: Beispiel f\*ur den erzeugten C-Code\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Anhang\ B: Beispiel f\*ur den erzeugten C-Code
.hE 0 4n 0.1v
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
(*====== Modula-Programm ===============================================*)
.sp 0.4v
(*------ Tree.md -------------------------------------------------------*)
.sp 0.4v
DEFINITION MODULE Tree;
.sp 0.4v
CONST NoTree    = NIL;
.sp 0.4v
TYPE
  tTree         = POINTER TO tNode;
  tNode         = RECORD
                    Key         : INTEGER;
                    Count       : CARDINAL;
                    Left, Right : tTree;
                  END;
.sp 0.4v
  tProcOfNode   = PROCEDURE (INTEGER, CARDINAL);
.sp 0.4v
VAR Root        : tTree;
.sp 0.4v
PROCEDURE Insert        (x: INTEGER; VAR t: tTree);
PROCEDURE Delete        (x: INTEGER; VAR t: tTree);
PROCEDURE InOrder       (t: tTree; p: tProcOfNode);
.sp 0.4v
END Tree.
.sp 0.4v
(*------ Tree.mi -------------------------------------------------------*)
.sp 0.4v
IMPLEMENTATION MODULE Tree;
.sp 0.4v
FROM Storage    IMPORT ALLOCATE, DEALLOCATE;
.sp 0.4v
PROCEDURE Insert (x: INTEGER; VAR t: tTree);
BEGIN
  IF t = NoTree THEN
    NEW (t);
    WITH t^ DO
      Key := x; Count := 1;
      Left := NoTree; Right := NoTree;
    END;
  ELSIF x < t^.Key THEN Insert (x, t^.Left);
  ELSIF x > t^.Key THEN Insert (x, t^.Right);
  ELSE
    INC (t^.Count);
  END;
END Insert;
.sp 0.4v
PROCEDURE Delete (x: INTEGER; VAR t: tTree);
  VAR s : tTree;
.sp 0.4v
  PROCEDURE del (VAR t: tTree);
  BEGIN
    IF t^.Right # NoTree THEN
      del (t^.Right);
    ELSE
      s^.Key := t^.Key; s^.Count := t^.Count;
      s := t; t := t^.Left;
    END;
  END del;
.sp 0.4v
BEGIN
  IF t # NoTree THEN
    IF x < t^.Key THEN Delete (x, t^.Left);
    ELSIF x > t^.Key THEN Delete (x, t^.Right);
    ELSE
      s := t;
      IF s^.Right = NoTree THEN t := s^.Left;
      ELSIF s^.Left = NoTree THEN t := s^.Right;
      ELSE del (s^.Left);
      END;
      DISPOSE (s);
    END;
  END;
END Delete;
.sp 0.4v
PROCEDURE InOrder (t: tTree; p: tProcOfNode);
BEGIN
  IF t # NoTree THEN
    InOrder (t^.Left, p);
    p (t^.Key, t^.Count);
    InOrder (t^.Right, p);
  END;
END InOrder;
.sp 0.4v
BEGIN
  Root := NoTree;
END Tree.
.sp 0.4v
(*------ Main.mi -------------------------------------------------------*)
.sp 0.4v
MODULE Main;
.sp 0.4v
FROM StdIO      IMPORT ReadI, ReadNl, WriteI, WriteNl, CloseIO;
FROM Tree       IMPORT tTree, NoTree, Root, Insert, Delete, InOrder;
.sp 0.4v
CONST cMax = 4;
.sp 0.4v
VAR
  i : SHORTCARD;
  x : INTEGER;
  a : ARRAY [1..cMax] OF INTEGER;
.sp 0.4v
MODULE TestOutput;
.sp 0.4v
IMPORT WriteI; EXPORT WriteArray, WriteNode;
.sp 0.4v
  VAR i : CARDINAL;
.sp 0.4v
  PROCEDURE WriteArray (VAR a: ARRAY OF INTEGER);
  BEGIN
    FOR i := 0 TO HIGH (a) DO WriteI (a[i], 5); END;
  END WriteArray;
.sp 0.4v
  PROCEDURE WriteNode (Key: INTEGER; Count: CARDINAL);
  BEGIN
    FOR i := Count TO 1 BY -1 DO WriteI (Key, 5); END;
  END WriteNode;
.sp 0.4v
END TestOutput;
.sp 0.4v
BEGIN
  FOR i := 1 TO cMax DO a[i] := ReadI (); Insert (a[i], Root); END; ReadNl;
  WriteArray (a); WriteNl;
  REPEAT
    InOrder (Root, WriteNode); WriteNl;
    x := ReadI (); ReadNl;
    Delete (x, Root);
  UNTIL Root = NoTree;
  CloseIO;
END Main.
.sp 0.4v
.br
.ne 8
(*====== Von Mtc erzeugtes C-Programm ==================================*)
.sp 0.4v
/*------ Tree.h --------------------------------------------------------*/
.sp 0.4v
#define DEFINITION_Tree
.sp 0.4v
#define Tree_NoTree	NIL
typedef struct Tree_1 *Tree_tTree;
typedef struct Tree_1 {
    INTEGER Key;
    CARDINAL Count;
    Tree_tTree Left, Right;
} Tree_tNode;
typedef void (*Tree_tProcOfNode)();
extern Tree_tTree Tree_Root;
extern void Tree_Insert();
extern void Tree_Delete();
extern void Tree_InOrder();
extern void BEGIN_Tree();
.sp 0.4v
/*------ Tree.c --------------------------------------------------------*/
.sp 0.4v
#include "SYSTEM_.h"
.sp 0.4v
#ifndef DEFINITION_Storage
#include "Storage.h"
#endif
.sp 0.4v
#ifndef DEFINITION_Tree
#include "Tree.h"
#endif
.sp 0.4v
Tree_tTree Tree_Root;
.sp 0.4v
static void del();
.sp 0.4v
static Tree_tTree *G_1_s;
.sp 0.4v
void
Tree_Insert(x, t)
INTEGER x;
Tree_tTree *t;
{
  if (*t == Tree_NoTree) {
    Storage_ALLOCATE(t, sizeof(Tree_tNode));
    {
      register Tree_tNode *W_1 = *t;
.sp 0.4v
      W_1->Key = x;
      W_1->Count = 1;
      W_1->Left = Tree_NoTree;
      W_1->Right = Tree_NoTree;
    }
  } else if (x < (*t)->Key) {
    Tree_Insert(x, &(*t)->Left);
  } else if (x > (*t)->Key) {
    Tree_Insert(x, &(*t)->Right);
  } else {
    INC((*t)->Count);
  }
}
.sp 0.4v
static void
del(t)
Tree_tTree *t;
{
  if ((*t)->Right != Tree_NoTree) {
    del(&(*t)->Right);
  } else {
    (*G_1_s)->Key = (*t)->Key;
    (*G_1_s)->Count = (*t)->Count;
    *G_1_s = *t;
    *t = (*t)->Left;
  }
}
.sp 0.4v
void
Tree_Delete(x, t)
INTEGER x;
Tree_tTree *t;
{
  Tree_tTree s;
  Tree_tTree *L_1;
.sp 0.4v
  L_1 = G_1_s;
  G_1_s = &s;
  if (*t != Tree_NoTree) {
    if (x < (*t)->Key) {
      Tree_Delete(x, &(*t)->Left);
    } else if (x > (*t)->Key) {
      Tree_Delete(x, &(*t)->Right);
    } else {
      s = *t;
      if (s->Right == Tree_NoTree) {
        *t = s->Left;
      } else if (s->Left == Tree_NoTree) {
        *t = s->Right;
      } else {
        del(&s->Left);
      }
      Storage_DEALLOCATE(&s, sizeof(Tree_tNode));
    }
  }
  G_1_s = L_1;
}
.sp 0.4v
void
Tree_InOrder(t, p)
Tree_tTree t;
Tree_tProcOfNode p;
{
  if (t != Tree_NoTree) {
    Tree_InOrder(t->Left, p);
    (*p)(t->Key, t->Count);
    Tree_InOrder(t->Right, p);
  }
}
.sp 0.4v
void BEGIN_Tree()
{
  static BOOLEAN has_been_called = FALSE;
.sp 0.4v
  if (!has_been_called) {
    has_been_called = TRUE;
.sp 0.4v
    BEGIN_Storage();
.sp 0.4v
    Tree_Root = Tree_NoTree;
  }
}
.sp 0.4v
/*------ Main.c --------------------------------------------------------*/
.sp 0.4v
#include "SYSTEM_.h"
.sp 0.4v
#ifndef DEFINITION_StdIO
#include "StdIO.h"
#endif
.sp 0.4v
#ifndef DEFINITION_Tree
#include "Tree.h"
#endif
.sp 0.4v
#define cMax	4
static SHORTCARD i;
static INTEGER x;
static struct S_1 {
    INTEGER A[cMax - 1 + 1];
} a;
static CARDINAL C_1_i;
static void WriteArray();
static void WriteNode();
.sp 0.4v
static void
WriteArray(a, O_1)
INTEGER a[];
LONGCARD O_1;
{
  {
    LONGCARD B_1 = 0, B_2 = (O_1 - 1);
.sp 0.4v
    if (B_1 <= B_2)
      for (C_1_i = B_1;; C_1_i += 1) {
        StdIO_WriteI(a[C_1_i], 5);
        if (C_1_i >= B_2) break;
      }
  }
}
.sp 0.4v
static void
WriteNode(Key, Count)
INTEGER Key;
CARDINAL Count;
{
  for (C_1_i = Count; C_1_i >= 1; C_1_i += -1) {
    StdIO_WriteI(Key, 5);
  }
}
.sp 0.4v
static void TestOutput()
{}
.sp 0.4v
void BEGIN_MODULE()
{
  BEGIN_StdIO();
  BEGIN_Tree();
  TestOutput();
.sp 0.4v
  for (i = 1; i <= cMax; i += 1) {
    a.A[i - 1] = StdIO_ReadI();
    Tree_Insert(a.A[i - 1], &Tree_Root);
  }
  StdIO_ReadNl();
  WriteArray(a.A, 4L);
  StdIO_WriteNl();
  do {
    Tree_InOrder(Tree_Root, WriteNode);
    StdIO_WriteNl();
    x = StdIO_ReadI();
    StdIO_ReadNl();
    Tree_Delete(x, &Tree_Root);
  } while (!(Tree_Root == Tree_NoTree));
  StdIO_CloseIO();
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Anhang\ C: UNIX-Manualseite f\*ur Mtc\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Anhang\ C: UNIX-Manualseite f\*ur Mtc
.hE 0 4n 0.1v
NAME
.br
.in +4n
\&mtc - Modula-2 to C Translator
.in -4n
.sp 0.4v
SYNOPSIS
.br
.in +4n
\&\fBmtc\fP [ options ] [ file ]
.in -4n
.sp 0.4v
DESCRIPTION
.br
.in +4n
\&\%\fIMtc\fP translates \%Modula-2 programs into readable C code.
\%\fIMtc\fP implements the language \%Modula-2 as defined in N. Wirth's
report (3rd edition)
with a few minor restrictions (see below) and most language extensions
implemented by \%\fIMOCKA\fP,
the \%Modula-2 Compiler Karlsruhe. It produces K&R (not ANSI)
C code with a few very common extensions like passing structures as value
parameters.
.sp 0.4v
A definition or foreign module \fImodule\fP.md is translated into a C header file
\fImodule\fP.h. An implementation or program module \fImodule\fP.mi is translated
into the corresponding C source file \fImod\%ule\fP.c.
Separate compilation is
handled by reprocessing all transitively imported def\%i\%ni\%tion modules when
translating a compilation unit. If \fIfile\fP is omitted \fImtc\fP reads from
standard input.
.sp 0.4v
\%\fIMtc\fP is intended as a tool for translating finished programs from
\%Modula-2 to C and not as a tool for program development.
Therefore, the translator
does not check the semantic correctness of the \%Modula-2 programs.
.sp 0.4v
For each foreign module an empty implementation module corresponding to it
has to be translated to C, because the initialization routine
produced for the dummy implementation module is used
within the modules resp. C programs which import
the foreign module.
.sp 0.4v
If the library function \fIalloca\fP is available and the C programs
are compiled with the flag -D\fIStackAlloc\fP\^, then the memory
space for open array value parameters will be allocated in the
stack frame of the corresponding procedure. This temporary
space will be freed automatically when the procedure returns.
Otherwise, \fImalloc\fP and \fIfree\fP will be used to allocate and deallocate
memory space for open array value parameters.
.in -4n
.sp 0.4v
OPTIONS
.br
.in +4n
.br
.ne 2v
\&-w
.in +12n
.if \w'-w\ 'u<12n .sp -1v
\&Suppress warning diagnostics.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-i
.in +12n
.if \w'-i\ 'u<12n .sp -1v
\&Generate header files for imported modules.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-c
.in +12n
.if \w'-c\ 'u<12n .sp -1v
\&Generate type casts to make the C programs \%\fIlint\fP free.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-r
.in +12n
.if \w'-r\ 'u<12n .sp -1v
\&Generate runtime checks.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-h
.in +12n
.if \w'-h\ 'u<12n .sp -1v
\&Print help information.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-t
.in +12n
.if \w'-t\ 'u<12n .sp -1v
\&Print test output (time).
.in -12n
.sp 0.2v
.br
.ne 2v
\&-m
.in +12n
.if \w'-m\ 'u<12n .sp -1v
\&Print test output (memory).
.in -12n
.sp 0.2v
.br
.ne 2v
\&-d\fIdir\fP
.in +12n
.if \w'-d\fIdir\fP\ 'u<12n .sp -1v
\&Allow import from modules in library \fIdir\fP.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-l\fIdir\fP
.in +12n
.if \w'-l\fIdir\fP\ 'u<12n .sp -1v
\&Specify directory where \fImtc\fP finds its tables.
.in -12n
.in -4n
.sp 0.4v
FILES
.br
.in +4n
.br
.ne 2v
\&\fImodule\fP.md
.in +16n
.if \w'\fImodule\fP.md\ 'u<16n .sp -1v
\&Source file of definition or foreign module \fImodule\fP.
.in -16n
.sp 0.2v
.br
.ne 2v
\&\fImodule\fP.mi
.in +16n
.if \w'\fImodule\fP.mi\ 'u<16n .sp -1v
\&Source file of implementation or program module \fImodule\fP.
.in -16n
.sp 0.2v
.br
.ne 2v
\&\fImodule\fP.h
.in +16n
.if \w'\fImodule\fP.h\ 'u<16n .sp -1v
\&C header file produced for \fImodule\fP.md.
.in -16n
.sp 0.2v
.br
.ne 2v
\&\fImodule\fP.c
.in +16n
.if \w'\fImodule\fP.c\ 'u<16n .sp -1v
\&C source file produced for \fImodule\fP.mi.
.in -16n
.sp 0.2v
.br
.ne 2v
\&SYSTEM_.h
.in +16n
.if \w'SYSTEM_.h\ 'u<16n .sp -1v
\&Definition of standard constants, types, functions, and
macros, which are used in the generated C programs.
.in -16n
.sp 0.2v
.br
.ne 2v
\&SYSTEM_.c
.in +16n
.if \w'SYSTEM_.c\ 'u<16n .sp -1v
\&Main program and implementation of standard functions.
.in -16n
.in -4n
.sp 0.4v
SEE ALSO
.br
.in +4n
\&\fIEntwurf und Implementierung eines \*Ubersetzers von \%Modula-2 nach C\fP
by M. Martin.
.in -4n
.sp 0.2v
.in +4n
\&\fIProgramming in Modula-2\fP (3rd edition) by N. Wirth.
.in -4n
.sp 0.2v
.in +4n
\&\fIMOCKA User Manual\fP by F. Engelmann.
.in -4n
.sp 0.2v
.in +4n
\&\fIThe C Programming Language\fP by B. W. Kernighan and D. M. Ritchie.
.in -4n
.sp 0.4v
DIAGNOSTICS
.br
.in +4n
\&The translator reports lexical and syntactic errors, errors detected during
the handling of separate compilation, and restrictions of the code generation.
The translator does not check the semantic correctness of the \%Modula-2
programs. The diagnostics produced by \fImtc\fP are intended to be
self-explanatory.
.in -4n
.sp 0.4v
BUGS
.br
.in +4n
\&Coroutines are not supported.
.sp 0.2v
Forward references within pointer declarations are limited to structured types.
.sp 0.2v
Comments are not translated from \%Modula-2 to C.
.sp 0.2v
In some very rare cases the translator has to evaluate constant expressions,
because a literal translation is not possible. The translator will fail to do
this, if the expression or one of
its operands is not in the range \%MIN(INTEGER)\|..\|\%MAX(INTEGER).
.in -4n
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Anhang\ D: Verzeichnis der vom \*Ubersetzer erzeugten Bezeichner\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Anhang\ D: Verzeichnis der vom \*Ubersetzer erzeugten Bezeichner
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
Die folgende Tabelle gibt einen \*Uberblick \*uber Bezeichner und
Bedeutung der vom \*Ubersetzer \%\fIMtc\fP erzeugten C-Objekte. Die Abk\*urzung
\%\fInnn\fP steht dabei f\*ur eine eindeutige, vom \*Ubersetzer vergebene Nummer.
.sp 0.4v
\s-2
.TS
delim($$)tab(|) center expand box;
c| c
l| lw(12c).
Bezeichner|Bedeutung
_
A|T{
Abbildung von Feldern auf Strukturen mit einem Vektor A als einziger
Komponente (s. Kap. 4.4.2.5)
T}|
BEGIN_MODULE|T{
Rumpf von Programmoduln (s. Kap. 4.8.7)
T}
BEGIN_\fIModulname\fP|T{
Initialisierungsroutine (Rumpf) des (Implementierungs-)Moduls
\%\fIModulname\fP (s. Kap. 4.8.6)
T}
B_\fInnn\fP|T{
Anfangs- bzw. Endwert von FOR-Schleifen (s. Kap. 4.6.5)
T}
DEFINITION_\fIM\fP|T{
Makroname f\*ur die Steuerung des Einf\*ugens der Definitionsdatei
des Moduls \%\fIM\fP mit #include-An\%wei\%sun\%gen in alle Moduln,
die \%\fIM\fP importieren (s. Kap. 4.8.1 u. 4.8.4)
T}
EXIT_\fInnn\fP|T{
Sprungziel f\*ur EXIT-Anweisungen (s. Kap. 4.6.5)
T}
G_\fInnn\fP\^_\fIName\fP|T{
Abbildung von statisch geschachtelten Prozedurdeklarationen:
Globaler Zeiger auf lokale Variable \%\fIName\fP (s. Kap. 4.4.4)
T}
L_\fInnn\fP|T{
Lokale Zeigervariable f\*ur die Kellerung der Werte von G_\fInnn_Name\fP
bei Rekursion
(s. Kap. 4.4.4)
T}
\fIModulname\fP\^_\fInnn\fP|T{
Strukturnamen f\*ur vom globalen Modul \%\fIModulname\fP exportierte
Verbunde oder Felder (s. Kap. 4.4.2.6)
T}|
O_\fInnn\fP|T{
Abbildung offener Felder: Zus\*atzlicher Parameter mit aktueller Anzahl
von Feldelementen (s. Kap. 4.4.4.1.2)
T}
R_\fInnn\fP|T{
Wert von RETURN-Ausdr\*ucken (s. Kap. 4.6.7)
T}
S_\fInnn\fP|T{
Strukturnamen f\*ur nicht exportierte Verbunde oder Felder
(s. Kap. 4.4.2.6)
T}
U_\fInnn\fP\^, V_\fInnn\fP|T{
Abbildung varianter Verbunde durch Einf\*uhrung zus\*atzlicher
Strukturkomponenten (s. Kap. 4.4.2.7)
T}
W_\fInnn\fP|T{
Zeiger auf Verbunde f\*ur Abbildung von WITH-Anweisungen
(s. Kap. 4.6.6)
T}
X_\fInnn\fP|T{
Feldvariable f\*ur die Parameter\*ubergabe von Zeichenketten
(s. Kap. 4.6.2)
T}
dummy|T{
Strukturkomponente f\*ur in Modula-2 leere Verbunde
T}
.TE
\&\s+2
.sp 0.4v
.sp 0.4v
.ne 2v
.ti +2n
Als C-Bezeichner f\*ur die Modula-Objekte werden die Bezeichner aus dem
Modula-Programm verwendet. Dabei werden 2 F\*alle unterschieden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Bezeichner eines von einem globalen Modul
exportierten Objekts wird in C in der
qualifizierten Form \%\fIModulname_Bezeichner\fP geschrieben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle \*ubrigen Bezeichner werden direkt aus dem Modula-Programm
\*ubernommen, werden aber bei Bedarf zur Vermeidung von Namenskonflikten mit
einem Pr\*afix C_\fInnn\fP\^_ versehen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Alle anderen Bezeichner, die in den C-Programmen verwendet werden, sind Bezeichner
f\*ur vom \*Ubersetzer \%\fIMtc\fP vordefinierte Objekte, wie z.B. die
C-Definitionen der Standardtypen und -prozeduren der Sprache Modula-2.
Alle diese Objekte sind in SYSTEM_.h bzw. SYSTEM_.c definiert und ihre
Bedeutung ist aus ihrem Bezeichner ablesbar.
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Literaturverzeichnis\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Literaturverzeichnis
.hE 0 4n 0.1v
.sp 0.2v
.ne 2v
\&[Aho\|86]
.in +6n
.if \w'[Aho\|86]\ 'u<6n .sp -1v
A. V. Aho, R. Sethi, J. D. Ullman:
Compilers: Principles, Techniques, and Tools.
Addison Wesley, Reading. Ma,
1986.
.in -6n
.sp 0.2v
.ne 2v
\&[Donzeau\|79]
.in +6n
.if \w'[Donzeau\|79]\ 'u<6n .sp -1v
V. Donzeau-Gouge, G. Kahn, B. Krieg-Br\*uckner, B. Lang:
Formal Definition of Ada (preliminary draft).
CII Honeywell Bull,
Okt. 1979.
.in -6n
.sp 0.2v
.ne 2v
\&[Engelmann\|87]
.in +6n
.if \w'[Engelmann\|87]\ 'u<6n .sp -1v
F. Engelmann:
GMD MODULA SYSTEM MOCKA \- User Manual.
GMD Forschungsstelle an der Universit\*at Karlsruhe,
Dez. 1987.
.in -6n
.sp 0.2v
.ne 2v
\&[Grosch\|87a]
.in +6n
.if \w'[Grosch\|87a]\ 'u<6n .sp -1v
J. Grosch:
Reusable Software \- A Collection of MODULA-Modules.
Compiler Generation Report No. 4,
GMD Forschungsstelle an der Universit\*at Karlsruhe,
Sept. 1987.
.in -6n
.sp 0.2v
.ne 2v
\&[Grosch\|87b]
.in +6n
.if \w'[Grosch\|87b]\ 'u<6n .sp -1v
J. Grosch:
Rex \- A Scanner Generator.
Compiler Generation Report No. 5,
GMD Forschungsstelle an der Universit\*at Karlsruhe,
Dez. 1987.
.in -6n
.sp 0.2v
.ne 2v
\&[Grosch\|89a]
.in +6n
.if \w'[Grosch\|89a]\ 'u<6n .sp -1v
J. Grosch:
Ast \- A Generator for Abstract Syntax Trees (Revised Version).
Compiler Generation Report No. 15,
GMD Forschungsstelle an der Universit\*at Karlsruhe,
Aug. 1989.
.in -6n
.sp 0.2v
.ne 2v
\&[Grosch\|89b]
.in +6n
.if \w'[Grosch\|89b]\ 'u<6n .sp -1v
J. Grosch:
Ag \- An Attribute Evaluator Generator.
Compiler Generation Report No. 16,
GMD Forschungsstelle an der Universit\*at Karlsruhe,
Aug. 1989.
.in -6n
.sp 0.2v
.ne 2v
\&[Kastens\|80]
.in +6n
.if \w'[Kastens\|80]\ 'u<6n .sp -1v
U. Kastens:
Ordered Attributed Grammars.
Acta Informatica 13, 229\-256,
1980.
.in -6n
.sp 0.2v
.ne 2v
\&[Kastens\|82]
.in +6n
.if \w'[Kastens\|82]\ 'u<6n .sp -1v
U. Kastens, B. Hutt, E. Zimmermann:
GAG: A Practical Compiler Generator.
Springer Verlag, Heidelberg,
1982.
.in -6n
.sp 0.2v
.ne 2v
\&[Kernighan\|78]
.in +6n
.if \w'[Kernighan\|78]\ 'u<6n .sp -1v
B. W. Kernighan, D. M. Ritchie:
The C Programming Language.
Prentice-Hall,
Englewood Cliffs,
N.J.,
1978.
.in -6n
.sp 0.2v
.ne 2v
\&[Kernighan\|83]
.in +6n
.if \w'[Kernighan\|83]\ 'u<6n .sp -1v
B. W. Kernighan, D. M. Ritchie:
Programmieren in C.
Carl Hanser Verlag,
M\*unchen, Wien,
1983.
.in -6n
.sp 0.2v
.ne 2v
\&[Klein\|86]
.in +6n
.if \w'[Klein\|86]\ 'u<6n .sp -1v
E. Klein, J. Grosch:
User Manual for the PGS-System.
GMD Forschungsstelle an der Universit\*at Karlsruhe,
Aug. 1986.
.in -6n
.sp 0.2v
.ne 2v
\&[PascAda\|80]
.in +6n
.if \w'[PascAda\|80]\ 'u<6n .sp -1v
P. F. Albrecht, P. E. Garrison, S. L. Graham,
R. H. Hyerle, P. Ip, B. Krieg-Br\*uckner:
Source-to-Source Translation: Ada to Pascal and Pascal to Ada.
Symposium on the Ada Programming Language,
ACM-SIGPLAN,
1980.
.in -6n
.sp 0.2v
.ne 2v
\&[PTC\|87]
.in +6n
.if \w'[PTC\|87]\ 'u<6n .sp -1v
P. Bergsten:
PTC implementation note.
Holistic Technology AB,
Grona Gatan 59,
41454 Gothenburg,
Sweden,
1987.
.in -6n
.sp 0.2v
.ne 2v
\&[UNIX\|79]
.in +6n
.if \w'[UNIX\|79]\ 'u<6n .sp -1v
The UNIX Programmers Manual.
Volume 1, 2a, 2b,
Bell Laboratories,
1979.
.in -6n
.sp 0.2v
.ne 2v
\&[Vielsack\|88]
.in +6n
.if \w'[Vielsack\|88]\ 'u<6n .sp -1v
B. Vielsack:
The Parser Generators Lalr and Ell.
Compiler Generation Report No. 8,
GMD Forschungsstelle an der Universit\*at Karlsruhe,
April 1988.
.in -6n
.sp 0.2v
.ne 2v
\&[Vielsack\|89]
.in +6n
.if \w'[Vielsack\|89]\ 'u<6n .sp -1v
B. Vielsack:
Spezifikation und Implementierung der Transformation attributierter B\*aume.
Diplomarbeit,
Universit\*at Karlsruhe, Fakult\*at f\*ur Informatik,
Juni 1989.
.in -6n
.sp 0.2v
.ne 2v
\&[Waite\|84]
.in +6n
.if \w'[Waite\|84]\ 'u<6n .sp -1v
W. M. Waite, G. Goos: Compiler Construction.
Springer Verlag, New York,
1984.
.in -6n
.sp 0.2v
.ne 2v
\&[Wirth\|85]
.in +6n
.if \w'[Wirth\|85]\ 'u<6n .sp -1v
N. Wirth:
Programming in Modula-2 (3rd edition).
Springer Verlag, Berlin, Heidelberg, New York, Tokyo,
1985.
.in -6n
.br
.ne 29.7c
.eo
.ds f1 
.ds f2 
.ds f3 
.ec
.eo
.ds f4 
.ds f5 
.ds f6 
.ec
.eo
.ds f7 
.ds f8 
.ds f9 
.ec
.de fX
.fi
.nf
..
\fBInhaltsverzeichnis\fP
.sp 1v
.hH

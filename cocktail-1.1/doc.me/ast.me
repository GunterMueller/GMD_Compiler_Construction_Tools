.\" use: pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.if t \{ \
.pl 29.7c	\" page length
.po 2.5c	\" page offset (left margin)
.ll 16.5c	\" line length
.lt 16.5c	\" title length
.nr LL 16.5c
.nr )l 29.7c
.nr hm 2c
.nr $r 9	\" factor for vertical spacing
.nr $R \n($r
.sz 12		\" font size
.nr pp 12
.nr sp 12
.nr tp 12
.nr fp 10
.hc ~		\" hyphenation character
.		\" Umlauts and sharp s
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s sz
.\}
.de _
\&\\$1\l'|0\(ul'\\$2
..
.de FT		\" font for programs
.ft C
.sz -2
..
.de FR
.ft R
.sz +2
..
.de []		\" start to display collected references
.uh References
.lp
..
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.de np
.nr $p +1
.ip \\n($p.
..
.de SH
.sp 0.5
.in -3
.r \\$1
.sp 0.5
.in +3
..
.de PP
.sp 0.5
..
.de IP
.ip \\$1 \\$2
..
.de I
.i \\$1
..
.de TH
..
.EQ
delim off
.EN
.hc @
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.1c'
.nf

	Ast - A Generator for
	Abstract Syntax Trees


	J. Grosch


\l'17.1c'
.sp 12.5c
\l'17.1c'
.ft H
.nf
	GESELLSCHAFT F\*UR MATHEMATIK
	UND DATENVERARBEITUNG MBH

	FORSCHUNGSSTELLE F\*UR
	PROGRAMMSTRUKTUREN
	AN DER UNIVERSIT\*AT KARLSRUHE
.r
\l'17.1c'
.bp
.oh ''Ast'%'
.eh ''Ast'%'
.nr % 1
.ce 99
.sz 20
.b " "
.sp 2
Project
.sp
.b "Compiler Generation"
.sp
.sz 12
\l'15c'
.sp
.sz 16
.b "Ast - A Generator for Abstract Syntax Trees"
.sp 2
Josef Grosch
.sp 2
.sz 14
Aug. 3, 1992
.sp
.sz 12
\l'15c'
.sp 2
Report No. 15
.sp 2
Copyright \(co 1992 GMD
.sp 2
Gesellschaft f\*ur Mathematik und Datenverarbeitung mbH
Forschungsstelle an der Universit\*at Karlsruhe
Vincenz-Prie\*snitz-Str. 1
D-7500 Karlsruhe
.ce 0
.fi
.bp 1
.sh 1 Introduction
.pp
.i Ast
is a generator for program modules that define the structure of abstract syntax
trees and provide general tree manipulating procedures. The defined trees
may be decorated with attributes of arbitrary types. Besides trees,
graphs can be handled, too. The structure of the trees is specified by a
formalism based on context-free grammars.
The generated module includes procedures to construct
and destroy trees, to read and write trees from (to) files, and to traverse
trees in some commonly used manners. The mentioned readers and writers
process ascii as well as binary tree representations.
All procedures work for graphs as well.
.pp
The advantages of this approach are: record aggregates are provided which
allow a concise notation for node creation. It is possible to build trees
by writing terms. An extension mechanism avoids chain rules and allows, for
example lists with elements of different types. Input/output procedures
for records and complete graphs are provided. The output procedures and the
interactive graph browser facilitate the debugging phase as they operate on
a readable level and know the data structure.
The user does not have to care about algorithms for traversing graphs. He/she
is freed from the task of writing large amounts of relatively simple code.
All of these features significantly increase programmer productivity.
.pp
.i Ast
is implemented in Modula-2 as well as in C and generates Modula-2 or C source modules.
The following sections define the specification language, explain the
generated output, discuss related approaches, and present some examples.
.sh 1 Specification
.pp
The structure of trees and directed graphs is specified by a
formalism based on context-free grammars.
However, we primarily use the terminology of trees and types in defining the
specification language.
Its relationship to context-free grammars is discussed later.
.sh 2 "Node Types"
.pp
A tree consists of
.i nodes .
A node may be related to other nodes in a so-called
.i parent-child
relation. Then the first node is called a
.i parent
node and the latter nodes are called
.i child
nodes. Nodes without a parent node are usually called
.i root
nodes, nodes without children are called
.i leaf
nodes.
.pp
The structure and the properties of nodes are described by
.i "node types" .
Every node belongs to a node type.
A specification for a tree describes a finite number of node types.
A node type specifies the names of the child nodes and the associated node
types as well as the names of the attributes and the associated attribute types.
A node type is introduced by a name which can be an identifier or a string.
The names of all node types have to be pairwise distinct.
A node type can be regarded as a
.i nonterminal ,
a
.i terminal ,
or an
.i abstract
entity. Nonterminals are characterized by the character '=' following its name,
terminals by the character ':', and abstract node types by the characters ':='.
Undefined node types are implicitly defined to be terminals
without attributes. The distinction between nonterminals and terminals is only of interest if
concrete syntax is described. In the case of abstract syntax this distinction does not make
sense and therefore nonterminal node types and eventually abstract ones suffice.
Abstract node types are explained in section 2.6.
.(b
Example:
.sp 0.5
.FT
   If        = .
   While     = .
   '()'      = .
   Ident     : .
   ":="      : .
   SCOPE     := .
.)b
The example defines the node types
.i If ,
.i While ,
and
.i '()'
to be nonterminals, the node types
.i Ident
and \fI":="\fP to be terminals, and
.i SCOPE
to be an abstract node type.
.pp
The following names are reserved for keywords and can not be used for node types:
.(b
.FT
BEGIN           CLOSE           DECLARE         DEMAND          END
EVAL            EXPORT          FOR             FUNCTION        GLOBAL
IGNORE          IMPORT          IN              INH             INHERITED
INPUT           LEFT            LOCAL           MODULE          NONE
OUT             OUTPUT          PARSER          PREC            PROPERTY
REMOTE          REV             REVERSE         RIGHT           RULE
SCANNER         SELECT          STACK           SUBUNIT         SYN
SYNTHESIZED     THREAD          TREE            VIEW            VIRTUAL
VOID
.)b
.sh 2 Children
.pp
Children are distinguished by
.i selector
names which have to be unambiguous within one node type.
The children are of a certain node type.
.(b
Example:
.sp 0.5
.FT
   If        = Expr: Expr Then: Stats Else: Stats .
   While     = Expr: Expr Stats: Stats .
.)b
The example introduces two node types called
.i If
and
.i While .
A node of type If has three children which are selected by the names
.i Expr ,
.i Then ,
and
.i Else.
The children have the node types
.i Expr ,
.i Stats ,
and
.i Stats .
.pp
If a selector name is equal to the associated name of the node type it can
be omitted. Therefore, the above example can be abbreviated as follows:
.(b
.FT
   If        = Expr Then: Stats Else: Stats .
   While     = Expr Stats .
.)b
.sh 2 Attributes
.pp
As well as children, every node type can specify an arbitrary number of
.i attributes
of arbitrary types. Like children, attributes are characterized by a selector
name and a certain type.
The descriptions of attributes are enclosed in brackets. The attribute types
are given by names taken from the target language. Missing attribute types
are assumed to be int or INTEGER depending on the target language (C or Modula-2).
Children and attributes can be given in any order.
The type of an attribute can be a pointer to a node type. In contrast to children,
.i ast
does not follow such an attribute during a graph traversal. All attributes
are considered to be neither tree nor graph structured. Only the user knows
about this fact and therefore he/she should take care.
.(b
Example:
.sp 0.5
.FT
   Binary        = Lop: Expr Rop: Expr [Operator: int] .
   Unary         = Expr [Operator] .
   IntConst      = [Value] .
   RealConst     = [Value: float] .
.)b
.pp
For example the node types
.i IntConst
and
.i RealConst
describe leaf nodes with an attribute named
.i Value
of types int or float respectively.
.i Binary
and
.i Unary
are node types with an attribute called
.i Operator
of type int.
.sh 2 "Declare Clause"
.pp
The DECLARE clause allows the definition of children and attributes for several
node types at one time.
Following the keyword DECLARE, a set of declarations can be given. The syntax is the same as
described above with the exception that several node type names may introduce a declaration.
If there already exists a declaration for a specified node type,
the children and attributes are added to this declaration.
Otherwise a new node type is introduced.
.(b
Example:
.sp 0.5
.FT
DECLARE
   Decls Stats Expr = -> [Level] [Env: tEnv] .
               Expr = -> Code [Type: tType] .
.)b
.sh 2 Extensions
.pp
To allow several alternatives for the types of children an
.i extension
mechanism is used. A node type may be associated with several other node types enclosed
in angle brackets. The first node type is called
.i base
or
.i super
type and the latter types are called
.i derived
types or
.i subtypes .
A derived type can in turn be extended with no limitation of the nesting depth.
The extension mechanism induces a subtype relation between node types.
This relation is transitive.
Where a node of a certain node type is required, either a node of this node type or a node of
a subtype thereof is possible.
.(b
Example:
.sp 0.5
.FT
Stats           = <
   If           = Expr Then: Stats Else: Stats .
   While        = Expr Stats .
> .
.)b
.pp
In the above example
.i Stats
is a base type describing nodes with neither children nor attributes.
It has two derived types called
.i If
and
.i While .
Where a node of type Stats is required, nodes of types Stats, If, and While are possible.
Where a node of type If is required, nodes of type If are possible, only.
.pp
Besides extending the set of possible node types, the extension mechanism has
the property of extending the children and attributes of the nodes of the base type.
The derived types possess the children and attributes of the base type.
They may define additional children and attributes.
In other words they
.i inherit
the structure of the base type.
The selector names of all children and attributes in an extension hierarchy have to be
distinct. The syntax of extensions has been designed this way in order to allow
single inheritance, only. Multiple inheritance is available, too. It is described in
the next section.
.(b
Example:
.sp 0.5
.FT
Stats           = Next: Stats [Pos: tPosition] <
   If           = Expr Then: Stats Else: Stats .
   While        = Expr Stats .
> .
.)b
.pp
Nodes of type
.i Stats
have one child selected by the name
.i Next
and one attribute named
.i Pos .
Nodes of type
.i While
have three children with the selector names
.i Next ,
.i Expr ,
and
.i Stats
and one attribute named
.i Pos.
.pp
A node of a base type like
.i Stats
usually does not occur in an abstract syntax tree for a complete program.
Still,
.i ast
defines this node type. It could be used as placeholder for unexpanded
nonterminals in incomplete programs which occur in applications like
syntax directed editors.
.sh 2 "Multiple Inheritance"
.pp
The extension mechanism described in the previous section allows for single inheritance of
children and attributes. The syntax of the extensions has been designed to reflect the
notation of context-free grammars as close as possible. For multiple inheritance a
different syntax and the concept of
.i "abstract node types"
are used.
.pp
Abstract node types are characterized by the definition characters ':=' instead of '=' or ':'
which are used for nonterminals or terminals. They are termed abstract because they
describe only the structure of nodes or parts thereof but nodes of this types do not exist.
Therefore no code is generated by
. iast
for abstract node types: no constant, no record type, no constructor procedure, etc..
Abstract node types can be used as base types in combination with multiple inheritance.
.pp
For multiple inheritance the following syntax is used: The name of a node type may be
followed by a left arrow '<-' and a list of names. This construct is available for all three
kinds of node types: nonterminals, terminals, and abstract node types. The names after the
left arrow have to denote abstract node types. The meaning is that the node type inherits
the structure of all listed abstract node types. Multiple inheritance is possible from
abstract node types to non abstract ones and among abstract node types. Among non abstract
node types only single inheritance is allowed.
.lp
.(b
Example:
.sp 0.5
.FT
DECLS              := [Objects: tObjects THREAD] <
  NODECLS          := .
  DECL             := [Ident: tIdent INPUT] Next:DECLS .
> .
.sp 0.5
ENV                := [Env: tEnv INH] .
.sp 0.5
USE   <- ENV       := [Ident: tIdent INPUT] [Object: tObject SYN] .
.sp 0.5
SCOPE <- ENV       := [Objects: tObjects SYN] [NewEnv: tEnv SYN] .
.)b
.(b
.FT
Root               = Proc .
.sp 0.5
Decls <- DECLS ENV = <
  NoDecls          = .
  Decl <- DECL     = <
    Var            = .
    Proc <- SCOPE  = Decls Stats .
  > .
> .
Stats <- ENV       = <
  NoStats          = .
  Stat             = <
    Assign         = Name Expr .
    Call <- USE    = .
  > .
> .
Expr <- ENV        = <
  Plus             = Lop: Expr Rop: Expr .
  Const            = [Value] .
  Name <- USE      = .
> .
.)b
.pp
The above example uses multiple inheritance and abstract node types to describe
the identification problem of programming languages. The node types written with
all upper-case letters represent abstract node types. DECLS specifies lists of
declared objects, SCOPE describes scopes or visibility regions, ENV stands for
environment and is used to distribute scope information, and USE is intended to be
used at the application of identifiers. In the second part of the example, the abstract node
types are connected to nonterminal node types.
.i Decls
is the concrete node type to describe lists of declarations.
.i Decl
represents one declaration and there are to alternatives,
.i Var
and
.i Proc ,
variables and procedures. A procedure introduces a scope and therefore it inherits from
SCOPE.
At the node types
.i Call
and
.i Name
identifiers are used and thus they inherit from USE. Finally, the node types
.i Decls ,
.i Stats ,
and
.i Expr
are regions where the environment information has to be distributed and they inherit from
ENV.
.sh 2 Modules
.pp
The specification of node types can be grouped into an arbitrary number of modules.
The modules allow to combine parts of the specification that logically belong together.
This feature can be used to structure a specification or to extend an existing one.
A module consists of target code sections (see section 2.12.)
and specifications of node types with attribute declarations.
The information given in the modules is merged in the following way:
the target code sections are concatenated.
If a node type has already been declared the given children, attributes,
and subtypes are added to the existing declaration.
Otherwise a new node type is introduced.
This way of modularization offers several possibilities:
.ip -
Context-free grammar and attribute declarations (= node types)
can be combined in one module.
.ip -
The context-free grammar and the attribute declarations
can be placed in two separate modules.
.ip -
The attribute declarations can be subdivided into several modules according
to the tasks of semantic analysis. For example, there would be modules for
scope handling, type determination, and context conditions.
.ip -
The information can be grouped according to language concepts or
nonterminals. For example, there would be modules containing
the grammar rules and the attribute declarations
for declarations, statements, and expressions.
.lp
.(b
Example:
.sp 0.5
.FT
MODULE my_version
.sp 0.5
Stats        = [Env: tEnv] <                    /* add attribute   */
   While     = Init: Stats Terminate: Stats .   /* add children    */
   Repeat    = Stats Expr .                     /* add node type   */
> .
.sp 0.5
END my_version
.)b
.sh 2 Properties
.pp
The description of children and attributes can be refined by the association of so-called
properties. These properties are expressed by the keywords listed in Table 1.
.(z L
.ce
Table 1: Properties for Children and Attributes
.sp 0.5
.TS
center;
l l.
long form	short form
_
.FT
INPUT	IN
OUTPUT	OUT
SYNTHESIZED	SYN
INHERITED	INH
THREAD
REVERSE	REV
IGNORE
VIRTUAL
.TE
.)z
.pp
The properties have the following meanings:
.i Input
attributes (or children) receive a value at node-creation time, whereas non-input
attributes may receive their values at later times.
.i Output
attributes are supposed to hold a value at the end of a node's existence,
whereas non-output
attributes may become undefined or unnecessary earlier.
.i Synthesized
and
.i inherited
describe the kinds of attributes occurring in attribute grammars. They have
no meaning for
.i ast .
The property
.i thread
supports so-called threaded attributes:
An attribute declaration [a THREAD] is equivalent to the declaration of a pair of attributes
with the suffixes In and Out: [aIn] [aOut].
These attributes have to be accessed with their full name including the suffixes.
The property
.i reverse
specifies how lists should be reversed. It is discussed in section 2.11.
The property
.i ignore
instructs
.i ast
to disregard or omit an attribute or a child. It is useful in connection with the concept of
views (see section 2.10.).
The property
.i virtual
is meaningful in attribute grammars. It is used to describe dependencies among attributes.
However, no space will be allocated for those attributes and the attribute computations for
those attributes will be omitted in the generated attribute evaluator.
Within
.i ast
the properties
.i input ,
.i reverse ,
and
.i ignore
are of interest, only.
.pp
Properties are specified either locally or globally. Local properties are valid for one
individual child or attribute. They are listed after the type of this item. Example:
.(b
.FT
Stats = Next: Stats IN REV [Pos: tPosition IN] [Level INH] .
.)b
Global properties are valid for all children and attributes
defined in one or several modules. They are valid in addition to the local properties that
might be specified. In order to describe global properties, a module may contain several
property clauses which are written in the following form:
.(b
.FT
PROPERTY properties [ FOR module_names ]
.)b
The listed properties become valid for the given modules. If the FOR part is missing, the
properties become valid for the module that contains the clause.
.(b
Example:
.sp 0.5
.FT
PROPERTY INPUT
PROPERTY SYN OUT FOR Mapping
.)b
.pp
Input attributes are included into the parameter list of the
node constructor procedures (see section 3). The global property
.i input
replaces the symbol '->' of former versions of
.i ast .
For compatibility reasons this symbol still works in a restricted way:
The symbol '->' could be included in a
list of children and attributes as a shorthand notation to separate
input from non-input items. In a list without this symbol all children and
attributes are treated as input items.
This meaning of the symbol '->' is still in effect as long as
.i ast
does not encounter a global property clause. After encountering such a clause,
local and global properties are in effect only \(en the symbol '->' is ignored.
.(b
Example:
.sp 0.5
.FT
Stats           = Next: Stats REV [Pos: tPosition] -> [Level INH] <
   If           = Expr Then: Stats Else: Stats .
   While        = -> Expr IN Stats IN .
> .
.)b
The node types of the example possess the children and attributes
listed in Table 2.
.(z L
.ce
Table 2: Example of Properties
.sp 0.5
.TS
center;
l l l l l.
node	selector	associated	kind	properties
type	name	type
_
Stats	Next	Stats	child	IN REV
	Pos	tPosition	attribute	IN
	Level	int	attribute	INH
_
If	Next	Stats	child	IN REV
	Pos	tPosition	attribute	IN
	Level	int	attribute	INH
	Expr	Expr	child	IN
	Then	Stats	child	IN
	Else	Stats	child	IN
_
While	Next	Stats	child	IN REV
	Pos	tPosition	attribute	IN
	Level	int	attribute	INH
	Expr	Expr	child	IN
	Stats	Stats	child	IN
.TE
.)z
.sh 2 "Subunits"
.pp
Usually, an
.i ast
specification is translated into one program module. This module
receives the name that immediately follows the keyword TREE.
If several modules contain a name, the first one is chosen.
If none of the modules contains a name, the default name
.i Tree
is used. It is possible to generate several modules out of an
.i ast
specification. Then there is exactly one module called
.i "main unit"
that describes the tree structure and an arbitrary number of modules called
.i subunits .
This is of interest if the generated source code becomes too large for one compilation unit.
Then either some or all desired procedures could be placed into separate subunits. In the
extreme, there might be a subunit for every procedure. It is possible to have two or
more versions of one procedure (e. g. WriteTREE) where every one uses a different view
(see section 2.10.).
.pp
The names of the main unit and the subunits are described in the header of an
.i ast
specification:
.(b
.FT
[ TREE [ Name ] ] [ SUBUNIT Name ] [ VIEW Name ]
.)b
The name after the keyword VIEW is necessary if abstract syntax trees are to be processed
by program modules generated with other tools such as e. g.
.i puma
\*([[Gro91\*(]] that need to know the definition of the tree structure.
.i Ast
has an option that requests to write a binary version of the tree definition to a file
whose name is derived from the name given after the keyword VIEW by appending the suffix
".TS" (Default: "Tree.TS").
.pp
Every unit has to be generated by a separate run of
.i ast .
If a subunit name is present, then a subunit is generated \(en otherwise a main unit is
generated. The options select the procedures to be included in the units.
It is probably wise not to include the subunit name in an
.i ast
specification. If this name is added "on the fly" with UNIX commands then different
subunits can be generated from one specification without the need to change it.
.(b
Example:
.sp 0.5
.FT
                                      ast -dim spec.ast
echo SUBUNIT read  | cat - spec.ast | ast -dir
echo SUBUNIT write | cat - spec.ast | ast -diw
.FR
or
.FT
echo TREE MyTree               | cat - spec.ast | ast -dim
echo TREE MyTree SUBUNIT read  | cat - spec.ast | ast -dir
echo TREE MyTree SUBUNIT write | cat - spec.ast | ast -diw
.)b
.sh 2 "Views"
.pp
An
.i ast
specification can be roughly seen as a collection of node types and associated children and
attributes. A so-called
.i view
selects a subset of this collection and it may attach further properties to some parts of
this collection.
.pp
The concept of views is necessary for instance if two programs communicate a common data
structure via a file. Every program might need additional data which should neither appear in
the other program nor in the file. In order to make this work both programs must agree upon
the coding of the node types in the shared part of the data structure. This is accomplished
by using one common
.i ast
specification that contains the description of the complete data structure. Every program
uses a specific view and selects only those parts of the common specification that are of
interest. See Figure 1 for an example.
.(z
.PS
boxht	= .6
boxwid	= 1.2

	down
	box "program A" invis
	box "main unit Tree" "generated" "from A and C"
P:	box "subunit PutTree" "generated" "from C"
	box "other modules"

	right
	arrow at P.e right 0.75
F:	box "file"
	arrow right 0.75
G:	box "subunit GetTree" "generated" "from C"
	box "other modules" at G + (0, - boxht)
	up
	box "main unit Tree" "generated" "from B and C" at G + (0, boxht)
	box "program B" invis

	box "MODULE C" "common data" at F + (0, boxht * 3)
	box "MODULE B" "data specific" "to program B"
	box "MODULE A" "data specific" "to program A"
	box "specification" "file: spec.ast" invis
.PE
.sp
.ce 5
UNIX commands to generate the compilation units:
.sp 0.5
.FT
echo                 SELECT A C | cat - spec.ast | ast -dim
echo SUBUNIT PutTree SELECT   C | cat - spec.ast | ast -dip
echo                 SELECT B C | cat - spec.ast | ast -dim
echo SUBUNIT GetTree SELECT   C | cat - spec.ast | ast -dig
.FR
.sp
.ce
Fig. 1: Programs Sharing a Part of a Data Structure
.)z
.pp
Another need for views arises if several attribute evaluators operate one after the other on
one tree. The output attributes of a preceding evaluator become the input attributes of a
succeeding one. Here it is necessary to be able to change the properties of attributes. In
one view the attributes are regarded as output and in the other one they are regarded as
input. The usage of views for the specification of several attribute evaluators is described
in\*([<\*([[Gro89\*(]]\*(>].
.pp
Furthermore, views are necessary if abstract syntax trees are to be processed by program
modules generated with other tools such as e. g.
.i puma
\*([[Gro91\*(]] that need to know the definition of the tree structure.
In general, there might be several tree processing modules and every one uses a different
view. In this case, the views have to be communicated to the other tool in a file.
.i ast
has an option that requests to write a binary version of the tree definition to a file
whose name is derived from the name given after the keyword VIEW by appending the suffix
".TS" (Default: "Tree.TS", see section on "Subunits").
.pp
The concept of views is based on the global properties:
.(b
.FT
PROPERTY properties FOR module_names
.)b
allows the dynamic addition of properties.
.(b
.FT
PROPERTY IGNORE FOR module_names
.)b
allows the suppression of all definitions given in the listed modules. Additionally there is
the so-called select clause:
.(b
.FT
SELECT module_names
.)b
This is equivalent to:
.(b
.FT
PROPERTY IGNORE FOR module_names_not_given
.)b
.pp
It is wise to assign names to all modules of an
.i ast
specification, because otherwise they can not be selected with the select clause.
Furthermore, the property or select clauses that express views should probably not be included
in the file containing the
.i ast
specification. The reason is that this form is not flexible, because it is relatively hard to
change. It is better to add the one line that is necessary for views "on the fly" using UNIX
commands like echo and cat (see Figure 1).
.sh 2 "Reversal of Lists"
.pp
Recursive node types like
.i Stats
in the abstract grammar of the example below describe lists of subtrees.
There are at least two cases where it is convenient to be able to easily
reverse the order of the subtrees in a list. The facility provided by
.i ast
is a generalization of an idea presented in\*([<\*([[Par88\*(]]\*(>].
.sh 3 "LR Parsers"
.pp
Using LR parsers, one might be forced to parse a list using a left-recursive
concrete grammar rule because of the limited stack size.
.\" However, for some
.\" reason, the list should be right-recursive in the abstract syntax.
The concrete grammar rules of the following examples are written in the
input language of the parser generator
.i Lalr
\*([[GrV88\*(],Gro88\*(]] which is similar to the one of
YACC\*([<\*([[Joh75\*(]]\*(>].
The node constructor procedures within the semantic actions are the ones provided by
.i ast
(see section 3).
.(b
Example:
.sp 0.5
concrete grammar (with tree building actions):
.sp 0.5
.FT
Stats:                         {$$ = mStats0 ();      } .
Stats: Stats Stat ';'          {$$ = mStats1 ($2, $1);} .
Stat : WHILE Expr DO Stats END {$$ = mWhile  ($2, $4);} .
.sp 0.5
.sz +2
.r
abstract grammar:
.sp 0.5
.FT
Stats           = <
   Stats0       = .
   Stats1       = Stat Stats .
> .
.)b
A parser using the above concrete grammar would construct statement lists
where the list elements are in the wrong order, because the last statement
in the source would be the first one in the list. The WHILE rule represents a
location where statement lists are used.
.pp
To easily solve this problem
.i ast
can generate a procedure to reverse lists.
The specification has to describe how this should be done.
At most one child of every node type may be given the property
.i reverse .
The child's type has to be the node type itself or an associated base type.
The generated list reversal procedure ReverseTREE then reverses a list with
respect to this indicated child.
The procedure ReverseTREE has to be called exactly once for a list to be
reversed. This is the case at the location where a complete list is included
as subtree (e. g. in a WHILE statement).
.(b
Example:
.sp 0.5
concrete grammar (with tree building actions):
.sp 0.5
.FT
Stats:                         {$$ = mStats0 ();      } .
Stats: Stats Stat ';'          {$$ = mStats1 ($2, $1);} .
Stat : WHILE Expr DO Stats END {$$ = mWhile  ($2, ReverseTREE ($4));} .
.sp 0.5
.sz +2
.r
abstract grammar:
.sp 0.5
.FT
Stats           = <
   Stats0       = .
   Stats1       = Stat Stats REVERSE .
> .
.)b
.pp
It is possible to represent lists differently in an abstract syntax.
A more sophisticated solution is given in the next example.
The procedure ReverseTREE handles this variant, too.
.(b
Example:
.sp 0.5
concrete grammar (with tree building actions):
.sp 0.5
.FT
Stats:       {$$ = mEmpty ();} .
Stats: Stats IF Expr THEN Stats ELSE Stats END ';'
             {$$ = mIf ($3, ReverseTREE ($5), ReverseTREE ($7), $1);} .
Stats: Stats WHILE Expr DO Stats END ';'
             {$$ = mWhile ($3, ReverseTREE ($5), $1);} .
.sp 0.5
.sz +2
.r
abstract grammar:
.sp 0.5
.FT
Stats           = Next: Stats REVERSE <
   Empty        = .
   If           = Expr Then: Stats Else: Stats .
   While        = Expr Stats .
> .
.)b
.sh 3 "LL Parsers"
.pp
Using LL parsers a similar problem as in the LR case can arise if extended
BNF is used. Lists are parsed with an iteration which is turned into a
loop statement as follows:
(The identifiers Stats0, Stats1, Stat0, and Stat1 in the concrete grammar
rules denote the symbolic access to the L-attribution mechanism provided by
.i Ell
\*([[GrV88\*(]]. These identifiers should not be mixed up with the similar
ones used as node names in the abstract syntax.)
.(b L
Example:
.sp 0.5
concrete grammar (with tree building actions):
.sp 0.5
.FT
Stats: {*Stats0=mStats0 ();} ( Stat ';' {*Stats0=mStats1 (Stat1, Stats0);} ) * .
Stat : WHILE Expr DO Stats END {*Stat0=mWhile (Expr1, ReverseTREE (Stats1));} .
.sp 0.5
.sz +2
.r
abstract grammar:
.sp 0.5
.FT
Stats           = <
   Stats0       = .
   Stats1       = Stat Stats REVERSE .
> .
.)b
The list elements (statements) are inserted in the wrong order within the
first concrete grammar rule. The order is corrected by a call of the
procedure ReverseTREE in the second concrete grammar rule.
.sh 2 "Target Code"
.pp
An
.i ast
specification may include several sections containing so-called
.i "target code" .
This sections follow the keywords TREE or SUBUNIT.
Target code is code written in the target language which is copied unchecked
and unchanged to certain places in the generated module.
It has to be enclosed in braces '{' '}'. Balanced braces
within the target code are allowed. Unbalanced braces have to be escaped by a
preceding '\\' character. In general, the escape character '\\' escapes
everything within target code.
Therefore, especially the escape character itself has to be escaped.
.(b
Example in C:
.sp 0.5
.FT
TREE SyntaxTree
IMPORT {# include "Idents.h" }
EXPORT {  typedef tSyntaxTree MyTree; }
GLOBAL {# include "Idents.h"
          typedef struct { unsigned Line, Column; } tPosition;
BEGIN  { ... }
CLOSE  { ... }
.)b
.(b
Example in Modula-2:
.sp 0.5
.FT
TREE SyntaxTree
IMPORT { FROM Idents IMPORT tIdent; }
EXPORT { TYPE MyTree = tSyntaxTree; }
GLOBAL { FROM Idents IMPORT tIdent;
         TYPE tPosition = RECORD Line, Column: CARDINAL; END; }
BEGIN  { ... }
CLOSE  { ... }
.)b
.lp
The meaning of the sections is as follows:
.ip IMPORT: 3c
declarations to be included in the definition module at a place where IMPORT
statements are legal.
.ip EXPORT: 3c
declarations to be included in the definition module after the declaration
of the tree type
.i tTREE .
.ip GLOBAL: 3c
declarations to be included in the implementation module at global level.
.ip LOCAL: 3c
same as GLOBAL within
.i ast .
.ip BEGIN: 3c
statements to initialize the declared data structures.
.ip CLOSE: 3c
statements to finalize the declared data structures.
.sh 2 "Common Node Fields"
.pp
Sometimes it is desirable to include certain record fields into all node types.
This can be done directly in the target language by defining the macro
.i TREE_NodeHead
in the IMPORT or EXPORT target code sections. These fields become members of the variant
.i yyHead
and they can be accessed as shown in the following examples:
.(b
Example in C:
.sp 0.5
.FT
# define Tree_NodeHead int MyField1; MyType MyField2;
.sp 0.5
t->yyHead.MyField1 = ... ;
.)b
.(b
Example in Modula-2:
.sp 0.5
.FT
# define Tree_NodeHead MyField1: INTEGER; MyField2: MyType;
.sp 0.5
t^.yyHead.MyField1 := ... ;
.)b
.sh 2 "Type Specific Operations"
.pp
Procedures generated by
.i ast
apply several operations to attributes: initialization, finalization, ascii read
and write, binary read and write, and copy (see Table 3).
.i Initialization
is performed whenever a node is created. It can range from
assigning an initial value to the allocation of dynamic storage or the
construction of complex data structures.
.i Finalization
is performed immediately before a node is deleted and may e. g. release
dynamically allocated space. The
.i read
and
.i write
operations enable the readers and writers to handle the
complete nodes including all attributes, even those of user-defined types.
The operation
.i copy
is needed to duplicate values of attributes of user-defined types. By default,
.i ast
just copies the bytes of an attribute to duplicate it.
Therefore, pointer semantics is assumed for attributes of a pointer type.
If value semantics is needed, the user has to take care about this operation.
The operation
.i equal
checks whether two attributes are equal. It is used as atomic operation for the procedure
that tests the equality of trees.
.(z L
.ce
Table 3: Type Specific Operations
.sp 0.5
.TS
center;
c | c | c s
c | c | c | c
l | l | l | l.
		\h'2c'default macro
operation	macro name	C	Modula-2
_
initialization	beginTYPE(a)
finalization	closeTYPE(a)
ascii read	readTYPE(a)	yyReadHex (& a, sizeof (a));	yyReadHex (a);
ascii write	writeTYPE(a)	yyWriteHex (& a, sizeof (a));	yyWriteHex (a);
binary read	getTYPE(a)	yyGet (& a, sizeof (a));	yyGet (a);
binary write	putTYPE(a)	yyPut (& a, sizeof (a));	yyPut (a);
copy    	copyTYPE(a, b)
equal    	equalTYPE(a, b)	memcmp (& a, & b, sizeof (a)) == 0	yyIsEqual (a, b)
.TE
.)z
.pp
The operations are type specific in the sense that every type has its own
set of operations. All attributes having the same type (target type name)
are treated in the same way. Chosing different type names for one type
introduces subtypes and allows to treat attributes of different subtypes
differently. Type operations for the predefined types of a target language
are predefined within
.i ast
(see Appendices 6 and 7). For user-defined types,
.i ast
assumes default operations (see Table 3).
The procedures yyReadHex and
yyWriteHex read and write the bytes of an attribute as hexadecimal values.
The procedures yyGet and
yyPut read and write the bytes of an attribute unchanged (without conversion).
The operations are defined by a macro mechanism.
The procedure yyIsEqual checks the bytes of two attributes for equality.
TYPE is replaced by the concrete type name.
.i a
is a formal macro parameter referring to the attribute.
The predefined procedures mentioned in Table 3 use the global variable
.i yyf
of type FILE * or IO.tFile\*([<\*([[Gro87\*(]]\*(>]
describing the file used by the readers and writers.
.pp
It is possible to redefine the operations by including new macro definitions
in the GLOBAL section. The following example demonstrates the syntax for
doing this. It shows how records of the type tPosition might be handled and
how subtypes can be used to initialize attributes of the same type differently.
.(b
Example in C:
.sp 0.5
.FT
IMPORT {
# include "Sets.h"
typedef struct { unsigned Line, Column; } tPosition;
typedef tSet Set100;
typedef tSet Set1000;
}
.sp 0.5
GLOBAL {
# define begintPosition(a) a.Line = 0; a.Column = 0;
# define readtPosition(a)  fscanf (yyf, "%d%d", & a.Line, & a.Column);
# define writetPosition(a) fprintf (yyf, "%d %d", a.Line, a.Column);
.sp 0.5
# define beginSet100(a)    MakeSet    (& a, 100);
# define closeSet100(a)    ReleaseSet (& a);
# define readSet100(a)     ReadSet    (yyf, & a);
# define writeSet100(a)    WriteSet   (yyf, & a);
.sp 0.5
# define beginSet1000(a)   MakeSet    (& a, 1000);
# define closeSet1000(a)   ReleaseSet (& a);
# define readSet1000(a)    ReadSet    (yyf, & a);
# define writeSet1000(a)   WriteSet   (yyf, & a);
}
.)b
.(b
Example in Modula-2:
.sp 0.5
.FT
IMPORT {
   FROM Sets      IMPORT tSet;
   TYPE tPosition = RECORD Line, Column: CARDINAL; END;
   TYPE Set100    = tSet;
   TYPE Set1000   = tSet;
}
.sp 0.5
GLOBAL {
   FROM IO        IMPORT ReadI, WriteI, WriteC;
   FROM Sets      IMPORT MakeSet, ReleaseSet, ReadSet, WriteSet;
.sp 0.5
# define begintPosition(a) a.Line := 0; a.Column := 0;
# define readtPosition(a)  a.Line := ReadI (yyf); a.Column := ReadI (yyf);
# define writetPosition(a) WriteI (yyf, a.Line, 0); WriteC (yyf, ' '); \\\\
                           WriteI (yyf, a.Column, 0);
.sp 0.5
# define beginSet100(a)    MakeSet    (a, 100);
# define closeSet100(a)    ReleaseSet (a);
# define readSet100(a)     ReadSet    (yyf, a);
# define writeSet100(a)    WriteSet   (yyf, a);
.sp 0.5
# define beginSet1000(a)   MakeSet    (a, 1000);
# define closeSet1000(a)   ReleaseSet (a);
# define readSet1000(a)    ReadSet    (yyf, a);
# define writeSet1000(a)   WriteSet   (yyf, a);
}
.)b
.sh 2 "Storage Management"
.pp
The storage management for the nodes to be created is completely automatic.
Usually, the user does not have to care about it.
The predefined storage management works as follows: Every generated tree
module contains its own heap manager which is designed in favour of speed.
The constructor procedures use an in-line code sequence to obtain storage
(see below). The heap manager does not maintain free lists. It only allows
to free the complete heap of one module using the procedure
.i ReleaseTREEModule .
The procedure
.i ReleaseTREE
does not free the node space, it only finalizes the attributes of the node.
.pp
To change the predefined behaviour, two macro definitions may be included
in the GLOBAL section. For C these macros are initialized as follows:
.(b
.FT
# define yyALLOC(ptr, size) \\\\
  if ((ptr = (tTREE) TREE_PoolFreePtr) >= (tTREE) TREE_PoolMaxPtr) \\\\
     ptr = TREE_Alloc (); \\\\
  TREE_PoolFreePtr += size;
# define yyFREE(ptr, size)
.)b
For Modula-2 these macros are initialized as follows:
.(b
.FT
# define yyALLOC(ptr, size) ptr := yyPoolFreePtr; \\\\
  IF SYSTEM.ADDRESS (ptr) >= yyPoolMaxPtr THEN ptr := yyAlloc (); END; \\\\
  INC (yyPoolFreePtr, size);
# define yyFREE(ptr, size)
.)b
The following lines switch the heap manager to a global
storage allocator with free lists:
.(b
.FT
# define yyALLOC(ptr, size) ptr = Alloc (size);
# define yyFREE(ptr, size)  Free (size, ptr);
.)b
Now
.i ReleaseTREE
will work as expected whereas
.i ReleaseTREEModule
does not work any more.
.sh 1 "About the Generated Program Module"
.pp
A specification as described in the previous section is translated by
.i ast
into a program module consisting of a definition and an implementation part.
Only the definition part or header file respectively is sketched here
\(en Appendices 4 and 5 contain the general schemes.
The definition part contains primarily type declarations to
describe the structure of the trees and the headings of the generated procedures.
.pp
Every node type is turned into a constant declaration and a struct or record declaration.
That is quite simple, because node types and record declarations are almost the same
concepts except for the extension mechanism and some shorthand notations.
All these records become members of a union type or a variant record used to describe
tree nodes in general. This variant record has a tag field called
.i Kind
which stores the code of the node type.
A pointer to the variant record is a type representing trees.
Like all generated names, this pointer type is derived from the name of the specification.
Table 4 briefly explains the exported objects (replace TREE by the name of the generated
module (see section 2.12.) and <node type> by all the names of node types).
Whereas in Modula-2 the names of the constants to code the node types and the names of the
record variants are identical to the names of the node types this is not the case in C.
In C only the names of the union members are identical, the constant names are prefixed with
the letter 'k' standing for
.i Kind .
.(z L
.ce
Table 4: Generated Objects and Procedures
.sp 0.5
.TS
center;
l l.
object/procedure	description
_
k<node type>	named constant to encode a node type in C
<node type>	named constant to encode a node type in Modula-2
<node type>	name of union member or record variant for a node type
tTREE	pointer type, refers to variant record type describing all node types
TREERoot	variable of type tTREE, can serve as root
 	(additional variables can be declared)
TREE_NodeName	array mapping node types to names (strings) in C
TREE_NodeSize	array mapping node types to the size of the nodes in C
yyNodeSize	array mapping node types to the size of the nodes in Modula-2
_
MakeTREE	node constructor procedure without attribute initialization
IsType	test a node for a certain type
n<node type>	node constructor procedures with attribute initialization
 	according to the type specific operations
m<node type>	node constructor procedures with attribute initialization
	from a parameter list for \fIinput\fP attributes
ReleaseTREE	node or graph finalization procedure,
	all attributes are finalized, all node space is deallocated
ReleaseTREEModule	deallocation of all graphs managed by a module
WriteTREENode	ASCII node writer procedure
ReadTREE	ASCII graph reader procedure
WriteTREE	ASCII graph writer procedure
GetTREE	binary graph reader procedure
PutTREE	binary graph writer procedure
ReverseTREE	procedure to reverse lists
TraverseTREETD	top down graph traversal procedure (reverse depth first)
TraverseTREEBU	bottom up graph traversal procedure (depth first search)
CopyTREE	graph copy procedure
IsEqualTREE	equality test procedure for trees
CheckTREE	graph syntax checker procedure
QueryTREE	graph browser procedure
BeginTREE	procedure to initialize user-defined data structures
CloseTREE	procedure to finalize user-defined data structures
.TE
.)z
.pp
The parameters of the procedures
.i m<node type>
have to be given in the order of the
.i input
attributes in the specification. Attributes of the base type (recursively)
precede the ones of the derived type.
The procedures
.i TraverseTREETD
and
.i TraverseTREEBU
visit all nodes of a tree or a graph respectively. At every node a procedure given as
parameter is executed. An assignment of a tree or graph to a variable of type
.i tTREE
can be done in two ways: The usual assignment operators '=' or ':=' yield pointer
semantics. The procedure
.i CopyTREE
yields value semantics by duplicating a given graph.
.pp
The procedure
.i QueryTREE
allows to browse a tree and to inspect one node at a time. A node including
the values of its attributes is printed on
.i "standard output" .
Then the user is prompted to provide one of the following commands from
.i "standard input" :
.(b
.ta 4c
parent	display parent node
quit	quit procedure QueryTREE
<selector>	display specified child (first match, abbreviation possible)
<selector><space>	display specified child (exact match, no abbreviation)
.)b
All commands can be abbreviated to an unambiguous prefix. Usually, a first match strategy is
used to determine a child from its (abbreviated) selector name. With this search strategy,
children whose name is a prefix of others may not be accessible. If an unabbreviated selector
name is supplied together with a following space character an exact match strategy is used,
which allows to access every child. The empty command
behaves like
.i parent .
.pp
The construction of the pointer and the union type above does not enforce
the tree typing rules through the types of the target language. In fact, it
is possible to construct trees that violate the specification. The
user is responsible to adhere to the type rules. Most of the generated
procedures do not care about the type rules. Moreover, type violations are
possible and such erroneous trees are handled correctly by all procedures.
The procedure
.i CheckTREE
can be used to check if a tree is properly typed. In case of typing errors
the involved parent and child nodes are printed on
.i "standard error" .
.pp
The binary graph writer procedure
.i GetTREE
produces a binary file containing the graph in linearized form. The nodes are
written according to a depth first traversal. Edges are either represented by
concatenation of nodes or by symbolic (integer) labels.
The following kinds of records specified by C types are written to the file:
.(b
.FT
# define yyNil          0374
# define yyNoLabel      0375
# define yyLabelDef     0376
# define yyLabelUse     0377

typedef unsigned char  TREE_tKind;   /* less than 252 node types */
typedef unsigned short TREE_tKind;   /* more than 251 node types */
typedef unsigned short TREE_tLabel;

struct { char yyNil     ;                               } NoTree;
struct { char yyLabelUse; TREE_tLabel <label>;          } LabelUse;
struct { char yyLabelDef; TREE_tLabel <label>;
                          TREE_tKind Kind; <attributes> } LabelDef;
struct { char yyNoLabel ; TREE_tKind Kind; <attributes> } NoLabel;
struct { char Kind      ; <attributes>                  } Kind;
.)b
Record fields whose name starts with
.i yy
have a constant value as defined.
<label> is an integer representing a certain address.
<attributes> are written with the type specific
.i put
macros which either copy the bytes of an attribute unchanged or do whatever the user
has specified. If the value of the tag field Kind is less than 252 then the format
.i Kind
is used, otherwise the format
.i NoLabel
is used to write unlabeled nodes.
.sh 1 "Using the Generated Program Module"
.pp
This section explains how to use the objects of the generated program module.
Trees or graphs are created by successively creating their nodes. The easiest
way is to call the constructor procedures m<node_type>. These combine node
creation, storage allocation, and attribute assignment.
They provide a mechanism similar to record aggregates. Nested calls of
constructor procedures allow programming with (ground) terms as in Prolog or LISP.
In general, a node can be created by a call of one of the procedures
.(b
MakeTREE, n<node type>, or m<node type>.
.)b
The type of a node can be retrieved by
examination of the predefined tag field called
.i Kind .
Alternatively the function
.i IsType
can be used to test whether a node has a certain type or a subtype thereof.
Children and attributes can be accessed using two record selections.
The first one states the node type and the
second one gives the selector name of the desired item.
.(b
Example in C:
.sp 0.5
abstract syntax:
.sp 0.5
.FT
Expr         = [Pos: tPosition] <
   Binary    = Lop: Expr Rop: Expr [Operator: int] .
   Unary     = Expr [Operator] .
   IntConst  = [Value] .
   RealConst = [Value: float] .
> .
.)b
.(b
tree construction by a term:
.sp 0.5
.FT
# define Plus 1
tTREE t;
tPosition Pos;
.sp 0.5
t = mBinary (Pos, mIntConst (Pos, 2), mIntConst (Pos, 3), Plus);
.)b
.(b
tree construction during parsing:
.sp 0.5
.FT
Expr: Expr '+' Expr {$$.Tree = mBinary ($2.Pos, $1.Tree, $3.Tree, Plus);} .
Expr:      '-' Expr {$$.Tree = mUnary  ($1.Pos, $2.Tree, Minus);        } .
Expr: IntConst      {$$.Tree = mIntConst ($1.Pos, $1.IntValue);         } .
Expr: RealConst     {$$.Tree = mRealConst ($1.Pos, $1.RealValue);       } .
.)b
.(b
tree construction using a statement sequence:
.sp 0.5
.FT
t = MakeTREE (Binary);
t->Binary.Pos.Line            = 0;
t->Binary.Pos.Column          = 0;
t->Binary.Lop                 = MakeTREE (IntConst);
t->Binary.Lop->IntConst.Pos   = Pos;
t->Binary.Lop->IntConst.Value = 2;
t->Binary.Rop                 = MakeTREE (IntConst);
t->Binary.Rop->IntConst.Pos   = Pos;
t->Binary.Rop->IntConst.Value = 3;
t->Binary.Operator            = Plus;
.)b
.(b
access of tag field, children, and attributes:
.sp 0.5
.FT
switch (t->Kind) {
case kExpr  : ... t->Expr.Pos             ...
case kBinary: ... t->Binary.Operator      ...
              ... t->Binary.Lop           ...
case kUnary : ... t->Unary.Expr->Expr.Pos ...
};
.)b
.(b
Example in Modula-2:
.sp 0.5
abstract syntax:
.sp 0.5
.FT
Expr         = [Pos: tPosition] <
   Binary    = Lop: Expr Rop: Expr [Operator: INTEGER] .
   Unary     = Expr [Operator] .
   IntConst  = [Value] .
   RealConst = [Value: REAL] .
> .
.)b
.(b
tree construction by a term:
.sp 0.5
.FT
CONST Plus = 1;
VAR t: tTREE; Pos: tPosition;
.sp 0.5
t := mBinary (Pos, mIntConst (Pos, 2), mIntConst (Pos, 3), Plus);
.)b
.(b
tree construction during parsing:
.sp 0.5
.FT
Expr: Expr '+' Expr {$$.Tree := mBinary ($2.Pos, $1.Tree, $3.Tree, Plus);} .
Expr:      '-' Expr {$$.Tree := mUnary  ($1.Pos, $2.Tree, Minus);        } .
Expr: IntConst      {$$.Tree := mIntConst ($1.Pos, $1.IntValue);         } .
Expr: RealConst     {$$.Tree := mRealConst ($1.Pos, $1.RealValue);       } .
.)b
.(b
tree construction using a statement sequence:
.sp 0.5
.FT
t := MakeTREE (Binary);
t^.Binary.Pos.Line            := 0;
t^.Binary.Pos.Column          := 0;
t^.Binary.Lop                 := MakeTREE (IntConst);
t^.Binary.Lop^.IntConst.Pos   := Pos;
t^.Binary.Lop^.IntConst.Value := 2;
t^.Binary.Rop                 := MakeTREE (IntConst);
t^.Binary.Rop^.IntConst.Pos   := Pos;
t^.Binary.Rop^.IntConst.Value := 3;
t^.Binary.Operator            := Plus;
.)b
.(b
access of tag field, children, and attributes:
.sp 0.5
.FT
CASE t^.Kind OF
| Expr  : ... t^.Expr.Pos             ...
| Binary: ... t^.Binary.Operator      ...
          ... t^.Binary.Lop           ...
| Unary : ... t^.Unary.Expr^.Expr.Pos ...
END;
.)b
.sh 1 "Related Research"
.sh 2 "Variant Records"
.pp
.i Ast
specifications and variant record types like in Pascal or Modula-2 are very
similar. Every node type in an
.i ast
specification corresponds to a single variant. In the generated code every
node type is translated into a record type. All record types become members
of a variant record type representing the type for the trees.
.pp
The differences are the following:
.i Ast
specifications are shorter than directly hand-written variant record types.
.i Ast
specifications are based on the formalism of context-free grammars (see
section 5.3.). The generator
.i ast
automatically provides operations on record types which would be simple but
voluminous to program by hand. The node constructor procedures allow to
write record aggregates and provide dynamic storage management. The reader
and writer procedures supply input and output for record types and even for
complete linked data structures such as trees and graphs.
.sh 2 "Type Extensions"
.pp
Type extensions have been introduced with the language Oberon
\*([[Wir88a\*(],Wir88b\*(],Wir88c\*(]].
The extension mechanism of
.i ast
is basically the same as in Oberon. The notions extension, base type, and derived type are
equivalent.
.i "Type tests"
and
.i "type guards"
can be easily programmed by inspecting the tag field of a node.
.i Ast
does not provide assignment of subtypes to base types in the sense of value semantics or a
projection, respectively.
The tool can be seen as a preprocessor providing type extensions for Modula-2 and C.
.pp
The second example in section 2.5. illuminates the relationship between
.i ast
and Oberon. The node type Stats is a base type with two fields, a child and an attribute.
It is extended e. g. by the node type While with two more fields which are children.
.sh 2 "Context-Free Grammars"
.pp
As already mentioned,
.i ast
specifications are based on context-free grammars.
.i Ast
specifications extend context-free grammars by selector names for right-hand
side symbols, attributes, the extension mechanism, and modules. If these
features are
omitted, we basically arrive at context-free grammars. This holds from the
syntactic as well as from the semantic point of view. The names of the node
types represent both terminal or nonterminal symbols and rule names.
Node types correspond to grammar rules. The notions of derivation and
derivation tree can be used similarly in both cases. The selector names can
be seen as syntactic sugar and the attributes as some kind of terminal
symbols. The extension mechanism is equivalent to a shorthand notation for
factoring out common rule parts in combination with implicit chain rules.
.(b
Example:
.sp 0.5
\fIast\fP specification:
.sp 0.5
.FT
Stats           = Next: Stats <
   If           = Expr Then: Stats Else: Stats .
   While        = Expr Stats .
> .
.)b
.(b
corresponding context-free grammar:
.sp 0.5
.FT
Stats           = Stats .
Stats           = Stats If .
Stats           = Stats While .
If              = Expr Stats Stats .
While           = Expr Stats .
.)b
.pp
In the example above, Stats corresponds to a nonterminal.
There are two rules or right-hand sides for Stats which are named If and While.
The latter would be regarded as nonterminals, too, if a child of types If or While would be
specified.
.sh 2 "Attribute Grammars"
.pp
Attribute grammars\*([<\*([[Knu68\*(],Knu71\*(]]\*(>]
and
.i ast
specifications are based on context-free grammars and associate attributes with terminal
and nonterminals symbols. Additionally
.i ast
allows attributes which are local to rules.
As the structure of the tree itself is known and transparent, subtrees can be
accessed or created dynamically and used as attribute values. The access of
the right-hand side symbols uses the selector names for symbolic access
instead of the grammar symbol with an additional subscript if needed.
There is no need to map chain rules
to tree nodes because of the extension mechanism offered by
.i ast.
Attribute evaluation is outside the scope of
.i ast .
This can be done either with the attribute evaluator generator
.i ag
\*([[Gro89\*(]] which understands
.i ast
specifications extended by attribute computation rules and processes the
trees generated by
.i ast
or by hand-written programs that use an
.i ast
generated module. In the latter case attribute computations do not have to
obey the single assignment restriction for attributes. They can assign a
value to an attribute zero, one, or several times.
.sh 2 "Interface Description Language (IDL)"
.pp
The approach of
.i ast
is similar to the one of IDL\*([<\*([[Lam87\*(],NNG89\*(]]\*(>].
Both specify attributed trees as well as graphs.
Node types without extensions are called nodes in IDL and node types with
extensions (base types) are called classes.
.i Ast
has simplified this to the single notion of a node type.
Attributes are treated similarly in both systems.
Children and attributes are both regarded as attributes, as
structural and non-structural ones, with only little difference in between.
Both systems allow multiple inheritance of attributes,
.i ast
has a separate syntax for single inheritance and uses the notion extension instead
\*([[Wir88c\*(]].
IDL knows the predefined types INTEGER, RATIONAL, BOOLEAN, STRING, SEQ OF,
and SET OF. It offers special operations for the types SEQ OF and SET OF.
.i Ast
really has no built in types at all, it uses the ones of the target language
and has a table containing the type specific operations e.\ g. for reading
and writing.
Both
.i ast
and IDL allow attributes of user-defined types. In
.i ast ,
the type specific operations for predefined or user-defined
types are easily expressed by macros using the target language directly.
IDL offers an assertion language whereas
.i ast
does not. IDL provides a mechanism to modify existing specifications.
The module feature of
.i ast
can be used to extend existing specifications.
From
.i ast ,
readers and writers are requested with simple command line options instead of
complicated syntactic constructs.
.i Ast
does not support representation specifications, because representations are
much more easily expressed using the types of the target language directly.
Summarizing, we consider
.i ast
to have a simpler specification method and to generate more powerful
features like aggregates, reversal of lists, and graph browsers.
.sh 2 "Attribute Coupled Grammars"
.pp
Attribute coupled grammars (ACG's)\*([<\*([[Gie88\*(]]\*(>] or algebraic
specifications\*([<\*([[HHK88\*(]]\*(>] have only very little in common with
.i ast
specifications. They all view node types or rules as signatures of
functions. The name of the node type plays the role of the function name and
describes the result type. The types of the children and attributes
correspond to the type of the function arguments.
The constructor procedures generated by
.i ast
reflect this view best.
.sh 2 "Object-Oriented Languages"
.pp
The extension mechanism of
.i ast
is exactly the same as single inheritance in object-oriented languages like
e. g. Simula\*([<\*([[DMN70\*(]]\*(>] or Smalltalk\*([<\*([[Gol84\*(]]\*(>].
The hierarchy introduced by the extension mechanism corresponds
directly to the class hierarchy of object-oriented languages.
The notions base type and super class both represent the same concept.
Messages and virtual procedures are out of the scope of
.i ast.
Virtual procedures might be simulated with procedure-valued attributes.
Table 5 summarizes the corresponding notions of trees
(\fIast\fP), type extensions, and object-oriented programming.
.(z L
.sp 0.5
.ce
Table 5: Comparison of notions from the areas of trees, types, and object-oriented programming
.sp 0.5
.TS
center;
l | l | l.
trees	types	object-oriented programming
_
node type	record type	class
-	base type	superclass
-	derived type	subclass
attribute, child	record field	instance variable
tree node	record variable	object, instance
-	extension	inheritance
.TE
.)z
.sh 2 "Tree Grammars"
.pp
Conventional tree grammars are characterized by the fact that all
right-hand sides start with a terminal symbol. They are used for the
description of string languages that represent trees in prefix form.
.i Ast
specifications describe trees  which are represented by (absolute) pointers
from parent to child nodes. If we shift the names of node types of
.i ast
specifications to the beginning of the right-hand side and interpret them as
terminals we arrive at conventional tree grammars. That is exactly what is done by
the
.i ast
tree/graph writers. They write a tree in prefix form and prepend every node
with the name of its node type.
That is necessary to be able to perform the read operations.
.sh 1 "Hints on Specifying Abstract Syntax"
.ip -
Keep the abstract syntax as short and simple as possible.
.ip -
Try to normalize by representing only the most general form.
.ip -
Normalize to the general form e. g. by adding default values.
.ip -
Normalize several concrete representations to one abstract construct.
.ip -
Map concrete to abstract syntax by disregarding the concrete syntax
rules and by concentrating on the semantic structure of the abstract syntax.
.ip -
Map several concrete nonterminals to one abstract node type (e. g. Expr,
Term, and Factor \(-> Expr)
.ip -
Allow all lists to be empty regardless of the concrete syntax.
Otherwise you have to process the list element at two places in exactly the
same way. This causes programming overhead and violates the law of
singularity: "One thing only once!"
.ip -
Operators can be represented by different node types (e. g. Plus, Minus,
Mult, ...) or by one node type with an
attribute describing the operator (e. g. Binary).
.ip -
Lists can be represented by separate nodes for the list and the elements
(e. g. Stats and Stat) or by nodes for the elements where every node has
a child that refers to the next list element (see last example in section 2.11.1.).
.sh 1 Examples
.pp
The Appendices 1 to 3 contain examples of
.i ast
specifications.
.pp
Appendix 1 contains the concrete syntax of
.i ast's
specification language. The node types enclosed in quotes or starting with
the character 't' constitute the terminals for
.i ast's
parser. The extensions and the node types used for the latter describe the lexical grammar.
.pp
Appendix 2 contains the concrete syntax of a small example programming
language called
.i MiniLAX
\*([[GrK88\*(]].
The attributes specified are the ones a parser would evaluate during parsing.
The Appendices 1 and 2 show how concrete grammars can be described with
.i ast .
.pp
Appendix 3 contains an abstract syntax for MiniLAX.
The attributes specified are input or intrinsic ones whose values would be provided
by the scanner and parser.
The definition follows the hints of the previous section.
Terminal symbols without attributes are omitted.
All binary and unary operators are expressed by two nodes having one
attribute to represent the operator.
To simplify things as much as possible all lists are allowed to be empty and
procedure declarations as well as calls always have a parameter list.
The specification tries to keep the tree as small as possible.
The inheritance mechanism allows to avoid all chain rules. There are no
nodes for sequences of declarations, statements, etc.. Instead every node
for a declaration or a statement has a field named
.i Next
describing the successor entity. Except for expressions no separate nodes
are used for identifiers. The information is included as attribute in the
node types
.i "Proc, Var, Formal" ,
and
.i Call .
The source position is stored only at the nodes where it might be needed
during semantic analysis. The above measures not only reduce the amount of
storage but they also reduce run time because less information has to be
produced and processed.
.sh 1 "Experiences"
.pp
.i Ast
can be used not only for abstract syntax trees in compilers but for every
tree or graph like data structure. In general the data structure can serve
as interface between phases within a program or between separate programs.
In the latter case it would be communicated via a file using the generated
reader and writer procedures.
.pp
Generated tree respectively graph modules have successfully been used in
compilers e.\ g. for MiniLAX\*([<\*([[WGS89\*(]]\*(>] and UNITY
\*([[Bie89\*(]] as well as for a Modula to C translator\*([<\*([[Mar90\*(]]\*(>].
The modules for the internal data structure of
.i ast
itself and the attribute evaluator generator
.i ag
\*([[Gro89\*(]] have also been generated by
.i ast .
Moreover, the symbol table module of the Modula to C translator has been generated.
.pp
The advantage of this approach is that it saves considerably hand-coding of
trivial declarations and operations. Table 6 lists the sizes (numbers of
lines) of some specifications and the generated modules.
Sums in the specification column are composed of the sizes for
the definition of node types and for user-supplied target code.
Sums in the tree module column are composed of the sizes for the
definition part and for the implementation part.
The reason for the large sizes of the tree modules comes from the numerous
node constructor procedures and from the graph browser in the case of
.i ag .
These procedures proved to be very helpful for debugging purposes
as they provide readable output of complex data structures. The constructor
procedures allow to write record aggregates. Therefore, node creation and
assignment of values to the components can be written very compact.
It is even possible to write (ground) terms as in Prolog or LISP by
nested calls of the constructor procedures.
.(b L
.sp 0.5
.ce
Table 6: Examples of Ast Applications
.sp 0.5
.TS
center;
l | r | r.
application	specification	tree module
_
MiniLAX 	56      	202 + \0835 = 1037
Modula-2	240      	583 + 3083 = 3666
UNITY   	210      	207 + \0962 = 1169
Ag      	78 + 347 = 425	317 + 1317 = 1634
Definition table	82 + 900 = 982	399 + 1431 = 1830
.TE
.)b
.sh 1 "Usage"
.pp
.de TH
..
.TH AST 1 "" "GMD-Forschungsstelle-Karlsruhe"
.SH NAME
ast - generator for abstract structure/syntax trees
.SH SYNOPSIS
ast [-options] [-ldir] [file]
.SH DESCRIPTION
.I Ast
generates a program module to handle arbitrary attributed trees and graphs.
A typical application is the abstract syntax tree in a compiler.
The input
.I file
contains a specification which describes the structure of all
possible trees or nodes respectively and the attributes of the nodes.
.I Ast
generates type declarations to implement the tree and several procedures for
tree manipulation including ASCII and binary readers and writers (see options below).
If
.I file
is omitted the specification is read from standard input.
.SH OPTIONS
.ta 2.5i
.IP a
generate all except -ch (default)
.IP n
generate node constructors	procedures n<node> (node)
.IP m
generate node constructors	procedures m<node> (make)
.IP f
generate node/tree destroyer	procedure ReleaseTREE (free)
.IP F
generate general destroyer	procedure ReleaseTREEModule (FREE)
.IP o
generate ASCII node writer	procedure WriteTREENode (output)
.IP r
generate ASCII graph reader	procedure ReadTREE
.IP w
generate ASCII graph writer	procedure WriteTREE
.IP g
generate binary graph reader	procedure GetTREE
.IP p
generate binary graph writer	procedure PutTREE
.IP R
generate list reverser	procedure ReverseTREE
.IP t
generate top down traversal	procedure TraverseTREETD
.br
(reverse depth first)
.IP b
generate bottom up traversal	procedure TraverseTREEBU
.br
(depth first)
.IP y
generate graph copy	procedure CopyTREE
.IP =
generate tree equality test	procedure IsEqualTREE
.IP k
generate graph checker	procedure CheckTREE
.IP q
generate graph browser	procedure QueryTREE
.IP d
generate definition module
.IP i
generate implementation module
.IP s
generate import statements
.IP 4
generate tree/graph description in file VIEW.TS
.IP 6
generate # line directives
.IP 7
touch output files only if necessary
.IP 8
report storage consumption
.IP c
generate C code (default is Modula-2)
.IP h
print help information
.IP l\fRdir
.I dir
is the directory where ast finds its table files
.SH FILES
.nf
.ta 2i
if output is in C:
.sp 0.5
<module>.h	specification of the generated graph module
<module>.c	body of the generated graph module
yy<module>.w	macro file defining type specific operations
.sp 0.5
if output is in Modula-2:
.sp 0.5
<module>.md	definition module of the generated graph module
<module>.mi	implementation module of the generated graph module
<module>.imp	import statements
.fi
.SH SEE\ ALSO
.sp 0.5
J. Grosch: "Ast - A Generator for Abstract Syntax Trees",
GMD Forschungsstelle an der Universitaet Karlsruhe,
Compiler Generation Report No. 15
.sp 0.5
J. Grosch: "Tool Support for Data Structures",
Structured Programming, 12, 31-38 (1991)
.sz 12
.[]
.[-
.ds [F Bie89
.ds [A F\*(p] Bieler
.ds [T An Interpreter for Chandy/Misra's UNITY
.ds [R internal paper
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [D 1989
.][
.[-
.ds [F DMN70
.ds [A O\*(p] Dahl
.as [A \*(c]B\*(p] Myrhaug
.as [A \*(m]K\*(p] Nygaard
.ds [T SIMULA 67 Common Base Language - Publication S-22
.ds [I Norwegian Computing Center
.ds [C Oslo
.ds [D 1970
.][
.[-
.ds [F Gie88
.ds [A R\*(p] Giegerich
.ds [T Composition and Evaluation of Attribute Coupled Grammars
.ds [J Acta Inf.
.ds [V 25
.nr [P 1
.ds [P 355-423
.ds [D 1988
.][
.[-
.ds [F Gol84
.ds [A A\*(p] Goldberg
.ds [T Smalltalk-80: The Interactive Programming Environment
.ds [I Addison Wesley
.ds [C Reading, M\&A
.ds [C Reading, MA
.ds [D 1984
.][
.[-
.ds [F Gro87
.ds [A J\*(p] Grosch
.ds [T Reusable Software - A Collection of Modula-Modules
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [R Compiler Generation Report No. 4
.ds [N 4
.ds [D Sep. 1987
.][
.[-
.ds [F GrK88
.ds [A J\*(p] Grosch
.as [A \*(n]E\*(p] Klein
.ds [T \\*:Ubersetzerbau-Praktikum
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [R Compiler Generation Report No. 9
.ds [N 9
.ds [D June 1988
.][
.[-
.ds [F GrV88
.ds [A J\*(p] Grosch
.as [A \*(n]B\*(p] Vielsack
.ds [T The Parser Generators Lalr and Ell
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [R Compiler Generation Report No. 8
.ds [N 8
.ds [D Apr. 1988
.][
.[-
.ds [F Gro88
.ds [A J\*(p] Grosch
.ds [T Generators for High-Speed Front-Ends
.ds [V 371
.ds [J LNCS
.ds [C Berlin
.ds [I Springer Verlag
.nr [P 1
.ds [P 81-92
.ds [D Oct. 1988
.][
.[-
.ds [F Gro89
.ds [A J\*(p] Grosch
.ds [T Ag - An Attribute Evaluator Generator
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [R Compiler Generation Report No. 16
.ds [N 16
.ds [D Aug. 1989
.][
.[-
.ds [F Gro91
.ds [A J\*(p] Grosch
.ds [T Puma - A Generator for the Transformation of Attributed Trees
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [R Compiler Generation Report No. 26
.ds [N 26
.ds [D July 1991
.][
.[-
.ds [F HHK88
.ds [A J\*(p] Heering
.as [A \*(c]P\*(p]\*(a]R\*(p]\*(a]H\*(p] Hendriks
.as [A \*(c]P\*(p] Klint
.as [A \*(m]J\*(p] Rekers
.ds [T The Syntax Definition Formalism SDF - Reference Manual
.ds [I ESPRIT Project GIPE
.ds [D Dec. 1988
.][
.[-
.ds [F Joh75
.ds [A S\*(p]\*(a]C\*(p] Johnson
.ds [T Yacc \(em  Yet Another Compiler-Compiler
.ds [R Computer Science Technical Report 32
.ds [I Bell Telephone Laboratories
.ds [C Murray Hill, NJ
.ds [D July 1975
.][
.[-
.ds [F Knu68
.ds [A D\*(p]\*(a]E\*(p] Knuth
.ds [T Semantics of Context-Free Languages
.nr [P 1
.ds [P 127-146
.ds [J Mathematical Systems Theory
.ds [V 2
.ds [D June 1968
.ds [N 2
.][
.[-
.ds [F Knu71
.ds [A D\*(p]\*(a]E\*(p] Knuth
.ds [T Semantics of Context-free Languages: Correction
.nr [P 1
.ds [P 95-96
.ds [J Mathematical Systems Theory
.ds [V 5
.ds [D Mar. 1971
.][
.[-
.ds [F Lam87
.ds [A D\*(p]\*(a]A\*(p] Lamb
.ds [T IDL: Sharing Intermediate Representations
.nr [P 1
.ds [P 297-318
.ds [J ACM Trans. Prog. Lang. and Systems
.ds [V 9
.ds [N 3
.ds [D July 1987
.][
.[-
.ds [F Mar90
.ds [A M\*(p] Martin
.ds [T Entwurf und Implementierung eines \\*:Ubersetzers von Modula-2 nach C
.ds [R Diplomarbeit
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [D Feb. 1990
.][
.[-
.ds [F NNG89
.ds [A J\*(p]\*(a]R\*(p] Nestor
.as [A \*(c]J\*(p]\*(a]M\*(p] Newcomer
.as [A \*(c]P\*(p] Giannini
.as [A \*(m]D\*(p]\*(a]L\*(p] Stone
.ds [T IDL: The Language and its Implementation
.ds [I Prentice Hall
.ds [C Englewood Cliffs, NJ
.ds [C Englewood Cliffs
.ds [D 1989
.][
.[-
.ds [F Par88
.ds [A J\*(p]\*(a]C\*(p]\*(a]H\*(p] Park
.ds [T y+: A Yacc Preprocessor for Certain Semantic Actions
.ds [J SI\&GPLAN Notices
.ds [V 23
.ds [N 6
.nr [P 1
.ds [P 97-106
.ds [D 1988
.][
.[-
.ds [F WGS89
.ds [A W\*(p]\*(a]M\*(p] Waite
.as [A \*(c]J\*(p] Grosch
.as [A \*(m]F\*(p]\*(a]W\*(p] Schr\\*:oer
.ds [T Three Compiler Specifications
.ds [R GMD-Studie Nr. 166
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [D Aug. 1989
.][
.[-
.ds [F Wir88a
.ds [A N\*(p] Wirth
.ds [T The Programming Language Oberon
.ds [J Software\(emPractice & Experience
.ds [V 18
.ds [N 7
.ds [D July 1988
.nr [P 1
.ds [P 671-690
.][
.[-
.ds [F Wir88b
.ds [A N\*(p] Wirth
.ds [T From Modula to Oberon
.ds [J Software\(emPractice & Experience
.ds [V 18
.ds [N 7
.ds [D July 1988
.nr [P 1
.ds [P 661-670
.][
.[-
.ds [F Wir88c
.ds [A N\*(p] Wirth
.ds [T Type Extensions
.ds [J ACM Trans. Prog. Lang. and Systems
.ds [V 10
.ds [N 2
.ds [D Apr. 1988
.nr [P 1
.ds [P 204-214
.][
.bp
.uh "Appendix 1: Syntax of the Specification Language"
.sp
.nf
.FT
RULE                                    /* Ast: concrete syntax */

/* parser grammar */

Specification    = <
                 =               TreeCodes PropPart DeclPart RulePart Modules .
                 = 'MODULE' Name TreeCodes PropPart DeclPart RulePart
                   'END' Name Modules .
> .
TreeCodes        = <
                 =             SubUnit .
                 = 'TREE'      SubUnit Codes .
                 = 'TREE' Name SubUnit Codes .
> .
Codes            = <
                 = .
                 = Codes 'EXPORT' tTargetCode .
                 = Codes 'IMPORT' tTargetCode .
                 = Codes 'GLOBAL' tTargetCode .
                 = Codes 'LOCAL'  tTargetCode .
                 = Codes 'BEGIN'  tTargetCode .
                 = Codes 'CLOSE'  tTargetCode .
> .
SubUnit          = <
                 = .
                 = SubUnit 'SUBUNIT' Name .
                 = SubUnit 'VIEW'    Name .
> .
PropPart         = Props .

Props            = <
                 =
                 = Props 'PROPERTY' Properties
                 = Props 'PROPERTY' Properties 'FOR' Names
                 = Props 'SELECT' Names
> .
DeclPart         = <
                 = .
                 = 'DECLARE' Decls .
> .
Decls            = <
                 = .
   MoreNonterms  = Decls Names '=' AttrDecls '.' .
   MoreTerminals = Decls Names ':' AttrDecls '.' .
> .
Names            = <
                 = .
                 = Names Name .
                 = Names ',' .
> .
RulePart         = <
                 = .
                 = 'RULE' Types .
> .
Types            = <
                 = .
   Nonterminal   = Types Name BaseTypes '='  AttrDecls Extensions '.' .
   Terminal      = Types Name BaseTypes ':'  AttrDecls Extensions '.' .
   Abstract      = Types Name BaseTypes ':=' AttrDecls Extensions '.' .
> .
BaseTypes        = <
                 = .
                 = '<-' Names .
> .
Extensions       = <
                 = .
                 = '<' Types '>' .
> .
AttrDecls        = <
                 = .
   ChildSelct    = AttrDecls     Name ':' Name Properties .
   ChildNoSelct  = AttrDecls              Name Properties .
   AttrTyped     = AttrDecls '[' Name ':' Name Properties ']' .
   AttrInteger   = AttrDecls '[' Name          Properties ']' .
> .
Properties       = <
                 = .
                 = Properties 'INPUT' .
                 = Properties 'OUTPUT' .
                 = Properties 'SYNTHESIZED' .
                 = Properties 'INHERITED' .
                 = Properties 'THREAD' .
                 = Properties 'REVERSE' .
                 = Properties 'IGNORE' .
                 = Properties 'VIRTUAL' .
> .
Modules          = <
                 = .
                 = Modules 'MODULE' Name TreeCodes DeclPart RulePart 'END' Name .
> .
Name             = <
                 = tIdent .
                 = tString .
> .

/* lexical grammar */

tIdent           : <
                 = Letter .
                 = tIdent Letter .
                 = tIdent Digit .
                 = tIdent '_' .
> .
tString          : <
                 = "'" Characters "'" .
                 = '"' Characters '"' .
> .
tTargetCode      : '{' Characters '}' .

Comment          : '/*' Characters '*/' .

Characters       : <
                 = .
                 = Characters Character .
> .
.FR
.bp
.uh "Appendix 2: Concrete Syntax of the Example Language MiniLAX"
.sp
.nf
.FT
.sz -2
RULE
.sp 0.5
Prog            = PROGRAM tIdent ';' 'DECLARE' Decls 'BEGIN' Stats 'END' '.' .
Decls           = <
   Decls1       = Decl .
   Decls2       = Decls ';' Decl .
> .
Decl            = <
   Var          = tIdent ':' Type .
   Proc0        = PROCEDURE tIdent ';' 'DECLARE' Decls 'BEGIN' Stats 'END' .
   Proc         = PROCEDURE tIdent '(' Formals ')' ';'
                                       'DECLARE' Decls 'BEGIN' Stats 'END' .
> .
Formals         = <
   Formals1     = Formal .
   Formals2     = Formals ';' Formal .
> .
Formal          = <
   Value        = tIdent ':' Type .
   Ref          = VAR tIdent ':' Type .
> .
Type            = <
   Int          = INTEGER .
   Real         = REAL .
   Bool         = BOOLEAN .
   Array        = ARRAY '[' Lwb: tIntegerConst '..' Upb: tIntegerConst ']' OF Type .
> .
Stats           = <
   Stats1       = Stat .
   Stats2       = Stats ';' Stat .
> .
Stat            = <
   Assign       = Adr ':=' Expr .
   Call0        = tIdent .
   Call         = tIdent '(' Actuals ')' .
   If           = IF Expr THEN Then: Stats ELSE Else: Stats 'END' .
   While        = WHILE Expr DO Stats 'END' .
   Read         = READ '(' Adr ')' .
   Write        = WRITE '(' Expr ')' .
> .
Actuals         = <
   Expr1        = Expr .
   Expr2        = Actuals ',' Expr .
> .
Expr            = <
   Less         = Lop: Expr '<' Rop: Expr .
   Plus         = Lop: Expr '+' Rop: Expr .
   Times        = Lop: Expr '*' Rop: Expr .
   Not          = NOT Expr .
   '()'         = '(' Expr ')' .
   IConst       = tIntegerConst .
   RConst       = tRealConst .
   False        = FALSE .
   True         = TRUE .
   Adr          = <
      Name      = tIdent .
      Index     = Adr '[' Expr ']' .
   > .
> .
tIdent          : [Ident: tIdent] .
tIntegerConst   : [Integer      ] .
tRealConst      : [Real : REAL  ] .
.sz +2
.FR
.bp
.uh "Appendix 3: Abstract Syntax of the Example Language MiniLAX"
.sp
.nf
.FT
TREE                                    /* MiniLAX: abstract syntax */
IMPORT  { FROM Idents IMPORT tIdent;
          TYPE tPosition = RECORD Line, Column: CARDINAL; END; }

GLOBAL  { FROM Idents IMPORT tIdent; }

RULE

MiniLax         = Proc .
Decls           = <
   NoDecl       = .
   Decl         = Next: Decls REV [Ident: tIdent] [Pos: tPosition] <
      Proc      = Formals Decls Stats .
      Var       = Type .
   > .
> .
Formals         = <
   NoFormal     = .
   Formal       = Next: Formals REV [Ident: tIdent] [Pos: tPosition] Type .
> .
Type            = <
   Integer      = .
   Real         = .
   Boolean      = .
   Array        = Type                [Lwb] [Upb] [Pos: tPosition] .
   Ref          = Type .
> .
Stats           = <
   NoStat       = .
   Stat         = Next: Stats REV <
      Assign    = Adr Expr            [Pos: tPosition] .
      Call      = Actuals             [Ident: tIdent] [Pos: tPosition] .
      If        = Expr Then: Stats Else: Stats .
      While     = Expr Stats .
      Read      = Adr .
      Write     = Expr .
   > .
> .
Actuals         = <
   NoActual     =                     [Pos: tPosition] .
   Actual       = Next: Actuals REV Expr .
> .
Expr            =                     [Pos: tPosition] <
   Binary       = Lop: Expr Rop: Expr [Operator] .
   Unary        = Expr                [Operator] .
   IntConst     =                     [Value         ] .
   RealConst    =                     [Value: REAL   ] .
   BoolConst    =                     [Value: BOOLEAN] .
   Adr          = <
      Index     = Adr Expr .
      Ident     =                     [Ident: tIdent] .
   > .
> .
.FR
.bp
.uh "Appendix 4: Generated Header File for C"
.sp 0.2
.nf
.FT
# ifndef yyTREE   /* throughout replace TREE by the name of the tree module */
# define yyTREE
<import_declarations>
# define bool char
# define NoTREE (tTREE) NULL
# define k<type_1> 1
# define k<type_1> 2
   ...
typedef unsigned short TREE_tKind;   /* or char */
typedef unsigned short TREE_tMark;
typedef unsigned short TREE_tLabel;
typedef union TREE_Node * tTREE;
typedef void (* TREE_tProcTree) ();
<export_declarations>
# ifndef TREE_NodeHead
# define TREE_NodeHead
# endif
typedef struct { TREE_tKind yyKind; TREE_tMark yyMark; TREE_NodeHead } TREE_tNodeHead;
typedef struct { TREE_tNodeHead yyHead;
                 <children_and_attributes_of_type_1> } y<type_1>;
typedef struct { TREE_tNodeHead yyHead;
                 <children_and_attributes_of_type_2> } y<type_2>;
   ...
union TREE_Node {
   TREE_tKind Kind;
   TREE_tNodeHead yyHead;
   y<type_1> <type_1>;
   y<type_2> <type_2>;
    ...
};
extern tTREE TREERoot;
extern unsigned long TREE_HeapUsed;
extern unsigned short TREE_NodeSize [];
extern char * TREE_NodeName [];
extern tTREE n<type_1>          ();
extern tTREE n<type_2>          ();
   ...
extern tTREE m<type_1>          (<input_children_and_attributes_of_type_1>);
extern tTREE m<type_2>          (<input_children_and_attributes_of_type_2>);
   ...
extern tTREE MakeTREE           (TREE_tKind Kind);
extern bool  TREE_IsType        (tTREE t, TREE_tKind Kind);
extern void  ReleaseTREE        (tTREE t);
extern void  ReleaseTREEModule  ();
extern void  WriteTREENode      (FILE * f, tTREE t);
extern void  WriteTREE          (FILE * f, tTREE t);
extern tTREE ReadTREE           (FILE * f);
extern void  PutTREE            (FILE * f, tTREE t);
extern tTREE GetTREE            (FILE * f);
extern void  TraverseTREETD     (tTREE t, void (* Procedure) (tTREE t));
extern void  TraverseTREEBU     (tTREE t, void (* Procedure) (tTREE t));
extern tTREE ReverseTREE        (tTREE t);
extern tTREE CopyTREE           (tTREE t);
extern bool  CheckTREE          (tTREE t);
extern void  QueryTREE          (tTREE t);
extern bool  IsEqualTREE        (tTREE t1, tTREE t2);
extern void  BeginTREE          ();
extern void  CloseTREE          ();
# endif
.FR
.bp
.uh "Appendix 5: Generated Definition Module for Modula-2"
.sp 0.5
.nf
.FT
DEFINITION MODULE TREE;
   IMPORT IO;     (* throughout replace TREE by the name of the tree module *)
.sp 0.2
   <import_declarations>
.sp 0.2
   CONST
      NoTREE       = NIL;
      <type_1>     = 1;
      <type_2>     = 2;
      ...
.sp 0.2
   TYPE
      tTREE        = POINTER TO yyNode;
      tProcTree    = PROCEDURE (tTREE);
.sp 0.2
   <export_declarations>
.sp 0.2
   TYPE
      yytNodeHead  = RECORD yyKind, yyMark: SHORTCARD; END;
.sp 0.2
   TYPE
      y<type_1>    = RECORD yyHead: yytNodeHead;
                            <children_and_attributes_of_type_1> END;
      y<type_2>    = RECORD yyHead: yytNodeHead;
                            <children_and_attributes_of_type_2> END;
      ...
.sp 0.2
      yyNode       = RECORD
         CASE : SHORTCARD OF
         | 0        : Kind: SHORTCARD;
         | ...      : yyHead: yytNodeHead;
         | <type_1> : <type_1>    : y<type_1>;
         | <type_2> : <type_2>    : y<type_2>;
         ...
         END;
      END;
.sp 0.2
   VAR TREERoot  : tTREE;
   VAR HeapUsed  : LONGCARD;
   VAR yyNodeSize: ARRAY [ ... ] OF SHORTCARD;
.sp 0.2
   PROCEDURE n<type_1>      (): tTREE;
   PROCEDURE n<type_2>      (): tTREE;
   ...
   PROCEDURE m<type_1>      (<input_children_and_attributes_of_type_1>): tTREE;
   PROCEDURE m<type_2>      (<input_children_and_attributes_of_type_2>): tTREE;
   ...
   PROCEDURE MakeTREE       (Kind: SHORTCARD): tTREE;
   PROCEDURE IsType         (Tree: tTREE; Kind: SHORTCARD): BOOLEAN;
   PROCEDURE ReleaseTREE    (Tree: tTREE);
   PROCEDURE ReleaseTREEModule;
   PROCEDURE WriteTREENode  (f: IO.tFile; Tree: tTREE);
   PROCEDURE WriteTREE      (f: IO.tFile; Tree: tTREE);
   PROCEDURE ReadTREE       (f: IO.tFile): tTREE;
   PROCEDURE PutTREE        (f: IO.tFile; Tree: tTREE);
   PROCEDURE GetTREE        (f: IO.tFile): tTREE;
   PROCEDURE ReverseTREE    (Tree: tTREE): tTREE;
   PROCEDURE TraverseTREETD (Tree: tTREE; Proc: tProcTree);
   PROCEDURE TraverseTREEBU (Tree: tTREE; Proc: tProcTree);
   PROCEDURE CopyTREE       (Tree: tTREE): tTree;
   PROCEDURE CheckTREE      (Tree: tTREE): BOOLEAN;
   PROCEDURE QueryTREE      (Tree: tTREE);
   PROCEDURE IsEqualTREE    (Tree1, Tree2: tTREE): BOOLEAN;
   PROCEDURE BeginTREE;
   PROCEDURE CloseTREE;
END TREE.
.FR
.bp
.uh "Appendix 6: Predefined Type Operations for C"
.sp
.nf
.FT
/* int */
# define beginint(a)
# define closeint(a)
# define readint(a)             (void) fscanf (yyf, "%d", & a);
# define writeint(a)            (void) fprintf (yyf, "%d", a);
# define getint(a)              yyGet ((char *) & a, sizeof (a));
# define putint(a)              yyPut ((char *) & a, sizeof (a));
# define copyint(a, b)
# define equalint(a, b)         a == b
/* short */
# define beginshort(a)
# define closeshort(a)
# define readshort(a)           (void) fscanf (yyf, "%hd", & a);
# define writeshort(a)          (void) fprintf (yyf, "%hd", a);
# define getshort(a)            yyGet ((char *) & a, sizeof (a));
# define putshort(a)            yyPut ((char *) & a, sizeof (a));
# define copyshort(a, b)
# define equalshort(a, b)       a == b
/* long */
# define beginlong(a)
# define closelong(a)
# define readlong(a)            (void) fscanf (yyf, "%ld", & a);
# define writelong(a)           (void) fprintf (yyf, "%ld", a);
# define getlong(a)             yyGet ((char *) & a, sizeof (a));
# define putlong(a)             yyPut ((char *) & a, sizeof (a));
# define copylong(a, b)
# define equallong(a, b)        a == b
/* unsigned */
# define beginunsigned(a)
# define closeunsigned(a)
# define readunsigned(a)        (void) fscanf (yyf, "%u", & a);
# define writeunsigned(a)       (void) fprintf (yyf, "%u", a);
# define getunsigned(a)         yyGet ((char *) & a, sizeof (a));
# define putunsigned(a)         yyPut ((char *) & a, sizeof (a));
# define copyunsigned(a, b)
# define equalunsigned(a, b)    a == b
/* float */
# define beginfloat(a)
# define closefloat(a)
# define readfloat(a)           (void) fscanf (yyf, "%g", & a);
# define writefloat(a)          (void) fprintf (yyf, "%g", a);
# define getfloat(a)            yyGet ((char *) & a, sizeof (a));
# define putfloat(a)            yyPut ((char *) & a, sizeof (a));
# define copyfloat(a, b)
# define equalfloat(a, b)       a == b
/* double */
# define begindouble(a)
# define closedouble(a)
# define readdouble(a)          (void) fscanf (yyf, "%lg", & a);
# define writedouble(a)         (void) fprintf (yyf, "%lg", a);
# define getdouble(a)           yyGet ((char *) & a, sizeof (a));
# define putdouble(a)           yyPut ((char *) & a, sizeof (a));
# define copydouble(a, b)
# define equaldouble(a, b)      a == b
/* bool */
# define beginbool(a)
# define closebool(a)
# define readbool(a)            a = fgetc (yyf) == 'T';
# define writebool(a)           (void) fputc (a ? 'T' : 'F', yyf);
# define getbool(a)             yyGet ((char *) & a, sizeof (a));
# define putbool(a)             yyPut ((char *) & a, sizeof (a));
# define copybool(a, b)
# define equalbool(a, b)        a == b
/* char */
# define beginchar(a)
# define closechar(a)
# define readchar(a)            a = fgetc (yyf);
# define writechar(a)           (void) fputc (a, yyf);
# define getchar(a)             yyGet ((char *) & a, sizeof (a));
# define putchar(a)             yyPut ((char *) & a, sizeof (a));
# define copychar(a, b)
# define equalchar(a, b)        a == b
/* tString */
# define begintString(a)
# define closetString(a)
# define readtString(a)
# define writetString(a)        (void) fputs (a, yyf);
# define gettString(a)
# define puttString(a)
# define copytString(a, b)
# define equaltString(a, b)     strcmp (a, b)
/* tStringRef */
# define begintStringRef(a)
# define closetStringRef(a)
# define readtStringRef(a)
# define writetStringRef(a)     WriteString (yyf, a);
# define gettStringRef(a)
# define puttStringRef(a)
# define copytStringRef(a, b)
# define equaltStringRef(a, b)  a == b
/* tIdent */
# define begintIdent(a)
# define closetIdent(a)
# define readtIdent(a)          a = yyReadIdent ();
# define writetIdent(a)         WriteIdent (yyf, a);
# define gettIdent(a)           yyGetIdent (& a);
# define puttIdent(a)           yyPutIdent (a);
# define copytIdent(a, b)
# define equaltIdent(a, b)      a == b
/* tSet */
# define begintSet(a)
# define closetSet(a)
# define readtSet(a)            ReadSet (yyf, & a);
# define writetSet(a)           WriteSet (yyf, & a);
# define gettSet(a)
# define puttSet(a)
# define copytSet(a, b)
# define equaltSet(a, b)        IsEqual (& a, & b)
/* tPosition */
# define begintPosition(a)
# define closetPosition(a)
# define readtPosition(a)
# define writetPosition(a)      WritePosition (yyf, a);
# define gettPosition(a)
# define puttPosition(a)
# define copytPosition(a, b)
# define equaltPosition(a, b)   Compare (a, b) == 0
.FR
.bp
.uh "Appendix 7: Predefined Type Operations for Modula-2"
.sp 0.5
.nf
.FT
(* INTEGER *)
# define beginINTEGER(a)
# define closeINTEGER(a)
# define readINTEGER(a)         a := IO.ReadI (yyf);
# define writeINTEGER(a)        IO.WriteI (yyf, a, 0);
# define getINTEGER(a)          yyGet (a);
# define putINTEGER(a)          yyPut (a);
# define copyINTEGER(a, b)
# define equalINTEGER(a, b)     a = b
(* SHORTINT *)
# define beginSHORTINT(a)
# define closeSHORTINT(a)
# define readSHORTINT(a)        a := IO.ReadI (yyf);
# define writeSHORTINT(a)       IO.WriteI (yyf, a, 0);
# define getSHORTINT(a)         yyGet (a);
# define putSHORTINT(a)         yyPut (a);
# define copySHORTINT(a, b)
# define equalSHORTINT(a, b)    a = b
(* LONGINT *)
# define beginLONGINT(a)
# define closeLONGINT(a)
# define readLONGINT(a)         a := IO.ReadI (yyf);
# define writeLONGINT(a)        IO.WriteI (yyf, a, 0);
# define getLONGINT(a)          yyGet (a);
# define putLONGINT(a)          yyPut (a);
# define copyLONGINT(a, b)
# define equalLONGINT(a, b)     a = b
(* CARDINAL *)
# define beginCARDINAL(a)
# define closeCARDINAL(a)
# define readCARDINAL(a)        a := IO.ReadI (yyf);
# define writeCARDINAL(a)       IO.WriteI (yyf, a, 0);
# define getCARDINAL(a)         yyGet (a);
# define putCARDINAL(a)         yyPut (a);
# define copyCARDINAL(a, b)
# define equalCARDINAL(a, b)    a = b
(* SHORTCARD *)
# define beginSHORTCARD(a)
# define closeSHORTCARD(a)
# define readSHORTCARD(a)       a := IO.ReadI (yyf);
# define writeSHORTCARD(a)      IO.WriteI (yyf, a, 0);
# define getSHORTCARD(a)        yyGet (a);
# define putSHORTCARD(a)        yyPut (a);
# define copySHORTCARD(a, b)
# define equalSHORTCARD(a, b)   a = b
(* LONGCARD *)
# define beginLONGCARD(a)
# define closeLONGCARD(a)
# define readLONGCARD(a)        a := IO.ReadI (yyf);
# define writeLONGCARD(a)       IO.WriteI (yyf, a, 0);
# define getLONGCARD(a)         yyGet (a);
# define putLONGCARD(a)         yyPut (a);
# define copyLONGCARD(a, b)
# define equalLONGCARD(a, b)    a = b
(* REAL *)
# define beginREAL(a)
# define closeREAL(a)
# define readREAL(a)            a := IO.ReadR (yyf);
# define writeREAL(a)           IO.WriteR (yyf, a, 0, 6, 1);
# define getREAL(a)             yyGet (a);
# define putREAL(a)             yyPut (a);
# define copyREAL(a, b)
# define equalREAL(a, b)        a = b
(* LONGREAL *)
# define beginLONGREAL(a)
# define closeLONGREAL(a)
# define readLONGREAL(a)        a := IO.ReadR (yyf);
# define writeLONGREAL(a)       IO.WriteR (yyf, a, 0, 6, 1);
# define getLONGREAL(a)         yyGet (a);
# define putLONGREAL(a)         yyPut (a);
# define copyLONGREAL(a, b)
# define equalLONGREAL(a, b)    a = b
(* BOOLEAN *)
# define beginBOOLEAN(a)
# define closeBOOLEAN(a)
# define readBOOLEAN(a)         a := IO.ReadB (yyf);
# define writeBOOLEAN(a)        IO.WriteB (yyf, a);
# define getBOOLEAN(a)          yyGet (a);
# define putBOOLEAN(a)          yyPut (a);
# define copyBOOLEAN(a, b)
# define equalBOOLEAN(a, b)     a = b
(* CHAR *)
# define beginCHAR(a)
# define closeCHAR(a)
# define readCHAR(a)            a := IO.ReadC (yyf);
# define writeCHAR(a)           IO.WriteC (yyf, a);
# define getCHAR(a)             yyGet (a);
# define putCHAR(a)             yyPut (a);
# define copyCHAR(a, b)
# define equalCHAR(a, b)        a = b
(* BITSET *)
# define beginBITSET(a)
# define closeBITSET(a)
# define readBITSET(a)          yyReadHex (a);
# define writeBITSET(a)         yyWriteHex (a);
# define getBITSET(a)           yyGet (a);
# define putBITSET(a)           yyPut (a);
# define copyBITSET(a, b)
# define equalBITSET(a, b)      a = b
(* BYTE *)
# define beginBYTE(a)
# define closeBYTE(a)
# define readBYTE(a)            yyReadHex (a);
# define writeBYTE(a)           yyWriteHex (a);
# define getBYTE(a)             yyGet (a);
# define putBYTE(a)             yyPut (a);
# define copyBYTE(a, b)
# define equalBYTE(a, b)        a = b
(* WORD *)
# define beginWORD(a)
# define closeWORD(a)
# define readWORD(a)            yyReadHex (a);
# define writeWORD(a)           yyWriteHex (a);
# define getWORD(a)             yyGet (a);
# define putWORD(a)             yyPut (a);
# define copyWORD(a, b)
# define equalWORD(a, b)        a = b
(* ADDRESS *)
# define beginADDRESS(a)
# define closeADDRESS(a)
# define readADDRESS(a)         yyReadHex (a);
# define writeADDRESS(a)        yyWriteHex (a);
# define getADDRESS(a)          yyGet (a);
# define putADDRESS(a)          yyPut (a);
# define copyADDRESS(a, b)
# define equalADDRESS(a, b)     a = b
(* tString *)
# define begintString(a)
# define closetString(a)
# define readtString(a)         Strings.ReadL (yyf, a);
# define writetString(a)        Strings.WriteL (yyf, a);
# define gettString(a)          yyGet (a);
# define puttString(a)          yyPut (a);
# define copytString(a, b)
# define equaltString(a, b)     Strings.IsEqual (a, b)
(* tStringRef *)
# define begintStringRef(a)
# define closetStringRef(a)
# define readtStringRef(a)
# define writetStringRef(a)     StringMem.WriteString (yyf, a);
# define gettStringRef(a)
# define puttStringRef(a)
# define copytStringRef(a, b)
# define equaltStringRef(a, b)  a = b
(* tIdent *)
# define begintIdent(a)
# define closetIdent(a)
# define readtIdent(a)          a := yyReadIdent ();
# define writetIdent(a)         Idents.WriteIdent (yyf, a);
# define gettIdent(a)           yyGetIdent (a);
# define puttIdent(a)           yyPutIdent (a);
# define copytIdent(a, b)
# define equaltIdent(a, b)      a = b
(* tText *)
# define begintText(a)
# define closetText(a)
# define readtText(a)
# define writetText(a)          Texts.WriteText (yyf, a);
# define gettText(a)
# define puttText(a)
# define copytText(a, b)
# define equaltText(a, b)       FALSE
(* tSet *)
# define begintSet(a)
# define closetSet(a)
# define readtSet(a)            Sets.ReadSet (yyf, a);
# define writetSet(a)           Sets.WriteSet (yyf, a);
# define gettSet(a)
# define puttSet(a)
# define copytSet(a, b)
# define equaltSet(a, b)        Sets.IsEqual (a, b)
(* tRelation *)
# define begintRelation(a)
# define closetRelation(a)
# define readtRelation(a)       Relations.ReadRelation (yyf, a);
# define writetRelation(a)      Relations.WriteRelation (yyf, a);
# define gettRelation(a)
# define puttRelation(a)
# define copytRelation(a, b)
# define equaltRelation(a, b)   Relations.IsEqual (a, b)
(* tPosition *)
# define begintPosition(a)
# define closetPosition(a)
# define readtPosition(a)
# define writetPosition(a)      Positions.WritePosition (yyf, a);
# define gettPosition(a)
# define puttPosition(a)
# define copytPosition(a, b)
# define equaltPosition(a, b)   Positions.Compare (a, b) = 0
.FR
.fi
.sz 12
.bp 1
.b Contents
.xp

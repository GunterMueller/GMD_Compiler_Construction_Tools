.\" use: pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.if t \{ \
.pl 29.7c	\" page length
.po 2.5c	\" page offset (left margin)
.ll 16.5c	\" line length
.lt 16.5c	\" title length
.nr LL 16.5c
.nr )l 29.7c
.nr hm 2c
.nr $r 9	\" factor for vertical spacing
.nr $R \n($r
.sz 12		\" font size
.nr pp 12
.nr sp 12
.nr tp 12
.nr fp 10
.hc ~		\" hyphenation character
.		\" Umlauts and sharp s
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s sz
.\}
.de _
\&\\$1\l'|0\(ul'\\$2
..
.de FT		\" font for programs
.ft C
.sz -2
..
.de FR
.ft R
.sz +2
..
.de []		\" start to display collected references
.uh References
.lp
..
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.de np
.nr $p +1
.ip \\n($p.
..
.de SH
.sp 0.5
.in -3
.r \\$1
.sp 0.5
.in +3
..
.de PP
.sp 0.5
..
.de IP
.ip \\$1 \\$2
..
.de I
.i \\$1
..
.de TH
..
.de SH
.sp 0.5
.in -3
.r \\$1
.sp 0.5
.in +3
..
.de I
.i \\$1
..
.EQ
delim off
.EN
.ds ], , 
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.1c'
.nf

	Puma - A Generator
	for the Transformation
	of Attributed Trees

	J. Grosch


\l'17.1c'
.sp 12.5c
\l'17.1c'
.ft H
.nf
	GESELLSCHAFT F\*UR MATHEMATIK
	UND DATENVERARBEITUNG MBH

	FORSCHUNGSSTELLE F\*UR
	PROGRAMMSTRUKTUREN
	AN DER UNIVERSIT\*AT KARLSRUHE
.r
\l'17.1c'
.bp
.oh ''Puma'%'
.eh ''Puma'%'
.ce 99
.sz 20
.b " "
.sp 2
Project
.sp
.b "Compiler Generation"
.sp
.sz 12
\l'15c'
.sp
.sz 16
.b "Puma - A Generator for the Transformation of Attributed Trees"
.sp 2
Josef Grosch
.sp 2
.sz 14
Nov. 22, 1991
.sp
.sz 12
\l'15c'
.sp 2
Report No. 26
.sp 2
Copyright \(co 1991 GMD
.sp 2
Gesellschaft f\*ur Mathematik und Datenverarbeitung mbH
Forschungsstelle an der Universit\*at Karlsruhe
Vincenz-Prie\*snitz-Str. 1
D-7500 Karlsruhe
.ce 0
.fi
.bp 1
.ce 99
.b "Puma - A Generator for the Transformation of Attributed Trees"
.\" .sp 2
.\" Josef Grosch
.\" GMD Forschungsstelle an der Universit\*at Karlsruhe
.\" Vincenz-Prie\*snitz-Str. 1, D-7500 Karlsruhe, Germany
.\" grosch@karlsruhe.gmd.de
.ce 0
.sh 1 Introduction
.lp
.i Puma
is a tool supporting the transformation and manipulation of attributed
trees. It is based on pattern-matching, unification, and recursion.
.i Puma
cooperates with the generator for abstract syntax trees
.i ast
\*([[Gro91\*(]],
which already supports the definition, creation, and storage of
attributed trees.
.i Puma
adds a concise notation for the analysis and synthesis of trees. The
pattern-matching capability facilitates the specification of decision
tables.
.i Puma
provides the implicit declaration of variables, strong type
checking with respect to trees, and checks the single assignment
restriction for variables. The output is the source code of a program
module written in one of the target languages C or Modula-2. This
module implements the specified transformation routines. It can be
integrated easily with arbitrary program code. The generated routines
are optimized with respect to common subexpression elimination and tail
recursion.
.pp
The intended use of this tool proceeds in three steps:
First, a tree is constructed either by a parser, a previous transformation phase, or whatever
is appropriate.
Second, the attributes in the tree are evaluated either using an attribute grammar based
tool, by a
.i puma
specified tree traversal and attribute computations, or by hand-written code.
Third, the attributed tree is transformed or mapped to another data structure by a
.i puma
generated transformation module.
These steps can be executed one after the other or more or less simultaneously.
Besides trees,
.i puma
can handle attributed graphs as well, even cyclic ones. Of course the cycles have to be
detected in order to avoid infinite loops. A possible solution uses attributes as marks for
nodes already visited.
.pp
A transformer module can make use of attributes in the following ways:
If attribute values have been computed by a preceding attribute evaluator and are accessed
in read only mode then this corresponds to the three step model explained above. A
.i puma
generated module can also evaluate attributes on its own. A further possibility is that an
attribute evaluator can call
.i puma
subroutines in order to compute attributes. This is especially of interest when attributes
depend on tree-valued arguments.
.pp
The tool supports two classes of tree transformations:
.i mappings
and
.i modifications .
Tree mappings map an input tree to arbitrary output data.
The input tree is accessed in read only mode and left unchanged. Tree
.i modifications
change a tree by e. g. computing and storing
attributes at tree nodes or by changing the tree structure. In this
case the tree data structure serves as input as well as output and it
is accessed in read and write mode.
.pp
The first class covers applications like the generation of
intermediate languages or machine code. Trees are mapped to arbitrary
output like source code, assembly code, binary machine code,
linearized intermediate languages like P-Code, or another tree
structure. A further variant of mapping is to emit a sequence of
procedure calls which are handled by an abstract data type.
.pp
The second class covers applications like semantic analysis or
optimization. Trees are decorated with attribute values, properties of
the trees corresponding to context conditions are checked, or trees
are changed in order to reflect optimizing transformations.
.pp
The contents of this manual is organized as follows:
Section 2 gives an overview and describes the cooperation of
.i puma
and
.i ast .
Section 3 describes the specification language of
.i puma .
Section 4 describes the output of
.i puma .
.\" Section 5 compares
.\" .i puma
.\" with similar tools.
Section 5 contains the UNIX manual page.
Appendix 1 contains the syntax summary.
Appendix 2 presents an example from a compiler for MiniLAX.
Appendix 3 lists the type specific equality operations for the target
languages C and Modula-2.
.sh 1 Overview
.(z
.PS
scale	= 2.54
boxwid	= 2.0
boxht	= 1.2
circlerad = 0.8
lineht	= 1.2

	down
	box "Tree" "Spec"
	arrow
AST:	circle "ast"
	arrow right boxwid at AST.e
	box "Tree.TS"
	arrow right boxwid
PUMA:	circle "puma"
	line <- at PUMA.n up
	box "Trafo" "Spec"

	down
TREH:	box "Tree.h" at AST + (- circlerad - boxwid/2, - 3.0)
ARR:	arrow
TREC:	box "Tree.c" at last box + (circlerad * 2 + boxwid, 0)
	arrow
TRAH:	box "Trafo.h" at last box + (boxwid + boxwid, 0)
	arrow
TRAC:	box "Trafo.c" at last box + (circlerad * 2 + boxwid, 0)
	arrow
	line to ARR.s
	arrow from center of last line
	circle "compile" "+ link"
	arrow
	box "executable" "program"

	arrow from AST.sw to TREH.n
	arrow from AST.se to TREC.n
	arrow from PUMA.sw to TRAH.n
	arrow from PUMA.se to TRAC.n
	move to TREH.w + (-1.7, 0)
.PE
.sp
.ce
Fig. 1: Cooperation of \fIpuma\fP and \fPast\fP
.)z
.lp
The input of a transformer is a tree which might be decorated with
attributes. The structure of the legal input trees and the desired
transformation are described in two separate documents. Both documents
are processed by the separate tools
.i ast
and
.i puma .
The cooperation between those tools is depicted in Figure 1.
The structure of the trees including their attributes is described by a
tree grammar and is fed into
.i ast .
.i Ast
produces the source code of a module that defines, stores, and
manipulates the specified tree and an internal description of the tree
in the file
.i Tree.TS .
This file and the description of the intended transformation are the
input of
.i puma .
.i Puma
generates a module that implements the specified transformation
by a set of subprograms which use the tree module produced by
.i ast .
The two generated modules, which are named
.i Tree
and
.i Trafo
by default, consist of two files: The header, interface, or definition
part and the implementation part. Both modules must be compiled and
linked, eventually with other modules, to yield an executable program.
.pp
For the following we assume the reader to be familiar with the tool
.i ast .
.i Ast 's
input language is used to define the node types, the subtype relation
between the node types, and the children and attributes of the node
types including their data types. This input language is described in the
.i ast
user manual\*([<\*([[Gro91\*(]]\*(>].
.sh 1 "Input Language"
.lp
The following sections define the syntax and the semantics of a
.i puma
specification. Appendix 1 contains a summary of the precise syntax of
the input language in BNF notation.
.sh 2 Notation
.lp
An EBNF notation is used in the following to describe the syntax of a
.i puma
specification. The meaning of the meta symbols is as follows:
.(b
.ta 4c
=	introduces the right-hand side of a grammar rule
|	introduces alternatives (usually used to separate alternatives)
[ ]	square brackets enclose optional parts
{ }	curly brackets denote repetition zero, one, or more times
non alpha-numeric characters
	terminal symbol
\&' character '	terminal symbol
all upper-case word	terminal symbol
other word	nonterminal symbol
.)b
.sh 2 "Lexical Conventions"
.lp
The input of
.i puma
consists of identifiers, numbers, keywords, operators, delimiters,
comments, white space, and so called target code.
.pp
Identifiers are sequences of letters, digits, and underscore characters _
that start with a letter or an underscore character _.
The case of the letters is significant:
.\" In case of collisions with keywords, identifiers can be escaped by a
.\" preceding backslash character \\.
.(b
.FT
x   NoName   k2   mouse_button
.)b
.lp
Numbers comprise integers and reals in decimal notation.
They are written as in the target language:
.(b
.FT
0   007   1991   31.4E-1
.)b
.lp
The following words are reserved as keywords and may not be used as identifiers:
.(b
.FT
AND           BEGIN         CLOSE         DIV           EXPORT
EXTERN        FAIL          FUNCTION      GLOBAL        IMPORT
IN            LOCAL         MOD           NIL           NL
NOT           OR            PREDICATE     PROCEDURE     PUBLIC
REF           REJECT        RETURN        TRAFO         TREE
.)b
.lp
Operators are either symbols from the following list or sequences of
characters introduced by a backslash \\ and terminated by white space.
Escaped operators are used for operators not known to
.i puma .
They are written to the output with the backslash \\ removed.
.(b
.FT
!      !=     #      %      &      &&     *      +      ++     -      --
->     .      /      <      <<     <=     <>     =      ==     >      >=
>>     ^      |      ||     AND    DIV    IN     MOD    NOT    OR
.)b
.(b
Examples of escaped operators:
.sp 0.5
.FT
\\\\,    \\\\?    \\\\:    \\\\(void)    \\\\(int*)    \\\\(struct \\\\node)
.)b
.lp
The following characters are delimiters:
.(b
.FT
(   )   ,   .   ..   ...   :   :=   :-   ;   =>   ?   [   ]   _   {   }
.)b
.lp
The delimiters \fC\s-2..\s+2\fP and \fC\s-2...\s+2\fP can be used alternatively, as can be
? and :-. Comments are characters enclosed in /* and */ as in C. They may not be nested:
.(b
.FT
/* comment */
.)b
.lp
Target code are declarations, statements, or expressions written in the
target language and enclosed in curly brackets { }.
Target code may contain curly brackets { } as long as these are either
properly nested or contained in strings or in character constants.
Unnested curly brackets outside of strings or character constants have to be
escaped by a backslash character \\. In general all characters outside of strings
or character constants may be escaped by a backslash character \\.
This escape mechanism is not necessary in strings and character constants.
Target code is usually copied unchecked and unchanged to the output.
.(b
.FT
{ x = 1; }
{ { char c = '}'; } }
{ printf ("}\\\\n"); }
.)b
.lp
White space characters like blanks, tab characters, form feeds, and return
characters are ignored.
.sh 2 Structure
.lp
The input of
.i puma
consists of a header, target code sections, and a list of subroutines.
.(b
Syntax:
.sp 0.5
.FT
Input  = [ TRAFO Ident ] [ TREE Idents ] [ PUBLIC Idents ] [ EXTERN Idents ]
         { TargetCodes } { Subroutine }
.sp 0.5
Idents = Ident { , Ident }
.)b
.pp
The identifier behind the keyword TRAFO determines the name of the
generated module. The default name is
.i Trafo .
.pp
The identifiers behind the keyword TREE refer to the tree modules to be
manipulated. A
.i puma
module can not only handle one tree definition but an arbitrary number.
There must be a tree grammar for every tree and they all must have been
converted to their internal format with
.i ast .
More precisely, those names refer to so-called
.i views
of a tree definition. Roughly speaking, a view selects a subset of a tree definition.
See the documentaion of
.i ast
for a description of this concept.
If the keyword TREE is missing then the following serves as default:
.(b
.FT
TREE Tree
.)b
Therefore an empty list of tree definitions has to be given as:
.(b
.FT
TREE
.)b
.pp
The identifiers behind the keyword PUBLIC specify those subroutines
that should become visible from outside the module. External
declarations for these subroutines are inserted automatically
in the interface part of the generated module.
.pp
The identifiers behind the keyword EXTERN specify those identifiers
of global, local, or external variables and subroutines that are used
in some subroutines but that are not declared from the point of view of
.i puma .
They may be used in expressions and statements that are checked by the tool
without causing a message.
.(b
Example:
.sp 0.5
.FT
TRAFO ICode TREE Tree Definitions PUBLIC Code
EXTERN ADD CHK ENT Emit
.)b
.sh 2 "Target Code"
.lp
A
.i puma
specification may contain several sections containing
.i "target code" .
Target code is code written in the target language. It is copied
unchecked and unchanged to certain places in the generated module.
.(b
Syntax:
.sp 0.5
.FT
TargetCodes =
| EXPORT TargetCode
.\" | IMPORT TargetCode
| GLOBAL TargetCode
| BEGIN  TargetCode
| CLOSE  TargetCode
.)b
.lp
The meaning of the different sections is as follows:
.ip EXPORT: 3c
declarations to be included in the interface part.
.\" .ip IMPORT: 3c
.\" the same as EXPORT.
.ip GLOBAL: 3c
declarations to be included in the implementation part at global level.
.\" .ip LOCAL: 3c same as GLOBAL within .i ast .
.ip BEGIN: 3c
statements to initialize the declared data structures.
.ip CLOSE: 3c
statements to finalize the declared data structures.
.lp
.(b
Example in C:
.sp 0.5
.FT
EXPORT { typedef int MyType; extern MyType Sum; }
GLOBAL {# include "Idents.h"
         MyType Sum; }
BEGIN  { Sum = 0; }
CLOSE  { printf ("%d", Sum); }
.)b
.(b
Example in Modula-2:
.sp 0.5
.FT
EXPORT { TYPE MyType = INTEGER; VAR Sum: MyType; }
GLOBAL { FROM Idents IMPORT tIdent; }
BEGIN  { Sum := 0; }
CLOSE  { WriteI (Sum, 0); }
.)b
.sh 2 Subroutines
.lp
A set of subroutines constitutes the main building blocks of a transformation.
Like in programming languages, subroutines are parameterized
abstractions of statements or expressions.
There are three kinds of subroutines:
.(b
.ta 2c
procedure	: a subroutine acting as a statement
function	: a subroutine acting as an expression and returning a value
predicate	: a boolean function
.)b
.(b
Syntax:
.sp 0.5
.FT
Subroutine = Header [ EXTERN Idents ; ] [ LOCAL TargetCode ] { Rule }
.sp 0.5
Header     =
| PROCEDURE Ident ( [ Parameters ] [ => Parameters ] )
| FUNCTION  Ident ( [ Parameters ] [ => Parameters ] ) Type
| PREDICATE Ident ( [ Parameters ] [ => Parameters ] )
.sp 0.5
Parameters = [ REF ] [ Ident : ] Type { , [ REF ] [ Ident : ] Type }
.)b
.lp
A subroutine consists of a header, an optional target code section, and
a sequence of rules.
The header specifies the kind of the subroutine, its name, and its parameters.
In case of a function, the type of the result value is added.
This type is restricted to types legal for function results in the target language
(usually simple types and pointers).
Input and output parameters are separated by the symbol =>.
It suffices to give the type of a parameter. A name for the formal
parameter is optional. Usually input parameters are passed by value and
output parameters are passed by reference. The keyword REF can be used to
pass input parameters by reference, too. This might be necessary in case of tree
modifications when an input tree is replaced by a newly created one.
The identifiers behind the keyword EXTERN specify those identifiers
of global, local, or external variables and subroutines that are used within
the subroutine but that are not declared from the point of view of
.i puma .
They may be used in expressions and statements that are checked by the tool
without causing a message.
The target code section is copied in front of the
body of the generated subprogram and may e. g. contain local declarations.
.(b
Examples:
.sp 0.5
.FT
PROCEDURE Code (t: Tree) LOCAL { tObjects object; } ...
PREDICATE IsCompatible (Type, Type) ...
FUNCTION  ResultType (Type, Type, int) Type ...
PROCEDURE ResultType (Type, Type, int => Type) ...
.)b
.sh 2 Types
.lp
Types are either predefined in the target language like \fIint\fP and \fIINTEGER\fP,
or user-defined like \fIMyType\fP, or they are tree types like \fIExpr\fP.
A tree type is described by the name of a tree
definition, a single node type, or a list of node types enclosed in
brackets [ ]. In case of ambiguities the latter two kinds may be
qualified by preceding the name of the tree definition. In every case
a tree-type defines a set of legal node types. The name of a tree
definition refers to every node type that is defined there. A single
node type yields a set with just this one element and a list of node
types yields the union of all list elements.
.(b
Syntax:
.sp 0.5
.FT
Type     =
| TreeType
| UserType
.sp 0.5
TreeType =
| Ident
| [ Ident . ] Ident
| [ Ident . ] '[' Idents ']'
.sp 0.5
UserType = Ident
.)b
.(b
Examples:
.sp 0.5
.FT
int                       /* predefined type             */
MyType                    /* user defined type           */
Tree                      /* tree type                   */
Expr                      /* node type                   */
Tree.Expr                 /* qualified node type         */
[Stats, Expr]             /* set of node types           */
Tree.[Stats, Expr]        /* qualified set of node types */
.)b
.sh 2 Rules
.lp
A rule behaves like a branch in a case or switch statement. It consists
of a list of patterns (nonterminal Patterns), a list of expressions, a return expression in
case of a function, and a list of statements. Several neighbouring rules with the same
list of expressions, return expression, and list of statements may share those parts.
A list of a list of patterns (nonterminal PatternList) is equivalent to a sequence of rules
having the sublists as patterns and sharing the other parts.
Patterns and expressions may be either positional or named. The named entities have to
follow the positional ones. For every position of a pattern or an expression at most one
entity may be given. The named elements are transformed into their positional form before
type checking is performed. The parts of a rule
may be given in almost any order as described by the exact syntax in Appendix 1.
.pp
The number of patterns must agree with the number of input parameters,
and the types of the elements of those lists must be pairwise compatible.
The number of expressions must agree with the number of output parameters,
and the types of the elements of those lists must be pairwise compatible.
The type of the expression after RETURN has to be compatible with the
result type of a function.
The type s of a pattern or an expression is said to be compatible
to the type t of a formal parameter if s is a subtype of t (s \(ib t).
.(b
Syntax:
.sp 0.5
.FT
Rule        = [ PatternList ] [ => Exprs ] [ RETURN Expr ] ? { Statement ; } .
.sp 0.5
PatternList = Patterns { ; Patterns }
.sp 0.5
Patterns    =
| Pattern { , Pattern } { , Ident := Pattern }
| Ident := Pattern      { , Ident := Pattern }
.sp 0.5
Exprs       =
| Expr { , Expr } { , Ident := Expr }
| Ident := Expr   { , Ident := Expr }
.)b
.pp
The semantics of a rule is as follows:
A rule may succeed or fail.
It succeeds if all its patterns, statements, and expressions succeed -
otherwise it fails. The patterns, statements, and expressions are
checked for success in the following order:
First, the patterns are checked from left to right. A pattern succeeds
if it matches its corresponding input parameter as described below.
Second, the statements are executed in sequence as long as they succeed.
The success of statements is defined below.
Third, the expressions are evaluated from left to right and
their results are passed to the corresponding output parameters.
In case of a function, additionally the expression after RETURN is
evaluated and its result is returned as value of the function call.
The success of expressions is defined below, too.
If all elements of a rule succeed then the rule succeeds and
the subroutine returns.
If one element of a rule fails the process described above stops and
causes the rule to fail. Then the next rule is tried.
This search process continues until either a successful rule is found
or the end of the list is reached. In the latter case the behaviour
depends on the kind of the subroutine:
.(b
A procedure signals a runtime error if option 'f' is set, otherwise it does nothing.
A predicate returns false.
A function signals a runtime error.
.)b
There is one exception to this definition of the semantics which is explained later.
Note, if a predicate fails then the values of its output parameters are undefined.
.(b
Examples:
.sp 0.5
.FT
PROCEDURE Code (t: Tree)
   Plus  (Lop, Rop) ? Code (Lop); Code (Rop); Emit (ADD); .
   Minus (Lop, Rop) ? Code (Lop); Code (Rop); Emit (SUB); .
   ...

PREDICATE IsCompatible (Type, Type)
   Integer      , Integer       ?.
   Real         , Real          ?.
   Boolean      , Boolean       ?.
   Array (t1, Lwb, Upb, _), Array (t2, Lwb, Upb, _) ? IsCompatible (t1, t2); .

FUNCTION ResultType (Type, Type, int) Type
   Integer      , Integer       , { Plus }      RETURN Integer  ?.
   Real         , Real          , { Plus }      RETURN Real     ?.
   Integer      , Integer       , { Times }     RETURN Integer  ?.
   Real         , Real          , { Times }     RETURN Real     ?.
   Integer      , Integer       , { Less }      RETURN Boolean  ?.
   Real         , Real          , { Less }      RETURN Boolean  ?.
.)b
.sh 2 Patterns
.lp
A pattern describes the shape at the top or root of a subtree.
A pattern can be a decomposition of a tree, the keyword NIL,
a label or a variable, one of the don't care symbols _ or \fC\s-2..\s+2\fP,
or an expression. A decomposition is written as
a node type followed by a list of patterns in parenthesis ( and ).
Optionally, the node type may be qualified by a tree name and preceded by a label.
.(b
Syntax:
.sp 0.5
.FT
Pattern =
| [ Label ] [ Ident . ] Ident [ ( [ Patterns ] ) ]
| [ Label ] NIL
| Ident
| _
| ..
| Expr
.sp 0.5
Label   =
| Ident :
| Ident :>
.)b
.lp
The match between a pattern and a value is defined recursively depending
on the kind of the pattern:
.ip -
A decomposition with a node type t matches a tree u with a root node of type s if s is a
subtype of t (s \(ib t) and all subpatterns of t match their
corresponding subtrees or attributes of u.
If the node type is preceded by a label l then a binding is
established between l and u which defines the label l to refer to the tree u.
If the label l is followed by a colon : then l has the type of u.
If the label l is followed by the symbol :> then l has the type that is legal at this
location. This is either the type of a parameter or the type of a node type's child.
.ip -
The pattern NIL matches the values NoTree or NIL.
If NIL is preceded by a label l then a binding is
established between l and the parameter or child matching NIL.
l has the type that is legal at this location.
This is either the type of a parameter or the type of a node type's child.
.ip -
The first occurrence of a label l in a rule matches an arbitrary subtree
or attribute value u.
A binding is established between l and u which defines the label l to refer to the value u.
The label can be used later to access the associated value.
All further occurrences of the label l within patterns of this rule
match a subtree or an attribute value v only if u is equal to v.
The equality for trees is defined in the sense of structural equivalence.
Two attributes are equal if they have the same values.
This so-called non-linear pattern matching has to be enabled by an option.
Without this option all further occurrences of a label l are treated as error.
.ip -
The don't care symbol _ matches one arbitrary subtree or attribute
value.
.ip -
The don't care symbol \fC\s-2..\s+2\fP matches any number of arbitrary subtrees or attribute values.
.ip -
An expression matches a parameter or an attribute if both have the same value.
The equality of values is defined as a type specific operation (see section 3.11.).
.lp
The ambiguity between a node type without a list of patterns in
parentheses and a label is resolved in favor of the node type, by
default. A node type t without a list of subpatterns is treated as t (\fC\s-2..\s+2\fP).
.i Puma
has an option that disables this behaviour. Then all node types require
parentheses, otherwise they are considered as labels.
.(b
Examples:
.sp 0.5
.FT
Binary                         /* a node type */
Tree.Binary
Binary (Lop, Rop, Operator)
a:Binary (_, b:>Binary (Lop, ..), Operator)
                               /* a, b, Lop, and Operator are labels */
                               /* a is of type Binary */
                               /* b is of type Expr   */
NIL
X                              /* a label */
k + 2
{ Times }                      /* a named constant */
.)b
.sh 2 Expressions
.lp
Expressions denote the computation of values or the construction of trees.
Binary and unary operations as well as calls of external functions
are written as in the target language. Calls of
.i puma
functions and predicates distinguish between input and output arguments.
Named arguments are not allowed in calls.
The syntax for tree composition is similar to the syntax of patterns.
Again, the node type may be qualified by a tree name.
.(b
Syntax:
.sp 0.5
.FT
Expr =
| [ Ident . ] Ident [ ( [ Exprs ] ) ]
| NIL
| Ident
| _
| ..
| Expr ( [ Exprs ] [ => Patterns ] )
| Expr Operator Expr
| Operator Expr
| Expr Operator
| Expr [ Exprs ]
| ( Expr )
| Number
| String
| TargetCode
| Ident :: Ident
.)b
.lp
The semantics of the different kinds of expressions is as follows:
.ip -
A node type creates a tree node and provides the children and attributes
of this node with the values given in parenthesis.
Again a missing list in parentheses is treated as (\fC\s-2..\s+2\fP).
.ip -
NIL represents the value NoTree or NIL.
.ip -
A label refers to the expression it was bound to upon its definition.
.ip -
A function or predicate call must be compatible with the corresponding definition in
terms of the numbers of expressions and patterns as well as their types.
A function call evaluates the expressions corresponding to input
parameters, passes the results to the function, and executes the
function. Upon return from the function the result value of the
function determines the result of this expression.
The values of the output parameters that the function returns are
matched against the actual patterns of the function call.
If one pair does not match the call fails.
Labels in the patterns may establish bindings that enable to refer to
the output parameters or subtrees thereof.
.ip -
The don't care symbols specify that no computation should be executed,
either for one or for several expressions. The result values are
undefined.
.ip -
The most common binary and unary operators (prefix and postfix) of the
target language as well as array indexing and parentheses are known to
.i puma .
They are passed unchanged to the output.
.ip -
A target code expression, a number, or a string is evaluated as in the target language.
.ip -
The construct Ident :: Ident can be used to refer to children or attributes that are
not matched by a label. This can be of interest because of notational brevity or
because matching is impossible. The reason for the latter case can arise when a subset
of a tree definition is presented to
.i puma
using the concept of views. The first identifier is a label that is bound to a tree (node).
The second identifier is the name of a child or of an attribute of this node type.
.lp
In case of node types, labels for tree values, and functions returning tree values,
.i puma
does type checking. For user types, target code
expressions or target operators no type checking is done by
.i puma
but (hopefully) later by the compiler. An expression that does not contain calls of
.i puma
functions or predicates always succeeds. An expression containing those calls
succeeds if all the calls succeed \(\- otherwise it fails.
.(b
Examples:
.sp 0.5
.FT
Binary                      /* a node composition */
Tree.Binary                 /* a node composition */
Binary (X, Y, Z)            /* a node composition */
NIL
X
ResultType (t1, t2)         /* a function call */
_
..
k + 2
- k
k ++
a [x]
({ Times })                 /* a named constant */
3.14
"abc"
.)b
.sh 2 Statements
.lp
Statements are used to describe conditions, to perform output, to assign
values to attributes, and to control the execution of the transformer
via recursive subroutine calls. A statement is either a condition denoted
by an expression, a call of a procedure, an assignment, one of the
keywords REJECT or FAIL, a String or the keyword NL, a target code statement,
or declarations of variables. Named arguments are not allowed in calls.
Every kind of statement may succeed or fail as described below.
.(b
Syntax:
.sp 0.5
.FT
Statement =
| Expr
| Expr ( [ Exprs ] [ => Patterns ] )
| Expr := Expr
| REJECT
| FAIL
| String
| NL
| TargetCode
| Declarations
.sp 0.5
Declarations = Ident : Type { , Ident : Type }
.)b
.pp
There are some syntactic ambiguities:
Target code in curly brackets { }
is considered as target code statement instead of as target code
expression. To obtain the latter meaning the expression should be
enclosed in parentheses ( ).
Subroutine calls are treated according to their declaration:
Predicates and functions are treated as conditions,
procedures and external subroutines are treated as procedure calls.
If external subroutines should be considered as expressions, the call should be
enclosed in parentheses ( ), too.
A string is considered as a special kind of statement instead of as a normal expression.
.ip -
Conditions are denoted by expressions and can be used to determine
properties that can not be expressed with pattern matching alone. Patterns describe
either shapes of a fixed size of a tree or the equality between two
values. Properties of trees of unlimited size and relations like <, <=
etc. have to be checked with conditions.
The expression has to be of type boolean or the call of a predicate.
A condition succeeds if the expression evaluates to true - otherwise
it fails.
.ip -
For a procedure call the same rules as for a function call apply.
It succeeds if the values of all output parameters are matched by the
corresponding patterns - otherwise it fails.
A call of an undefined subroutine is treated as a call of a procedure
that is either defined externally or in the GLOBAL target code
section. Such a call is flagged by a warning message.
.ip -
An assignment statement evaluates its expression and stores this value
at the entity denoted by the identifier on the left-hand side. The
identifier can denote
.(b
a global or a local variable,
an input or an output parameter, or
a label for an attribute or a subtree.
.)b
An assignment statement succeeds if the expression succeeds - otherwise it fails.
.ip -
The statement REJECT does nothing but fail. This way the execution of the
current rule terminates and control is passed to the next rule.
.ip -
The statement FAIL causes the execution of the current subroutine to
terminate. This statement is allowed in procedures and predicates, only.
Depending on the kind of subroutine the following happens:
.(b
A procedure terminates.
A predicate returns false.
.)b
.ip -
A string is an output statement that prints this string.
(For details see section 3.13.).
.ip -
The keyword NL is an output statement that prints a newline character.
(For details see section 3.13.).
.ip -
A target code statement is executed as in the target language. It can be used
for arbitrary actions. In particular it can compute the value of an explicitly
declared label (variable) by means of implementation language code or calls of
external subroutines. A target code statement always succeeds.
.ip -
A declaration explicitly introduces a label or variable. It is similar to
a label in a pattern except that its value is undefined. It can be used also for
the definition of temporary variables. The user is responsible that all labels receive
values either by assignments or by target code statements. Declarations always succeed.
.pp
Note, statements and expressions may cause side effects by changing e. g.
global variables, local variables, the input tree, or by producing output.
Those side effects are not undone when a rule fails.
.(b
Examples:
.sp 0.5
.FT
IsCompatible (t1, t2)        /* condition: predicate call         */
(IsSimpleType (t))           /* condition: external  call         */
X < Y                        /* condition: expression             */
({ X < Y })                  /* condition: target code expression */
Code (Then)                  /* procedure call: internal          */
printf ("hello")             /* procedure call: external          */
X := Y 
{ X = Y; }
REJECT 
FAIL 
"hello"
NL
{ Code (Then); }             /* unchecked internal call           */
{ printf ("hello"); }        /* unchecked external call           */
Z: Expr
{ Z = mBinary (X, Y, Plus); } 
.)b
.sh 2 "Equality Operations"
.lp
The equality between two trees is defined recursively:
Two trees are equal if the node types of the two root nodes are equal
and all corresponding subtrees or attributes are equal.
.pp
The equality between attribute values is type specific.
For every type name a separate equality test is defined.
Chosing different type names for one type introduces subtypes and
allows to treat attributes of different subtypes differently.
The equality tests are defined by a macro mechanism using the
C preprocessor
.i cpp :
.(b
.FT
# define equalTYPE(a, b) a == b
.)b
.lp
TYPE is replaced by the concrete type name.
.i a
and
.i b
are formal macro parameters referring to the attributes to be compared.
.pp
The equality test for the predefined types of a target language
are predefined within
.i puma
(see Appendix 3). For user-defined types,
by default the following equality test is used:
.(b
in C:
.sp 0.5
.FT
# define equalTYPE(a, b) memcmp ((char *) & a, (char *) & b, sizeof (a)) == 0
.FR
.sp 0.5
in Modula-2:
.sp 0.5
.FT
# define equalTYPE(a, b) yyIsEqual (a, b)
.)b
.lp
Above procedures check values of arbitrary types by comparing the byte
sequences.
.pp
It is possible to redefine the operations by including new macro definitions
in the GLOBAL section. The following example demonstrates the syntax for
doing this.
.(b
Example in C:
.sp 0.5
.FT
GLOBAL {
typedef struct { short Line, Column; } tPosition;
# define equaltPosition(a, b) a.Line == b.Line && a.Column == b.Column
}
.)b
.(b
Example in Modula-2:
.sp 0.5
.FT
GLOBAL {
TYPE tPosition = RECORD Line, Column: SHORTCARD; END;
# define equaltPosition(a, b) (a.Line = b.Line) AND (a.Column = b.Column)
}
.)b
.sh 2 "Begin Operations"
.lp
Usually, a composition of a node specifies values for the attributes and children.
Using dont't care symbols it is possible to omit these values.
In this case the attributes and children are initialized by a macro mechanism using the
C preprocessor
.i cpp :
.(b
.FT
# define beginTYPE(a)
.)b
.lp
TYPE is replaced by the concrete type name.
.i a
is the formal macro parameter referring to the attribute or children to be initialized.
.pp
Initialization for attributes is predefined within
.i puma
by empty macros. Children are set to NULL or NIL, by default:
.(b
in C:
.sp 0.5
.FT
# define begintTYPE(a) a = NULL;
.FR
.sp 0.5
in Modula-2:
.sp 0.5
.FT
# define begintTYPE(a) a := NIL;
.)b
.pp
It is possible to redefine the operations by including new macro definitions
in the GLOBAL section. The following example demonstrates the syntax for
doing this.
.(b
Example in C:
.sp 0.5
.FT
GLOBAL {# define equaltint(a) a = 0;}
.)b
.(b
Example in Modula-2:
.sp 0.5
.FT
GLOBAL {# define equaltINTEGER(a) a := 0;}
.)b
.sh 2 "Output Statements"
.lp
The two builtin output statements "string" and NL are translated into macro calls:
.(b
.FT
yyWrite ("string");
yyWriteNl;
.)b
The macros are predefined as follows:
.(b
in C:
.sp 0.5
.FT
# define yyWrite(s) (void) fputs (s, yyf)
# define yyWriteNl  (void) fputc ('\\\\n', yyf)
.sp 0.5
static FILE * yyf = stdout;
.)b
.(b
in Modula-2:
.sp 0.5
.FT
# define yyWrite(s) IO.WriteS (yyf, s)
# define yyWriteNl  IO.WriteNl (yyf)
.sp 0.5
VAR yyf: IO.tFile;
.sp 0.5
yyf := IO.StdOutput;
.)b
By default the statements print on standard output using the library routines
specified in the macro definitions. This behaviour can be changed in two ways:
The global variable yyf can be assigned a new value that describes an arbitrary file.
The macros can be redefined in the GLOBAL target code section.
.sh 1 Scopes
.lp
Scopes are regions of text which control the meaning of identifiers. A
.i puma
specification defines three kinds of scopes which are nested in each
other:
.ip "global scope"
A complete
.i puma
specification defines a global scope.
It contains all declarations included in the GLOBAL target code
section and all subroutine definitions. The subroutines can be defined
in any order.
.ip "local scope"
Every subroutine definition introduces a local scope. It contains the
names of the input and output parameters and the declarations included
in a LOCAL target code section.
.ip "rule scope"
Every rule introduces a rule scope. It contains the labels used in this
rule. Labels are declared upon their first occurrence in patterns.
They are visible only within a rule.
Labels in expressions represent using positions.
Labels have to be declared or bound textually before they are used.
.lp
For entities other then subroutine names and label names the scope
rules of the target language apply.
.sh 1 Output
.lp
From a given specification,
.i puma
generates a program module in one of the target languages C or Modula-2
implementing the desired transformation. The subroutines in the sense
of
.i puma
are mapped to subroutines in the target language. Procedures
yield procedures, functions yield functions that return a value, and
predicates yield boolean functions. These subroutines can be called
from other modules using the usual subroutine call syntax of the target
language provided they are exported: All arguments are separated by commas -
the symbol => as separator between input and output arguments is only
required in calls processed by
.i puma .
.pp
The types of the parameters are treated as follows: Predefined types or
user defined types remain unchanged. Node types or sets of node types
are replaced by the name of the corresponding tree type.
This is a pointer to a union of record types. Input parameters are
passed by value and output parameters are passed by reference (VAR in Modula-2) by
default. Input parameters with the keyword REF are passed by reference, too.
.pp
In addition to the exported subroutines, a
.i puma
generated module exports the subroutines BeginTRAFO and CloseTRAFO,
where TRAFO is replaced by the module name. Both subroutines contain
the target code sections BEGIN and CLOSE. All target code sections and
target code representing expressions or statements are more or
less copied unchecked and unchanged to the generated output module. The
only change is that in target code representing expressions or
statements label identifiers are replaced by access paths to the
associated values.
.pp
The rules of a subroutine are treated like a comfortable case or switch statement.
The code generated for pattern matching is relatively simple.
A naive implementation would just use a sequence of if statements.
This kind of code showed to be already rather efficient.
Possible optimizations are the clever use of switch statements and the elimination of common
subexpressions. Furthermore, tail recursion can be turned into iteration.
Labels are replaced by access paths to the associated values.
The code for the construction of tree nodes is inserted in-line.
It is therefore efficient because
no procedure calls are necessary for the creation of tree nodes.
Moreover, the transformer module independent of the tree module with respect to
the presence of procedures to create nodes and the classification of input attributes.
.if 0 \{\
.sh 1 "Related Research"
.lp
Many tools for the transformation of trees have been proposed and
constructed in the recent years. As mentioned in the introduction even
at GMD there are several and there are many more worldwide. This
section tries to compare the approach of
.i puma
with the most prominent or important tools. The paradigms of
.i puma
are relatively fundamental and therefore it is worth while to have a look at
tools for attribute grammars and programming languages as well.
.pp
We start with a comparison of the transformation tools developed at
GMD. Table 1 summarizes the features of these tools. Entries in
parentheses indicate that the feature is not available explicitly but
it is covered by an other one.
.(z
.ce
Table 1: Comparison of Transformation Tools from GMD
.sp 0.5
.TS
center box;
l | c c c c c c.
Feature          	Tg	Estra	Gentle	Puma	Beg	Twig
_
kinds and # of subroutines:
procedures      	n	n	n	n	1	0
functions        	0	n	0	n	0	1
predicates      	0	(n)	n	n	0	0
_
# of subroutine parameters:
matched input    	1	1	n	n	1	1
unmatched input  	0	n	(n)	(n)	n	0
matched output  	0	0	n	n	0	0
unmatched output	0	n	(n)	(n)	n	0
_
type of matched parameters:
tree-typed      	y	y	y	y	y	y
non tree-typed  	-	-	-	y	-	-
_
tree types:
sets of nonterminals	-	y	-	y	-	-
nonterminals    	-	y	y	y	y	y
all nonterminals	y	-	-	y	-	-
_
pattern syntax:
nested patterns  	-	y	y	y	y	y
composition      	-	-	y	y	-	-
decomposition    	(y)	y	y	y	y	y
subtypes        	-	-	-	y	-	-
NIL/NULL/NoTree        	y	-	-	y	-	-
don't cares      	-	-	-	y	-	-
_
attribute handling:
store attributes	y	y	-	y	-	y
read attributes 	y	y	-	y	y	y
write attributes 	y	-	-	y	-	y
_
conditions:
expressions     	-	(y)	-	y	(y)	(y)
predicate calls  	-	(y)	y	y	-	-
target code     	-	y	-	y	y	y
external calls         	-	(y)	y	(y)	(y)	(y)
_
statements:
procedure calls 	(y)	(y)	y	y	-	-
assignment      	(y)	-	-	y	-	-
target code     	y	y	-	y	y	y
external calls        	(y)	(y)	y	(y)	(y)	(y)
.TE
.)z
.(z
.ce
Table 1 (continued): Comparison of Transformation Tools from GMD
.sp 0.5
.TS
center box;
l | c c c c c c.
Feature          	Tg	Estra	Gentle	Puma	Beg	Twig
_
matching:
direction       	TD	TD/BU	TD	TD	BU	TD
range               	local	global	local	local	global	global
implementation    	direct	direct!	direct	direct	direct	table-
                  	CASE	dyn.	if	if	CASE + dyn. driven
_
miscellaneous:
costs             	-	y	-	-	y	Y
loopholes       	target	target	external	target	target	target
                 	code	code		code	code	code
flexibility         	open	open	closed	open	open	open
security         	low	high	high	mid	high	mid
cooperation dependencies	ast	(ast)	yacc/lalr	ast	-	-
_
target languages:
C               	-	-	y	y	y	y
Modula-2          	y	y	-	y	y	-
_
implementation languages:
C               	-	y	y	y	y	y
Modula-2          	y	y	-	y	y	-
_
efficiency:
run time        	high	mid	mid	mid !	mid	low
storage          	high	low	high	high	high	high
_
recursion:
explicit         	y	y	y	y	-	y
several times       	y	y	y	y	-	(y)
arbitrary order       	y	y	y	y	-	y
arbitrary subroutine   	y	y	y	y	-	-
implicit postorder	-	-	-	-	y	y
.TE
.)z
.sh 2 Tg
.lp
.i Tg
is an internal prototype of a rather primitive transformation tool. It
generates recursive transformation procedures with
one tree-valued parameter. Its pattern-matching is degenerated to a
case statement selecting node-types. The only target language supported
is Modula-2 and the only comfort is that every case branch is
automatically surrounded by a WITH statement. Therefore access to
children and attributes could be expressed in the target language.
In spite of its primitive nature,
.i tg
proved to be a useful tool, which was e. g. profitably used to
implement the generator for abstract syntax trees
.i ast ,
the attribute evaluator generator
.i ag ,
and in the bootstrap of
.i puma .
.sh 2 Estra
.lp
In contrast to
.i tg ,
.i estra
was an attempt to be a very powerful transformation tool. Again an
.i ast
defined tree was the input of the transformer.
.i Estra
has complex patterns, transformation routines with inherited and
synthesized attributes or parameters. It is rule based.
A rule consists of a pattern describing a
tree fragment and an action. Actions are composed of target language statements. It is
possible to specify several transformations. The subtrees of a pattern can be transformed in
any order. They can be transformed several times by the same or by different transformations.
The actions have read access to the attributes of the input tree. Additional synthesized
and inherited attributes may be evaluated during the transformation. The application of rules
can be restricted by conditions. Ambiguities may be resolved using costs.
.pp
Two
implementations of the pattern-matcher can be selected: a directly coded dynamic programming
algorithm or a table-driven tree pattern-matcher. In both cases the transformation has two
phases. While the first one determines the patterns that match with minimal costs the second
one executes the associated actions.
.nf
global match
successfully used for mtc
disadvantages:
   only Modula-2
   high storage consumption
   global match unnecessary in most applications
.fi
.sh 2 Gentle
.lp
.i Gentle
.[waite grosch schroeer.] was developed independently of
.i ast
and the toolbox. It tries to offer an uniform description of a complete
compiler including the tasks of parsing, tree construction, semantic
analysis, and transformation. The notation uses a Prolog like syntax
for the definition of tree structures and their transformation. Parsing
is viewed as a special case of transformation where the concrete
syntax tree is transformed into an abstract one. In contrast to
.i puma ,
it is not possible to store attributes in the tree and only one tree
grammar can be defined.
.i Gentle
does not allow predefined or user-defined types except INT and IDENT.
The latter is used for the internal representation of identifiers. The
subroutines and the pattern-matching are similar to
.i puma
with respect to syntax and semantics.
.i Gentle
only allows procedures and predicates, no functions are
available. Pattern-matching is deterministic without backtracking. The
mode of arguments is classified into input and output. Unification is
restricted to one term being ground term.
.pp
The generated code is very efficient because pattern-matching is
directly coded. Only the target language C is supported. On one hand
.i Gentle
tries to implement the pure theory of horn clauses but on the other
hand there are features for global variables and loopholes that allow
to call external C routines. It is a rather closed system that allows
no direct integration of hand-written code. It is rather inflexible as
it can not be used without the specification of a concrete grammar
which implies that there is always a scanner and a parser.
.i Puma
is independent of scanning and parsing. Therefore any number of
scanners, parsers, tree modules, and transformers can be combined into
one program.
.sh 2 "Code Generator Generators"
.lp
Tools to generate code generators like
.i beg ,
.i cgss ,
and
.i ascot
are a special kind of transformation tools. We compare
.i puma
only to the latest code generator generator developed at GMD, the back
end generator
.i beg .
.i cgss
and
.i ascot
are predecessors of
.i beg
following more or less similar designs.
.pp
.i Beg
focusses on code selection and register allocation.
Code selection is performed using tree pattern matching.
The target instructions are described using rules containing tree patterns.
The resulting code generator accepts a tree oriented intermediate
language. An input tree is translated by covering the tree by the patterns
and afterwards emitting the corresponding instructions.
Rules are annotated with cost values which allows the code 
generator to select a cover of minimal cost, that means the sum
of the costs of all rules in the cover is minimal.
.pp
Therefore the user only describes ambiguously how certain intermediate 
language constructs 
can be translated. He need not to program the algorithm to 
select the best way to translate a specific input tree. 
A good way to develop a code generator description is to first
describe only a subset of the machine's instructions, big enough 
to compile the whole language. This results in a running
compiler, which may produce inefficient code.
Afterwards gradually more and more rules can be added 
which finally leads to a compiler producing good code.
.pp
.i Beg
implements the determination of the minimal cover using a
directly coded version of the dynamic programming algorithm
.[emmelmann schroeer landwehr, emmelmann beg gmd-studie.].
.pp
The generation of register allocators is of specific importance, because
hand crafting is a rather difficult and tedious job and because
errors in the register allocator are sometimes very difficult to find.
Within rules, the characteristics with respect to register allocation
of an instruction can be specified: the allowed registers for 
each operand, the registers changed by side-effects, and 
whether the instruction is a two address instruction or not.
Additionally the register set of the target machine has to be described.
Even the double register problem (e. g. IBM 370) can be handled.
.pp
Two kinds of local register allocators can be requested: the on the fly
register allocator handles simple register sets.
However, it provides satisfying results for many machines and is very efficient.
In some cases the general register allocator is
necessary which performs some kind of look-ahead.
Therefore it requires an extra pass.
.pp
Of course, register allocation is outside the scope of
.i puma .
The code selection process is the transformation or mapping of an
attributed expression tree of the intermediate language into machine
code e. g. in form of assembler code.
.pp
The generated code generator can be seen as one transformation
procedure accepting one expression tree as input. Patterns are complex,
rules have conditions and costs, actions are expressed in the target
language. Pattern-matching is done globally on the complete input tree.
The cover which is cost optimal is selected. The recursion to process
subtrees is controlled implicitly. Subtrees are traversed from right to
left.
.\}
.sh 1 Usage
.pp
.de TH
..
.TH PUMA 1 "" "GMD-Forschungsstelle-Karlsruhe"
.SH NAME
puma - a generator for the transformation of attributed trees
.SH SYNOPSIS
puma [-options] [-l dir] [file]
.SH DESCRIPTION
.I puma
is a tool for the 
transformation of attributed trees which is based on pattern matching and unification.
It generates transformers (named \fITrafo\fP by default) that map
attributed trees to arbitrary output. As this tool also has to know about the structure
of the tree this information is communicated from \fIast\fP to \fIpuma\fP via a file
with the suffix .TS. If
.I file
is omitted the specification is read from standard input.
.SH OPTIONS
.ta 3i
.nf
.IP a
generate all, same as -di (default)
.IP d
generate definition module
.IP i
generate implementation module
.IP s
suppress warnings
.IP m
use procedure MakeTREE to construct nodes (default is in-line code)
.IP p
allow node constructors without parentheses
.IP f
signal a runtime error if none of the rules of a procedure matches
.IP k
allow non-linear patterns
.IP n
check parameters for NoTREE (NIL) and treat as failure (tg compatibility)
.IP w
surround actions by WITH statements (tg compatibility)
.IP e
treat undefined names as error
.IP v
treat undefined names as warning
.IP o
list undefined names on standard output
.IP t
print tree definitions
.IP r
print patterns
.IP q
browse internal data structure
.IP 6
generate # line directives
.IP 7
touch output files only if necessary
.IP 8
report storage consumption
.IP c
generate C code (default is Modula-2)
.IP h
print help information
.IP -l\fRdir
\fIdir\fP is the directory where puma finds its table files
.SH FILES
.nf
.ta 2i
<tree>.TS	description of the tree grammar(s)
.sp 0.5
if output is in C:
.sp 0.5
<module>.h	specification of the generated transformer module
<module>.c	body of the generated transformer module
.sp 0.5
if output is in Modula-2:
.sp 0.5
<module>.md	definition module of the generated transformer module
<module>.mi	implementation module of the generated transformer module
.fi
.SH SEE\ ALSO
.sp 0.5
J. Grosch:
"Puma - A Generator for the Transformation of Attributed Trees",
GMD Forschungsstelle an der Universit\*at Karlsruhe,
Compiler Generation Report No. 26
.sp 0.5
J. Grosch:
"Transformation of Attributed Trees Using Pattern Matching",
GMD Forschungsstelle an der Universit\*at Karlsruhe,
Compiler Generation Report No. 27
.bp
.uh "Appendix 1: Syntax Summary"
.sp
.(l L
.FT
/* parser grammar */

Trafo           = TrafoName TreePart PublicPart ExternPart0 TargetCodes
                     Subroutines .

TrafoName       = <
                = .
                = TRAFO Name .
> .
TreePart        = <
                = .
                = 'TREE' TreeNames .
> .
TreeNames       = <
                = .
                = TreeNames ',' .
                = TreeNames Name .
> .
PublicPart      = <
                = .
                = PUBLIC Names .
> .
ExternPart0     = <
                = .
                = EXTERN Names OptSemiColon .
> .
ExternPart      = <
                = .
                = EXTERN Names ';' .
> .
Names           = <
                = .
                = Names ',' .
                = Names Name .
> .
TargetCodes     = <
                = .
                = TargetCodes 'EXPORT' TargetCode .
                = TargetCodes 'IMPORT' TargetCode .
                = TargetCodes 'GLOBAL' TargetCode .
                = TargetCodes 'BEGIN'  TargetCode .
                = TargetCodes 'CLOSE'  TargetCode .
> .
Subroutines     = <
                = .
                = Subroutines PROCEDURE Name '(' Parameters OutParameters ')'
                     ExternPart LocalCode Rules .
                = Subroutines 'FUNCTION' Name '(' Parameters OutParameters ')'
                     Type ExternPart LocalCode Rules .
                = Subroutines PREDICATE Name '(' Parameters OutParameters ')'
                     ExternPart LocalCode Rules .
> .
OutParameters   = <
                = .
                = '=>' Parameters .
> .
Parameters      = <
                = .
                = Mode Ident ':' Type .
                = Mode Type .
                = Mode Ident ':' Type ',' Parameters .
                = Mode Type ',' Parameters .
> .
Mode            = <
                = .
                = REF .
> .
Declarations    = <
                = Ident ':' Type .
                = Ident ':' Type ',' Declarations .
> .
Type            = <
                = Ident .
                = Ident '.' Name .
                = '[' Names ']' .
                = Ident '.' '[' Names ']' .
> .
LocalCode       = <
                = .
                = 'LOCAL' TargetCode .
> .
Rules           = <
                = .
                = Rules Patterns2 '.' .
                = Rules Patterns '?' Statements '.' .
                = Rules Patterns '=>' Exprs2 '.' .
                = Rules Patterns RETURN Expr ';' '.' .
                = Rules Patterns '=>' Exprs '?' Statements '.' .
                = Rules Patterns '?' Statements '=>' Exprs2 '.' .
                = Rules Patterns '=>' Exprs RETURN Expr ';' '.' .
                = Rules Patterns RETURN Expr OptSemiColon '?' Statements '.' .
                = Rules Patterns '?' Statements RETURN Expr ';' '.' .
                = Rules Patterns '=>' Exprs RETURN Expr OptSemiColon '?'
                     Statements '.' .
                = Rules Patterns '=>' Exprs '?' Statements RETURN Expr ';' '.' .
                = Rules Patterns '?' Statements '=>' Exprs RETURN Expr ';' '.' .
> .
OptSemiColon    = <
                = .
                = ';' .
> .
Patterns        = <
                = Exprs .
                = Exprs ';' Patterns .
> .
Patterns2       = <
                = Exprs ';' .
                = Exprs ';' Patterns2 .
> .
Exprs           = <
                = '..' .
                = '..' ',' .
                = Expr .
                = Expr ',' Exprs .
                = NamedExprs .
> .
NamedExprs      = <
                = .
                = Ident ':=' Expr .
                = Ident ':=' Expr ',' NamedExprs .
> .
Exprs2          = <
                = '..' .
                = '..' ',' .
                = Expr ',' Exprs2 .
                = NamedExprs2 .
> .
NamedExprs2     = <
                = .
                = Ident ':=' Expr ',' NamedExprs2 .
> .
Expr            = <
                = PrefixExpr .
                = Expr Operator PrefixExpr .
> .
PrefixExpr      = <
                = PostfixExpr .
                = Ident ':' PostfixExpr .
                = Ident ':>' PostfixExpr .
                = Operator PrefixExpr .
                = IncOperator PrefixExpr .
> .
PostfixExpr     = <
                = PrimaryExpr .
                = PostfixExpr '[' Exprs ']' .
                = PostfixExpr '(' Exprs ')' .
                = PostfixExpr '(' Exprs '=>' Exprs ')' .
                = PostfixExpr '.' Ident .
                = PostfixExpr '->' Ident .
                = PostfixExpr '^' .
                = PostfixExpr IncOperator .
> .
PrimaryExpr     = <
                = Ident .
                = NIL .
                = '_' .
                = Number .
                = String .
                = Ident '::' Ident .
                = '{' TargetCodes2 '}' .
                = '(' Expr ')' .
> .
Statements      = <
                = .
                = Statements Expr ';' .
                = Statements Expr ':=' Expr ';' .
                = Statements REJECT .
                = Statements FAIL .
                = Statements NL .
                = Statements Declarations ';' .
                = Statements '{' TargetCodes2 '}' ';' .
                = Statements ';' .
> .
TargetCodes2    = <
                = .
                = TargetCodes2 Name Space '::' Space Ident .
                = TargetCodes2 Name Space '::' Space .
                = TargetCodes2 Name Space .
                = TargetCodes2 '::' .
                = TargetCodes2 TargetCode2 .
                = TargetCodes2 WhiteSpace .
> .
Name            = <
                = Ident .
                = String .
> .
Space           = <
                = .
                = Space WhiteSpace .
> .

/* lexical grammar */

Ident           : <
                = Letter .
                = `_` .
                = Ident Letter .
                = Ident Digit .
                = Ident '_' .
> .
Number          : <
                = Integer .
                = Real .
> .
Integer         : <
                = Digit .
                = Integer Digit .
> .
Real            : <
                = Integer '.' Integer Exponent .
                = Integer '.' Exponent .
                = '.' Integer Exponent .
> .
Exponent        : <
                = .
                = `E` `+` Integer .
                = `E` `-` Integer .
                = `E` Integer .
> .
String          : <
                = "'" Characters "'" .
                = '"' Characters '"' .
> .
TargetCode      : '{' Characters '}' .

TargetCode2     : Characters .

WhiteSpace      : <
                = ' ' .
                = Tabulator .
                = Newline .
> .

Operator        : <
                = '!' .
                = '!=' .
                = '#' .
                = '%' .
                = '&' .
                = '&&' .
                = '*' .
                = '+' .
                = '-' .
                = '/' .
                = '<' .
                = '<<' .
                = '<=' .
                = '<>' .
                = '=' .
                = '==' .
                = '>' .
                = '>=' .
                = '>>' .
                = '|' .
                = '||' .
                = '~' .
                = AND .
                = DIV .
                = IN .
                = MOD .
                = NOT .
                = OR .
                = '\\' Characters WhiteSpace .
> .
IncOperator     : <
                = '++' .
                = '--' .
> .

Comment         : '/*' Characters '*/' .

Characters      : <
                = .
                = Characters Character .
> .

/* replacements */

\&'..'            : < = '...' .  > .
\&'?'             : < = ':-'  .  > .
.)l
.bp
.uh "Appendix 2: Examples from MiniLAX"
.lp
The following examples are taken from a compiler for the demo language
MiniLAX. The complete MiniLAX example can be found in\*([<\*([[Gro90\*(]]\*(>]:
.pp
The first part contains the abstract syntax of the language and the
output attributes which are assumed to be computed by a preceding
semantic analysis phase. This information describes the structure of
the input to a
.i puma
generated transformer. It is written in the input language of
.i ast .
.pp
The second part specifies the generation of intermediate code. The
abstract syntax tree is mapped to I-Code which is a subset of P-Code.
.pp
The third part specifies routines to handle types. Types are
internally represented by trees. The routines are used by the semantic
analysis phase which is implemented by an attribute grammar.
.uh "Appendix 2.1: Abstract Syntax"
.sp
.nf
.FT
MODULE AbstractSyntax /* ------------------------------------------ */

TREE EXPORT  {
# include "Idents.h"
# include "Positions.h"
}

GLOBAL  {
# include "Idents.h"
# include "Positions.h"
# include <stdio.h>
}

EVAL Semantics

PROPERTY INPUT

RULE

MiniLAX         = Proc .
Decls           = <
   NoDecl       = .
   Decl         = Next: Decls REV [Ident: tIdent] [Pos: tPosition] <
      Var       = Type .
      Proc      = Formals Decls Stats .
   >.
>.
Formals         = <
   NoFormal     = .
   Formal       = Next: Formals REV [Ident: tIdent] [Pos: tPosition] Type .
>.
Type            = <
   Integer      = .
   Real         = .
   Boolean      = .
   Array        = Type OUT            [Lwb] [Upb] [Pos: tPosition] .
   Ref          = Type OUT .
   NoType       = .
   ErrorType    = .
>.
Stats           = <
   NoStat       = .
   Stat         = Next: Stats REV <
      Assign    = Adr Expr            [Pos: tPosition] .
      Call      = Actuals             [Ident: tIdent] [Pos: tPosition] .
      If        = Expr Then: Stats Else: Stats .
      While     = Expr Stats .
      Read      = Adr .
      Write     = Expr .
   >.
>.
Actuals         = <
   NoActual     =                     [Pos: tPosition OUT] .
   Actual       = Next: Actuals REV Expr .
>.
Expr            =                     [Pos: tPosition] <
   Binary       = Lop: Expr Rop: Expr [Operator: short] .
   Unary        = Expr                [Operator: short] .
   IntConst     =                     [Value         OUT] .
   RealConst    =                     [Value: double OUT] .
   BoolConst    =                     [Value: bool   OUT] .
   Adr          = <
      Index     = Adr Expr .
      Ident     =                     [Ident: tIdent] .
   >.
>.
Coercions       = <
   NoCoercion   = .
   Coercion     = Next: Coercions OUT <
      Content   = .             /* fetch contents of location    */
      IntToReal = .             /* convert integer value to real */
   >.
>.

END AbstractSyntax

MODULE Output /* -------------------------------------------------- */

PROPERTY OUTPUT

DECLARE
   Formals Decls        = [Decls: tObjects THREAD] .
   Call Ident           = [Object: tObjects] [level: short] .
   If While             = [Label1] [Label2] .
   Read Write Binary    = [TypeCode: short] .
   Expr                 = Type Co: Coercions .
   Index                = type: Type .

END Output
.fi
.bp
.uh "Appendix 2.2: Generation of Intermediate Code"
.sp
.(l L
.FT
TRAFO ICode TREE Tree Definitions PUBLIC Code

EXTERN
   ADD BoolType CHK ENT Emit EmitReal FJP FLT FalseCode INV IXA IntType JMP JSR
   LDA LDC LDI LES MST MUL REA RET RealType STI SUB TrueCode TypeSize WRI

GLOBAL {
# include "Tree.h"
# include "Definitions.h"
# include "Types.h"
# include "ICodeInter.h"
}

PROCEDURE Code (t: Tree)

MiniLax (Proc) ?
        Code (Proc);
        .
Proc (Next := Next:Decls (Proc3 (ParSize := ParSize, DataSize := DataSize), ..),
                Decls := Decls, Stats := Stats) ?
        Emit (ENT, DataSize - ParSize, 0);
        Code (Stats);
        Emit (RET, 0, 0);
        Code (Decls);
        Code (Next);
        .
Var (Next := Next) ?
        Code (Next);
        .
Assign (Next, Adr, Expr, _) ?
        Code (Adr); Code (Adr::Co);
        Code (Expr); Code (Expr::Co);
        Emit (STI, 0, 0);
        Code (Next);
        .
Call (Next, Actuals, _, _, Proc3 (Level := Level, Label := Label,
                ParSize := ParSize), level) ?
        Emit (MST, level - Level, 0);
        Code (Actuals);
        Emit (JSR, ParSize - 3, Label);
        Code (Next);
        .
If (Next, Expr, Then, Else, Label1, Label2) ?
        Code (Expr); Code (Expr::Co);
        Emit (FJP, Label1, 0);
        Code (Then);
        Emit (JMP, Label2, 0);
        Code (Else);
        Code (Next);
        .
While (Next, Expr, Stats, Label1, Label2) ?
        Emit (JMP, Label2, 0);
        Code (Stats);
        Code (Expr); Code (Expr::Co);
        Emit (INV, 0, 0);
        Emit (FJP, Label1, 0);
        Code (Next);
        .
Read (Next, Adr, TypeCode) ?
        Code (Adr); Code (Adr::Co);
        Emit (REA, TypeCode, 0);
        Emit (STI, 0, 0);
        Code (Next);
        .
Write (Next, Expr, TypeCode) ?
        Code (Expr); Code (Expr::Co);
        Emit (WRI, TypeCode, 0);
        Code (Next);
        .
Actual (Next, Expr) ?
        Code (Expr); Code (Expr::Co);
        Code (Next);
        .
Binary (_, _, _, Lop, Rop, {Times}, TypeCode) ?
        Code (Lop); Code (Lop::Co);
        Code (Rop); Code (Rop::Co);
        Emit (MUL, TypeCode, 0);
        .
Binary (_, _, _, Lop, Rop, {Plus}, TypeCode) ?
        Code (Lop); Code (Lop::Co);
        Code (Rop); Code (Rop::Co);
        Emit (ADD, TypeCode, 0);
        .
Binary (_, _, _, Lop, Rop, {Less}, TypeCode) ?
        Code (Lop); Code (Lop::Co);
        Code (Rop); Code (Rop::Co);
        Emit (LES, TypeCode, 0);
        .
Unary (Expr := Expr) ?
        Code (Expr); Code (Expr::Co);
        Emit (INV, 0, 0);
        .
IntConst  (Value := Value  ) ? Emit (LDC, IntType, Value); .
RealConst (Value := Value  ) ? EmitReal (LDC, RealType, Value); .
BoolConst (Value := {true} ) ? Emit (LDC, BoolType, TrueCode); .
BoolConst (Value := {false}) ? Emit (LDC, BoolType, FalseCode); .

Index (_, _, _, Adr, Expr, Array (Type, Lwb, Upb, _)) ?
        Code (Adr); Code (Adr::Co);
        Code (Expr); Code (Expr::Co);
        Emit (CHK, Lwb, Upb);
        Emit (LDC, IntType, Lwb);
        Emit (SUB, IntType, 0);
        Emit (IXA, TypeSize (Type), 0);
        .
Ident (_, _, _, Ident, Var3 (Level := Level, Offset := Offset), level) ?
        Emit (LDA, level - Level, Offset);
        .
Content (Next) ?
        Emit (LDI, 0, 0);
        Code (Next);
        .
IntToReal (Next) ?
        Emit (FLT, 0, 0);
        Code (Next);
        .
.bp
.uh "Appendix 2.3: Procedures for Type Handling"
.sp
.(l L
.FT
TRAFO Types PUBLIC

Reduce                  /* return type without any ref levels           */

ReduceToRef             /* return type with ref level 1                 */

Reduce1                 /* return type with 1 ref level removed         */

RefLevel                /* return number of ref levels of a type        */

IsSimpleType            /* check whether a type is simple               */

IsCompatible            /* check whether two types are compatible       */

IsAssignmentCompatible  /* check whether two types are                  */
                        /* assignment compatible                        */

ResultType              /* return the type of the result of             */
                        /* applying an operator to two operands         */

CheckParams             /* check a formal list of parameters            */
                        /* against an actual list of parameters         */

GetElementType          /* return the type of the elements of           */
                        /* an array type                                */

TypeSize                /* return the number of bytes used for          */
                        /* the internal representation of an            */
                        /* object of a certain type                     */

Coerce                  /* returns the coercion necessary to convert    */
                        /* an object of type 't1' to type 't2'          */

EXTERN nBoolean Error nNoCoercion

GLOBAL {
# include "Errors.h"
# include "Positions.h"
# include "Tree.h"

# define Error(Text, Position) Message (Text, xxError, Position)

static tTree nBoolean, nNoType, nNoCoercion;
}

BEGIN {
   nBoolean     = mBoolean      ();
   nNoType      = mNoType       ();
   nNoCoercion  = mNoCoercion   ();
}

FUNCTION Reduce (Type) Type
   Ref (t)      RETURN Reduce (t) ?.
   t            RETURN t ?.

FUNCTION ReduceToRef (Type) Type
   Ref (t:Ref)  RETURN ReduceToRef (t) ?.
   t:Ref        RETURN t ?.
   t            RETURN t ?.

FUNCTION Reduce1 (Type) Type
   Ref (t)      RETURN t ?.
   t            RETURN t ?.

FUNCTION RefLevel (Type) int
   Ref (t)      RETURN RefLevel (t) + 1 ?.
   _            RETURN 0 ?.

PREDICATE IsSimpleType (Type)
   Array        ? FAIL; .
   _            ?.

PREDICATE IsCompatible (Type, Type)
   Integer      , Integer       ?.
   Real         , Real          ?.
   Boolean      , Boolean       ?.
   Array (t1, Lwb, Upb, _), Array (t2, Lwb, Upb, _) ;
   Ref (t1)     , t2            ;
   t1           , Ref (t2)      ? IsCompatible (t1, t2); .
   NoType       , _             ?.
   _            , NoType        ?.
   ErrorType    , _             ?.
   _            , ErrorType     ?.

PREDICATE IsAssignmentCompatible (Type, Type)
   Integer      , Integer       ?.
   Real         , Real          ?.
   Real         , Integer       ?.
   Boolean      , Boolean       ?.
   Ref (t1)     , t2            ;
   t1           , Ref (t2)      ? IsAssignmentCompatible (t1, t2); .
   NoType       , _             ?.
   _            , NoType        ?.
   ErrorType    , _             ?.
   _            , ErrorType     ?.

FUNCTION ResultType (Type, Type, int) Type
   t:Integer    , Integer       , { Plus }      RETURN t        ?.
   t:Real       , Real          , { Plus }      RETURN t        ?.
   t:Integer    , Integer       , { Times }     RETURN t        ?.
   t:Real       , Real          , { Times }     RETURN t        ?.
   Integer      , Integer       , { Less }      RETURN nBoolean ?.
   Real         , Real          , { Less }      RETURN nBoolean ?.
   t:Boolean    , Boolean       , { Less }      RETURN t        ?.
   t:Boolean    , _             , { Not }       RETURN t        ?.
   Ref (t1)     , t2            , o             ;
   t1           , Ref (t2)      , o             RETURN ResultType (t1, t2, o) ?.
   t:NoType     , _             , _             RETURN t        ?.
   _            , t:NoType      , _             RETURN t        ?.
   ErrorType    , _             , _             RETURN NoType   ?.
   _            , ErrorType     , _             RETURN NoType   ?.
   ..                                           RETURN ErrorType?.

PROCEDURE CheckParams (Actuals, Formals)
   NoActual     , NoFormal      ?.
   NoActual (Pos), _            ?
      Error ("too few actual parameters"        , Pos); .
   Actual (_, Expr (Pos, ..)), NoFormal ?
      Error ("too many actual parameters"       , Pos); .

/* alternative 1 */

   Actual (NextA, Expr (Pos, TypeA, ..)), Formal (_, _, NextF, _, _, TypeF) ?
      {
         if (! IsCompatible (TypeA, TypeF))
            Error ("parameter type incompatible", Pos);
         if (! (RefLevel (TypeF) - 1 <= RefLevel (TypeA)))
            Error ("variable required"          , Pos);
      };
      CheckParams (NextA, NextF); .

/* alternative 2 */

   Actual (NextA, Expr (Pos, TypeA, ..)), Formal (_, _, NextF, _, _, TypeF) ?
      ! IsCompatible (TypeA, TypeF);
      Error ("parameter type incompatible"      , Pos);
      REJECT; .

   Actual (NextA, Expr (Pos, TypeA, ..)), Formal (_, _, NextF, _, _, TypeF) ?
      ! (RefLevel (TypeF) - 1 <= RefLevel (TypeA));
      Error ("variable required"                , Pos);
      REJECT; .

   Actual (NextA, Expr (Pos, TypeA, ..)), Formal (_, _, NextF, _, _, TypeF) ?
      CheckParams (NextA, NextF); .

/* alternative 3 */

   Actual (NextA, Expr (Pos, TypeA, ..)), Formal (_, _, NextF, _, _, TypeF) ?
      CheckCompatible (Pos, TypeA, TypeF);
      CheckRefLevel (Pos, TypeA, TypeF);
      CheckParams (NextA, NextF); .

PROCEDURE CheckCompatible (tPosition, Type, Type)
   _    , t1    , t2    ? IsCompatible (t1, t2); .
   Pos  , ..            ? Error ("parameter type incompatible"  , Pos); .

PROCEDURE CheckRefLevel (tPosition, Type, Type)
   _    , t1    , t2    ? RefLevel (t2) - 1 <= RefLevel (t1); .
   Pos  , ..            ? Error ("variable required"            , Pos); .

FUNCTION GetElementType (Type) Type
   Array (t, ..)        RETURN t ?.
   _                    RETURN NoType ?.

FUNCTION TypeSize (Type) int
   Array (t, Lwb, Upb, _)       RETURN (Upb - Lwb + 1) * TypeSize (t) ?.
   _                            RETURN 1 ?.

FUNCTION Coerce (t1: Type, t2: Type) Coercions
   Ref (T1)     , Ref (T2)      RETURN Coerce (T1, T2) ?.
   Integer      , Real          RETURN IntToReal (nNoCoercion) ?.
   Ref (T1)     , T2            RETURN Content (Coerce (T1, T2)) ?.
   ..                           RETURN nNoCoercion ?.
.)l
.bp
.uh "Appendix 3: Equality Operations"
.uh "Appendix 3.1: C"
.sp
.nf
.FT
# define equalint(a, b)         a == b
# define equalshort(a, b)       a == b
# define equallong(a, b)        a == b
# define equalunsigned(a, b)    a == b
# define equalfloat(a, b)       a == b
# define equaldouble(a, b)      a == b
# define equalbool(a, b)        a == b
# define equalchar(a, b)        a == b
# define equaltString(a, b)     strcmp (a, b)
# define equaltStringRef(a, b)  a == b
# define equaltIdent(a, b)      a == b
# define equaltSet(a, b)        IsEqual (& a, & b)
# define equaltPosition(a, b)   Compare (a, b) == 0
.fi
.uh "Appendix 3.2: Modula-2"
.sp
.nf
.FT
# define equalINTEGER(a, b)     a = b
# define equalSHORTINT(a, b)    a = b
# define equalLONGINT(a, b)     a = b
# define equalCARDINAL(a, b)    a = b
# define equalSHORTCARD(a, b)   a = b
# define equalLONGCARD(a, b)    a = b
# define equalREAL(a, b)        a = b
# define equalLONGREAL(a, b)    a = b
# define equalBOOLEAN(a, b)     a = b
# define equalCHAR(a, b)        a = b
# define equalBITSET(a, b)      a = b
# define equalBYTE(a, b)        a = b
# define equalWORD(a, b)        a = b
# define equalADDRESS(a, b)     a = b
# define equaltString(a, b)     Strings.IsEqual (a, b)
# define equaltStringRef(a, b)  a = b
# define equaltIdent(a, b)      a = b
# define equaltText(a, b)       FALSE
# define equaltSet(a, b)        Sets.IsEqual (a, b)
# define equaltRelation(a, b)   Relations.IsEqual (a, b)
# define equaltPosition(a, b)   Positions.Compare (a, b) = 0
.fi
.fi
.sz 12
.[]
.[-
.ds [F Gro90
.ds [A J\*(p] Grosch
.ds [T Specification of a Minilax Interpreter
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [R Compiler Generation Report No. 22
.ds [N 22
.ds [D Mar. 1990
.][
.[-
.ds [F Gro91
.ds [A J\*(p] Grosch
.ds [T Ast - A Generator for Abstract Syntax Trees
.ds [I GMD Forschungsstelle an der Universit\\*:at Karlsruhe
.ds [R Compiler Generation Report No. 15
.ds [N 15
.ds [D Sep. 1991
.][
.bp 1
.lp
.b Contents
.sp
.xp
